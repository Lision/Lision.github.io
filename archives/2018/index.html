<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2018 | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/archives/2018/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	


	<section class="page-header archive">
    <h1>- <span>2018</span> -</h1>
  </section>




<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/summary_for_2018/">
      写在 2018 年的最后一天
    </a>
  </h2>
  
  <time>
    12月 31, 2018
  </time>
  <section class="content">
	  <img src="/summary_for_2018/sundial.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>打眼一瞧，上一篇文章还是十一长假的时候由于旅行计划破灭后闲着无聊破解 Bartender 时写的，这一转眼的功夫就到了元旦假期了…</p>
<p>Emmmmm… 本来已经放弃要写年末总结的~</p>
<p>众所周知，写年末总结约等于自抽嘴巴。末了还要对应着列出新一年的计划，为明年年末相同的环节埋下伏笔。一般来说，年初的计划写的越是<strong>具体、生动、形象</strong>，年末的嘴巴抽的就越是<strong>啪！啪！！啪！！！</strong></p>
<p>让我惊喜的是，我的年初计划之前没有记到博客里，翻了一下仅有的一篇相关内容的文章<a href="https://lision.me/2017_2018/">《嘛~ 又一年了啊…》</a>，里面并没有什么具体的自定 KPI~</p>
<blockquote>
<p>原来我是这么的深谋远虑，早就想好了这一天的到来 😂</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>工作篇</li>
<li>技术篇</li>
<li>生活篇</li>
<li>总结</li>
</ul>
<h2 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h2><p>嘛~ 这一年在工作中的整体表现算是达到了自己的预期，里程碑如下：</p>
<ul>
<li>年初接到了美团外卖团队的 Offer 并成功入职</li>
<li>参加美团·点评技术通道秋季晋级答辩并成功晋升</li>
</ul>
<p>年初的 Offer 抉择没让自己后悔，这一年外卖商家侧的业务发展很迅猛，随之而言工作中面临的挑战也很多，工作内容充实。我的老板对组员和其自身都有着很高的要求，有一个优秀的 Leader 是一件很幸运的事，因为他（她）会直接决定你所处团队的方方面面。</p>
<h2 id="技术篇"><a href="#技术篇" class="headerlink" title="技术篇"></a>技术篇</h2><p>这一年在技术方面值得记录的事：</p>
<ul>
<li>年初在 GitHub 开源了两个轮子，一年维护下来虽然累，但从中收获不少</li>
<li>加入了 <a target="_blank" rel="noopener" href="https://weibo.com/swiftguide">@SwiftGG 翻译组</a> 并参与了一些优质文章的校对工作</li>
<li>阅读了一些公司内部自己感兴趣的源码</li>
</ul>
<h3 id="关于开源"><a href="#关于开源" class="headerlink" title="关于开源"></a>关于开源</h3><img src="/summary_for_2018/github.jpg" class="">
<p>Emmmmm… 年初的时候写了两个开源项目：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator">LSAnimator</a> - An easy to read and write, non-invasive multi-chain animation framework, inspired by JHChainableAnimations.</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Lision/WKWebViewJavascriptBridge">WKWebViewJavascriptBridge</a> - A Bridge for Sending Messages between Swift and JavaScript in WKWebViews.</li>
</ul>
<p>早在开坑时就做好了填坑的觉悟，得益于推广之前有写覆盖较为全面的单测用例并配置了 Travis-CI，这一年来两个开源项目并未对使用者造成任何负面影响，用户提的 Issue 也都有抽出时间解答 &amp; 处理。</p>
<h3 id="阅读-amp-实践"><a href="#阅读-amp-实践" class="headerlink" title="阅读 &amp; 实践"></a>阅读 &amp; 实践</h3><blockquote>
<p>「纸上得来终觉浅，绝知此事要躬行。」</p>
</blockquote>
<p>对于这句话的理解越发深刻了，自己之前在书本上学到过的知识好多都没有动手实践过，今年在学习时多次有茅塞顿开的感觉。经过复盘，这种感觉产生的根本原因是自己之前阅读技术书籍时没有完全弄明白，类似于在脑中记录了一个符号，在后期阅读源码 &amp; 解决问题时找到了该符号的对应实现体（笑）。</p>
<h2 id="生活篇"><a href="#生活篇" class="headerlink" title="生活篇"></a>生活篇</h2><img src="/summary_for_2018/game.jpg" class="">
<p>工作之余我的时间主要花费在电子游戏上面 😂 今年又败了一些游戏：</p>
<ul>
<li>《马里奥赛车 8 豪华版》</li>
<li>《龙珠斗士 z》</li>
<li>《精灵宝可梦 Let’s go 皮卡丘》</li>
<li>《任天堂全明星大乱斗 sp》</li>
<li>《Dead Cell》</li>
<li>《传说法师》</li>
<li>《空洞骑士》</li>
</ul>
<blockquote>
<p>Ps: 为了玩大乱斗还入手了 Switch Pro 手柄，不过 Pro 手柄的操控感真的是非常让我惊喜，想不到任天堂这种品控也能有这种精品外设产出（手动滑稽）。</p>
</blockquote>
<p>遗憾的是，自己貌似并没有太多时间去享受这些游戏，最为典型的应该是 2016 年入手的《黑暗之魂 III》，到现在还都是未开封状态 o(╯□╰)o … </p>
<blockquote>
<p>感觉一过了 25 周岁之后身体机能大不如前了，最明显的区别就是现在下班回家之后开机器的意愿非常弱，周末几乎不会有通宵肝游戏的想法出现。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Emmmmm… 感觉这一年来最大的变化是写文章的意愿越来越弱了，其实计划中是有很多东西想转为文字沉淀在自己的博客里的，奈何要做的事情太多，时间却又太少。有些东西当时梳理成了笔记（方便自己回顾），随着时间的推移也就不想再写成文章发出来了…</p>
<p>通过复盘也发现自己对于生活的态度过于随意，导致年末复盘几乎没什么可写的东西，准备在明年的年度计划中明确生活相关的各项指标，现在想到的有理财，健身，观影，游戏…</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/summary/" rel="tag">summary</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/mac_re_bartender/">
      逆向 Mac 应用 Bartender
    </a>
  </h2>
  
  <time>
    10月 1, 2018
  </time>
  <section class="content">
	  <img src="/mac_re_bartender/header_pic.png" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>本文内容<strong>仅作为学习交流</strong>，希望大家多多支持正版软件。</p>
<p>Emmmmm… 其实最初是准备写一篇关于 iOS 应用的逆向笔记的，不过一直没找到合适的目标 App 以及难度适宜的功能点来作为写作素材… </p>
<p>破解了 Bartender 之后我觉得对于 Bartender 的破解过程难度适中，非常适合当做素材来写，且不论是 Mac App 还是 iOS App，逆向的思路都是相通的，所以就写了这篇文章~</p>
</blockquote>
<p>国庆之前，果果放出了最新操作系统 macOS Mojave 的正式版本，相信很多小伙伴都跟我一样在正式版发布后紧跟着就升级了系统（此前由于工作设备参与项目产出需要确保系统稳定性所以没敢尝鲜的同学应该不只我一个人哈）。</p>
<p>升级到正式版 macOS Mojave 之后，我兴致勃勃的在新系统中各处探索了一番，然后将系统切换到 Dark Mode 后打开 Xcode 心满意足地敲（搬）起了代码（砖）… </p>
<p>嘛~ 又是一个惬意的午后，有时候人就是这么容易满足（笑）~ </p>
<p>等等！这是什么鬼！？我的 Bartender 怎么不能正常工作了（其实现在回想起来应该是试用期到期了）…</p>
<img src="/mac_re_bartender/bartender_invalid.png" class="">
<p>本文将以 Bartender 为目标 App，讲解如何通过静态分析工具 Hopper 逐步分析 Bartender 的内部实现逻辑并结合动态分析等手段逐步破解 Bartender 的过程与思路~</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Bartender</li>
<li>Hopper</li>
<li>逆向过程 &amp; 思路</li>
<li>总结</li>
</ul>
<h2 id="Bartender"><a href="#Bartender" class="headerlink" title="Bartender"></a>Bartender</h2><img src="/mac_re_bartender/bartender_show.jpg" class="">
<img src="/mac_re_bartender/bartender_hide.jpg" class="">
<p><a target="_blank" rel="noopener" href="https://www.macbartender.com/">Bartender</a> 是一款可以帮助我们整理屏幕顶部菜单栏图标的工具。</p>
<p>随着我们安装的 App 不断增多，屏幕顶部菜单栏上面的图标也会对应不断增加。这些 App 的图标并非出自一家之手，风格各异，随着数目增多逐渐显得杂乱不堪。</p>
<p>我们可以通过 Bartender 来<strong>隐藏</strong>或<strong>重新排列</strong>这些恼人的小图标，可以将没什么用但是运行起来却要显示的 App 图标<strong>始终隐藏</strong>，将偶尔会用的 App 图标隐藏到 Bartender 功能按钮后面（用到的时候可以通过点击 Bartender 功能按钮<strong>切换显隐</strong>），只显示常用的或者我们认为好看的应用图标。</p>
<p>除此之外 Bartender 还具备一些其他更加深入的功能（比如支持全部菜单栏条目范围的搜索等等），毫无疑问它是一款非常棒的菜单栏图标管理工具。</p>
<img src="/mac_re_bartender/bartender_honor.jpg" class="">
<blockquote>
<p>Note: 重申，Bartender 仅售 15 刀，还是推荐各位使用正版，本文仅作为学习交流。</p>
</blockquote>
<h2 id="Hopper"><a href="#Hopper" class="headerlink" title="Hopper"></a>Hopper</h2><img src="/mac_re_bartender/hopper_darkmode.jpg" class="">
<p><a target="_blank" rel="noopener" href="https://www.hopperapp.com/">Hopper</a> 是一款不错的 mac OS 与 Linux 反汇编工具，同时还提供一定的反编译能力，可以利用它来调试我们的程序。此外，Hopper 还支持控制流视图模式，Python 脚本，LLDB &amp; GDB，并且提供了 Hopper SDK 可供扩展，在 Hopper SDK 的基础上你甚至可以扩展自己的文件格式和 CPU 支持。</p>
<p>值得一提的是 Hopper 的作者是一名独立开发者，他的日常工作环境也是在 mac OS 上，所以在 mac OS 上的 Hopper 是完全使用 Cocoa Framework 实现的，而 Linux 版本的 Hopper 则选择使用 Qt 5 来实现。</p>
<p>个人认为 Hopper 在 mac OS 上面的运行表现非常好，很多细节（比如类型颜色区分等）都做的不错，功能简洁的同时快捷键也很好记（Hopper 提供的功能已经覆盖了绝大多数使用场景）。</p>
<p>最关键的一点是收费良心，个人证书只要 99 刀，当之无愧的人人都买得起的逆向工具！当然如果你觉得贵，Hopper 还提供试用，试用形式类似于 Charles，每次开启后可以试用 30 分钟，一般情况下这已经够用了。</p>
<blockquote>
<p>Note: Hopper v4.4.0 支持 Mojave Dark Mode。</p>
</blockquote>
<h2 id="逆向过程-amp-思路"><a href="#逆向过程-amp-思路" class="headerlink" title="逆向过程 &amp; 思路"></a>逆向过程 &amp; 思路</h2><p>这一章节的内容会详细的讲述我个人在破解 Bartender 过程中的想法以及中间遇到问题时解决问题的思路，之前没有涉足逆向或者逆向经验尚浅的同学可能会觉得比较晦涩，这种情况最好结合自己的实际操作反复阅读没有理解的地方直到真正弄明白为止。</p>
<p>相信自己，每一份努力终会有所回报！当有朝一日自己也可以通过自己的逆向技术破解 &amp; 定制化自己感兴趣的 App 时，你会发现一切的努力都是值得的。</p>
<h3 id="获取目标二进制"><a href="#获取目标二进制" class="headerlink" title="获取目标二进制"></a>获取目标二进制</h3><p>从 <a target="_blank" rel="noopener" href="https://www.macbartender.com/">Bartender 官网</a>下载最新的 Bartender，截止本文提笔之前 Bartender 的最新版本为 3.0.47。</p>
<p>将下载好的压缩包解压之后得到 Bartender 3.app，将 Bartender 3.app 文件复制到自己的 Application 文件夹下。右键点击 Bartender 3.app 选择“显示包内容”，在 Contents 目录下找到 MacOS 目录，里面有我们要的目标二进制文件 Bartender 3。</p>
<h3 id="从“授权”着手"><a href="#从“授权”着手" class="headerlink" title="从“授权”着手"></a>从“授权”着手</h3><p>打开 Hopper，将目标二进制文件拖入 Hopper，在弹出的弹窗中选择 OK 后等待 Hopper 分析完毕。</p>
<img src="/mac_re_bartender/hopper_interface.jpg" class="">
<p>在左侧的分栏中选择 <code>Proc.</code> ，这可以让我们查看 Hopper 分析出来的方法。分栏下面有搜索框，内部可以通过输入关键词来过滤出我们想要的结果。因为一般的 App 都是通过某些方法判断是否授权的，这里我们先输入 <code>is</code> （注意 is 前面加空格），然后观察过滤出来的结果。</p>
<img src="/mac_re_bartender/hopper_filter.jpg" class="">
<p>果不其然，发现里面有三个 <code>[xxx isLicensed]</code> 方法，点击方法 Hopper 会跳转至方法处。</p>
<blockquote>
<p>Note: 三处 <code>[xxx isLicensed]</code> 的方法内部逻辑几乎一样，这里拿 <code>[Bartender_3.AppDelegate isLicensed]</code> 讲解，其他两处不做赘述。</p>
</blockquote>
<img src="/mac_re_bartender/is_licensed.png" class="">
<p>Emmmmm… 这里的汇编代码还是比较简单的，虽然我不是很了解 x86 的汇编指令，不过 Hopper 已经帮助我们做了一些辅助性工作。其中开始处的 <code>push rbp</code> 以及结束处 <code>pop rbp</code> 可以简单理解为入栈出栈，<code>call sub_100067830</code> 可以理解为调用地址 <code>0x100067830</code> 处的方法，<code>pop</code> 之前的 <code>movsx eax, al</code> 和 ARM64 中的 <code>mov</code> 指令类似，可以理解为将 <code>al</code> 内存储的东西移动到 <code>eax</code> 寄存器中，<strong><code>eax</code> 寄存器用于存储 x86 的方法返回值</strong>。</p>
<p>我们可以看出这里调用了地址 <code>0x100067830</code> 处的函数，拿到结果之后又调用了 <code>imp___stubs__$S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF</code> 方法将结果做了转化，最后将结果赋值给 eax 寄存器用于结果返回。其中 <code>imp___stubs__$S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF</code> 我们可以根据名称推测出该方法的作用应该是将 <code>Bool</code> 转化为 Objective-C 的 BOOL 而已。</p>
<p>那么关键信息应该在 <code>sub_100067830</code> 处，双击 <code>sub_100067830</code> Hopper 会跳转到 <code>0x100067830</code> 处，这样我们就可以分析其中的具体实现了。不过 <code>0x100067830</code> 内部的实现比较复杂，跳转过去之后发现汇编代码非常多，还有很多跳转… 这时候我们可以通过 Hopper 顶部中间靠右一点的分栏，点击显示为 <code>if(b) f(x);</code> 的按钮查看伪代码。</p>
<p>Hopper 解析出来的伪代码风格类似 Objective-C 代码，可以看到 <code>0x100067830</code> 内部通过 <code>NSUserDefaults</code> 以及其他的逻辑实现，其中还包括其他的形式为 <code>sub_xxxxxx</code> 的方法调用，这种情况下如果我们继续跳转到这些方法的地址查看其内部实现很有可能陷入递归中… </p>
<img src="/mac_re_bartender/sub_100067830.jpg" class="">
<p>那么这种情况该如何处理呢？</p>
<p>分析问题，我们找到 <code>[xxx isLicensed]</code> 并且觉得这有可能就是 Bartender 中判断授权与否的函数，那么我们只需要将三处 <code>[xxx isLicensed]</code> 的返回值改为 <code>true</code> 即可。所以这里我们没有必要一步步的看其内部实现，先返回 <code>[Bartender_3.AppDelegate isLicensed]</code> 处。前面讲过在 x86 汇编中 <code>eax</code> 寄存器用于存储方法的返回值，我们在 <code>[Bartender_3.AppDelegate isLicensed]</code> 按快捷键 <code>option + A</code> 插入汇编代码 <code>mov eax, 0x1</code> 将 <code>eax</code> 永远赋值为 <code>1</code> 即 <code>true</code> 之后跟 <code>ret</code> 即 return 指令直接让函数返回 <code>true</code> 就可以达到我们的目的了。</p>
<img src="/mac_re_bartender/hopper_return_0x1.png" class="">
<p>用快捷键 <code>shift + command + E</code> 导出二进制文件，覆盖到原 Bartender 目录中，尝试运行。你会发现一开始是成功的，屏幕顶部的菜单栏图标也被正常管理了，但是过了大约 10s 之后一切又变回了原样，并且还会弹出一个试用期到期的弹窗…</p>
<img src="/mac_re_bartender/bartender_trialended.jpg" class="">
<h3 id="重拾思路"><a href="#重拾思路" class="headerlink" title="重拾思路"></a>重拾思路</h3><p>那么我们刚才修改的三处 <code>[xxx isLicensed]</code> 为什么没有产生作用呢？其实它已经产生作用了，虽然我们不可以正常使用 Bartender，但是打开 Bartender 的 License 界面我们可以发现这里的界面已经显示我们付过款了，<strong>尽管这并没有什么卵用就是了…</strong></p>
<img src="/mac_re_bartender/bartender_paid.jpg" class="">
<p>到这里我们似乎没有什么头绪了，因为延时方法有很多，光是凭借这一条线索很难定位到阻止我们破解的目标代码位置。</p>
<p>逆向过程中的思路很重要，如果<strong>遇到思路断了的情况不要着急也不要气馁</strong>，我们可以重新运行程序，尝试不同的操作并观察操作对应的表现 &amp; 结果。</p>
<p>经过反复运行程序，我发现每次重新启动 Bartender 都可以有大约 10s 的可用时间，如果启动之后直接主动点击 Bartender 的功能按钮则会直接弹出试用期到期弹窗且顶部菜单栏图标也会直接回到之前杂乱的样子。</p>
<p>这时候我的思路从延时方法转移到了这个 Trial ended 弹窗以及 Bartender 的功能按钮点击之后的对应方法上。这就是<strong>动态分析</strong>，它可以帮助我们重新找回思路。</p>
<h3 id="按钮响应方法"><a href="#按钮响应方法" class="headerlink" title="按钮响应方法"></a>按钮响应方法</h3><p>有了思路，对应的方法并不难找。我们可以利用 Hopper 的 Tag Scope 先把可能出现的区域找出来，再到对应的区域下的方法列表中寻找我们的目标方法位置。</p>
<img src="/mac_re_bartender/hopper_tag_scope.jpg" class="">
<img src="/mac_re_bartender/status_item_click.png" class="">
<p>这里我很快就找到了目标函数 <code>-[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:]</code>, 其内部调用了 <code>sub_100029ac0(arg2);</code> 其中 <code>arg2</code> 就是 <code>sender</code>，也就是这个 Bartender 的功能按钮了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sub_100029ac0(<span class="type">int</span> arg0) &#123;</span><br><span class="line">    sub_100022840(arg0);</span><br><span class="line">    rbx = **_NSApp;</span><br><span class="line">    <span class="keyword">if</span> (rbx == <span class="number">0x0</span>) <span class="keyword">goto</span> loc_100029f44;</span><br><span class="line"></span><br><span class="line">loc_100029ae7:</span><br><span class="line">    [rbx <span class="keyword">retain</span>];</span><br><span class="line">    r14 = [[rbx currentEvent] <span class="keyword">retain</span>];</span><br><span class="line">    rdi = rbx;</span><br><span class="line">    <span class="keyword">if</span> (r14 == <span class="number">0x0</span>) <span class="keyword">goto</span> loc_100029bef;</span><br><span class="line"></span><br><span class="line">loc_100029b18:</span><br><span class="line">    [rdi release];</span><br><span class="line">    <span class="keyword">if</span> (([r14 modifierFlags] &amp; <span class="number">0x80000</span>) != <span class="number">0x0</span>) <span class="keyword">goto</span> loc_100029b6e;</span><br><span class="line"></span><br><span class="line">loc_100029b33:</span><br><span class="line">    [r14 <span class="keyword">retain</span>];</span><br><span class="line">    <span class="keyword">if</span> ((([r14 modifierFlags] &amp; <span class="number">0x40000</span>) != <span class="number">0x0</span>) || ([r14 type] == <span class="number">0x4</span>)) <span class="keyword">goto</span> loc_100029b66;</span><br><span class="line"></span><br><span class="line">loc_100029bcc:</span><br><span class="line">    rbx = [r14 type];</span><br><span class="line">    [r14 release];</span><br><span class="line">    <span class="keyword">if</span> (rbx == <span class="number">0x3</span>) <span class="keyword">goto</span> loc_100029b6e;</span><br><span class="line"></span><br><span class="line">loc_100029bec:</span><br><span class="line">    rdi = r14;</span><br><span class="line">    <span class="keyword">goto</span> loc_100029bef;</span><br><span class="line"></span><br><span class="line">loc_100029bef:</span><br><span class="line">    [rdi release];</span><br><span class="line">    r14 = [[swift_getInitializedObjCClass(<span class="class"><span class="keyword">@class</span>(<span class="title">NSUserDefaults</span>)) <span class="title">standardUserDefaults</span>] <span class="title">retain</span>];</span></span><br><span class="line">    <span class="keyword">if</span> (*qword_1000e7e70 != <span class="number">0xffffffffffffffff</span>) &#123;</span><br><span class="line">            swift_once(qword_1000e7e70, sub_100069790);</span><br><span class="line">    &#125;</span><br><span class="line">    rbx = *qword_1000ee1f8;</span><br><span class="line">    r15 = *qword_1000ee200;</span><br><span class="line">    swift_bridgeObjectRetain(rbx);</span><br><span class="line">    r15 = (extension <span class="keyword">in</span> Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, r15);</span><br><span class="line">    swift_bridgeObjectRelease(rbx);</span><br><span class="line">    rbx = [[r14 objectForKey:r15] <span class="keyword">retain</span>];</span><br><span class="line">    [r15 release];</span><br><span class="line">    [r14 release];</span><br><span class="line">    <span class="keyword">if</span> (rbx != <span class="number">0x0</span>) &#123;</span><br><span class="line">            swift_getObjectType(rbx);</span><br><span class="line">            var_50 = rbx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            intrinsic_movaps(var_40, <span class="number">0x0</span>);</span><br><span class="line">            var_50 = intrinsic_movaps(var_50, <span class="number">0x0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rax = sub_10001c9a0(&amp;var_50, &amp;var_78);</span><br><span class="line">    <span class="keyword">if</span> (var_58 != <span class="number">0x1</span>) <span class="keyword">goto</span> loc_100029cd8;</span><br><span class="line"></span><br><span class="line">loc_100029ccd:</span><br><span class="line">    sub_10001c2f0(&amp;var_78);</span><br><span class="line">    <span class="keyword">goto</span> loc_100029d44;</span><br><span class="line"></span><br><span class="line">loc_100029d44:</span><br><span class="line">    <span class="keyword">if</span> (*(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded) == <span class="number">0x1</span>) &#123;</span><br><span class="line">            rax = sub_1000230e0(<span class="number">0x1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            *(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks) = <span class="number">0x1</span>;</span><br><span class="line">            rax = sub_1000215f0();</span><br><span class="line">            <span class="keyword">if</span> ((rax &amp; <span class="number">0x1</span>) == <span class="number">0x0</span>) &#123;</span><br><span class="line">                    rbx = *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks;</span><br><span class="line">                    rax = *(int8_t *)(r13 + rbx);</span><br><span class="line">                    rax = !rax &amp; <span class="number">0x1</span>;</span><br><span class="line">                    *(int8_t *)(r13 + rbx) = rax;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line"></span><br><span class="line">loc_100029cd8:</span><br><span class="line">    rcx = *qword_1000e8a98;</span><br><span class="line">    <span class="keyword">if</span> (rcx == <span class="number">0x0</span>) &#123;</span><br><span class="line">            rcx = swift_getObjCClassMetadata(swift_getInitializedObjCClass(<span class="class"><span class="keyword">@class</span>(<span class="title">NSDictionary</span>)));</span></span><br><span class="line">            *qword_1000e8a98 = rcx;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = swift_dynamicCast(&amp;var_28, &amp;var_78, *type metadata <span class="keyword">for</span> Any + <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">if</span> (rax == <span class="number">0x0</span>) <span class="keyword">goto</span> loc_100029d44;</span><br><span class="line"></span><br><span class="line">loc_100029d24:</span><br><span class="line">    r14 = var_28;</span><br><span class="line">    <span class="keyword">if</span> ([r14 count] == <span class="number">0x0</span>) <span class="keyword">goto</span> loc_100029d8f;</span><br><span class="line"></span><br><span class="line">loc_100029d3c:</span><br><span class="line">    [r14 release];</span><br><span class="line">    <span class="keyword">goto</span> loc_100029d44;</span><br><span class="line"></span><br><span class="line">loc_100029d8f:</span><br><span class="line">    r15 = [objc_allocWithZone(<span class="class"><span class="keyword">@class</span>(<span class="title">NSAlert</span>)) <span class="title">init</span>];</span></span><br><span class="line">    rbx = sub_1000a7f20(<span class="string">&quot;No menu items have been setup&quot;</span>, <span class="number">0x1d</span>, <span class="number">0x1</span>, rcx, <span class="number">0x6</span>);</span><br><span class="line">    r12 = (extension <span class="keyword">in</span> Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, <span class="number">0x1</span>);</span><br><span class="line">    swift_bridgeObjectRelease(rbx);</span><br><span class="line">    [r15 setMessageText:r12];</span><br><span class="line">    [r12 release];</span><br><span class="line">    rbx = sub_1000a7f20(<span class="string">&quot;No menu items have been setup in Bartender Preferences, so Bartender is not doing anything yet. Would you like to open preferences now.&quot;</span>, <span class="number">0x87</span>, <span class="number">0x1</span>, rcx, <span class="number">0x6</span>);</span><br><span class="line">    r12 = (extension <span class="keyword">in</span> Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, <span class="number">0x1</span>);</span><br><span class="line">    swift_bridgeObjectRelease(rbx);</span><br><span class="line">    [r15 setInformativeText:r12];</span><br><span class="line">    [r12 release];</span><br><span class="line">    [r15 setAlertStyle:<span class="number">0x1</span>];</span><br><span class="line">    rbx = sub_1000a7f20(<span class="string">&quot;Open Preferences&quot;</span>, <span class="number">0x10</span>, <span class="number">0x1</span>, rcx, <span class="number">0x6</span>);</span><br><span class="line">    r12 = (extension <span class="keyword">in</span> Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, <span class="number">0x1</span>);</span><br><span class="line">    swift_bridgeObjectRelease(rbx);</span><br><span class="line">    rbx = [[r15 addButtonWithTitle:r12] <span class="keyword">retain</span>];</span><br><span class="line">    [r12 release];</span><br><span class="line">    [rbx release];</span><br><span class="line">    rbx = sub_1000a7f20(<span class="string">&quot;Dismiss&quot;</span>, <span class="number">0x7</span>, <span class="number">0x1</span>, rcx, <span class="number">0x6</span>);</span><br><span class="line">    r12 = (extension <span class="keyword">in</span> Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, <span class="number">0x1</span>);</span><br><span class="line">    swift_bridgeObjectRelease(rbx);</span><br><span class="line">    rbx = [[r15 addButtonWithTitle:r12] <span class="keyword">retain</span>];</span><br><span class="line">    [r12 release];</span><br><span class="line">    [rbx release];</span><br><span class="line">    <span class="keyword">if</span> ([r15 runModal] == <span class="number">0x3e8</span>) &#123;</span><br><span class="line">            sub_100029a10();</span><br><span class="line">    &#125;</span><br><span class="line">    [r15 release];</span><br><span class="line">    rax = [r14 release];</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line"></span><br><span class="line">loc_100029b6e:</span><br><span class="line">    *(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks) = <span class="number">0x0</span>;</span><br><span class="line">    rdi = r14;</span><br><span class="line">    <span class="keyword">if</span> (([rdi modifierFlags] &amp; <span class="number">0x40000</span>) == <span class="number">0x0</span>) &#123;</span><br><span class="line">            sub_100020de0();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded) == <span class="number">0x1</span>) &#123;</span><br><span class="line">                    sub_1000230e0(<span class="number">0x1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                    sub_100020fe0(rdi);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rax = [r14 release];</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line"></span><br><span class="line">loc_100029b66:</span><br><span class="line">    [r14 release];</span><br><span class="line">    <span class="keyword">goto</span> loc_100029b6e;</span><br><span class="line"></span><br><span class="line">loc_100029f44:</span><br><span class="line">    <span class="keyword">asm</span> &#123; ud2 &#125;;</span><br><span class="line">    rax = sub_100029f46();</span><br><span class="line">    <span class="keyword">return</span> rax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>PS: 为了便于读者结合后面分析部分的内容快速定位（Command + F），上面的伪代码没有使用截图形式展示。</p>
</blockquote>
<p>其中很醒目的是 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 我们按照之前的方法，将伪代码先切回汇编模式，找到对应的汇编代码处。</p>
<img src="/mac_re_bartender/if_trial_ended.png" class="">
<p>这是一段明显的 <code>if</code> 语句汇编代码，看下面的 <code>mov edi, 0x1</code> 这一小节就是指 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 为 <code>true</code> 之后执行的代码，表示<strong>要是试用期到期就执行 <code>0x1000230e0</code> 处的方法</strong>。我们记下这个地址之后把这两处的汇编代码通过上文插入汇编代码的方式修改一下，将这个 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 直接替换为 <code>0x0</code> 即 <code>false</code> 。</p>
<img src="/mac_re_bartender/if_false.png" class="">
<p>在逆向工程中，切忌不可以冒进，时值今日几乎所有应用都会采取措施来增加其逆向难度。这时候千万不要想着一步到位，应该在适量修改之后尝试导出二进制，用动态分析的方法验证一下结果。因为我们这时候不是正向开发者，在没有见到上下文的情况下修改代码很可能会把程序改成一个不可用的状态（比如正常功能损坏或者频繁 Crash），所以最好步步为营。</p>
<p>这里我们导出修改之后的二进制文件，按照 Bartender 的原路径覆盖之前的二进制文件验证一下结果。我在这个阶段运行时发现如果正常开启 Bartender 还是会有一个 10s 左右的可用时长，之后依然会弹出试用期到期弹窗，并且程序变为不可用状态；而如果重启 Bartender 在试用期弹窗弹出之前点击功能按钮则可以正常切换，但是再次点击按钮却切换不回来了，并且程序运行 10s 左右仍会弹出试用期到期弹窗，但是菜单栏上面的图标不会变失效，只是切不回去而已。</p>
<h3 id="功能破解"><a href="#功能破解" class="headerlink" title="功能破解"></a>功能破解</h3><p>到目前为止如果不在乎功能仅仅想要隐藏菜单栏的图标已经是可以凑合用了，但是这显然不是我们想要的最终结果。</p>
<p>通过上面运行程序后观察到的情况我推测在 <code>-[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:]</code> 内部切换回来的逻辑中仍然有地方对是否到期做了判断，我们上面只是成功修改了切换过去的逻辑，那么切换回来的逻辑在哪呢？</p>
<p>按逻辑推测，正向切换的时候是使用 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 做判断，反向切换应该同理才对，我们去追踪 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 的使用，最终发现 <code>sub_10001f870</code> 中使用了 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 且 <code>sub_10001f870</code> 被 <code>sub_100029a10</code> 调用，<code>sub_100029a10</code> 又被 <code>sub_100029ac0</code> 调用，<code>sub_100029ac0</code> 就是上文在 <code>-[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:]</code> 中被调用的函数，这不仅满足了被 Bartender 功能按钮所引用的条件，同时还对 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 有所引用，所以我用插入汇编的方式将 <code>sub_10001f870</code> 中关于 <code>objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded</code> 的使用改为了 <code>0x0</code>，即 <code>false</code>。</p>
<p>嘛~ 导出二进制覆盖，发现这次的 Bartender 已经可以正常使用功能了，不过试用期到期的弹窗问题依然存在，尽管它并不影响使用，但我还是无法接受这样一个半成品的状态。</p>
<h3 id="完美破解"><a href="#完美破解" class="headerlink" title="完美破解"></a>完美破解</h3><p>还记得上文中得出的 <code>0x1000230e0</code> 吗，如果试用期到期则会执行 <code>0x1000230e0</code> 地址处的方法，我们通过快捷键 <code>G</code> 跳转到 <code>0x1000230e0</code> 地址，看一下里面的实现逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void sub_1000230e0(int arg0) &#123;</span><br><span class="line">    r14 = arg0;</span><br><span class="line">    r15 = r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialOverWindow;</span><br><span class="line">    rbx = swift_unknownWeakLoadStrong(r15);</span><br><span class="line">    if (rbx != 0x0) &#123;</span><br><span class="line">            [rbx center];</span><br><span class="line">            [rbx release];</span><br><span class="line">            rbx = **_NSApp;</span><br><span class="line">            if (rbx != 0x0) &#123;</span><br><span class="line">                    [rbx retain];</span><br><span class="line">                    [rbx activateIgnoringOtherApps:sign_extend_64($S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF(r14 &amp; 0xff))];</span><br><span class="line">                    [rbx release];</span><br><span class="line">                    rbx = swift_unknownWeakLoadStrong(r15);</span><br><span class="line">                    if (rbx != 0x0) &#123;</span><br><span class="line">                            [rbx makeKeyAndOrderFront:0x0];</span><br><span class="line">                            [rbx release];</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                            asm &#123; ud2 &#125;;</span><br><span class="line">                            sub_100023199();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                    asm &#123; ud2 &#125;;</span><br><span class="line">                    loc_100023195();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">            asm &#123; ud2 &#125;;</span><br><span class="line">            loc_100023191();</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的伪代码，我们可以初步判断这个 <code>0x1000230e0</code> 内部就是弹出试用期到期弹窗的方法。接着我们通过快捷键 <code>X</code> 查看关于 <code>0x1000230e0</code> 的引用，可以发现有三处调用，一个一个看下去发现第一个 <code>sub_100022840</code> 中的调用最像是延时调用，因为其中有 Hopper 反编译出来的 Dispatch 相关的伪代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$Ss10SetAlgebraPyxqd__cs8SequenceRd__7ElementQyd__ADRtzlufCTj(&amp;var_A0, r13);</span><br><span class="line">   swift_release(*__swiftEmptyArrayStorage);</span><br><span class="line">   (extension in Dispatch):__ObjC.OS_dispatch_queueasyncAfterdeadlineqosflags.execute(Dispatch.DispatchTime, Dispatch.DispatchQoS, Dispatch.DispatchWorkItemFlags, @convention(block) () -&gt; ()) -&gt; ()(var_40, var_68, var_B0, var_30);</span><br><span class="line">   (*(var_D0 + 0x8))(var_B0, var_C8);</span><br><span class="line">   (*(var_C0 + 0x8))(var_68, var_B8);</span><br><span class="line">   _Block_release(var_30);</span><br><span class="line">   swift_release(var_D8);</span><br><span class="line">   (var_38)(var_40, var_70, rdx);</span><br><span class="line">   [var_A8 release];</span><br><span class="line">   sub_1000230e0(0x0);</span><br><span class="line">   rbx = var_48;</span><br><span class="line">   goto loc_100022df5;</span><br></pre></td></tr></table></figure>
<p>切到汇编模式，找到对应的汇编代码。</p>
<img src="/mac_re_bartender/call_trial_window.jpg" class="">
<p>由于 <code>sub_1000230e0(0x0);</code> 是在 Dispatch 中调用的，考虑到修改后程序的稳定性，这里通过 Hopper 的 Modify 菜单中提供的 NOP Region 填平 <code>call sub_1000230e0</code> 汇编代码。</p>
<img src="/mac_re_bartender/nop.jpg" class="">
<p>老规矩，导出二进制文件覆盖 Bartender 中的二进制后重启 Bartender 验收成果。</p>
<img src="/mac_re_bartender/bartender_valid.png" class="">
<p>清爽~ 这次运行 Bartender 发现不但可以正常使用功能，之前烦人的试用期到期弹窗也被我们成功干掉了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章简单介绍了本次要破解的目标 Mac 应用 Bartender，如果各位同学还没有找到合适的顶部菜单栏图标管理工具不妨试着使用 Bartender。</li>
<li>文章介绍了 maxOS 与 iOS 逆向工程中主流的静态分析工具 Hopper，从文章后面破解 Bartender 的实战过程中就可以看出 Hopper 对于我们逆向过程的帮助有多么大。</li>
<li>文章最后详细讲述了我在破解 Bartender 过程中的经历，从<strong>初始常规思路</strong>到不起作用<strong>思路被截断</strong>再到通过动态分析<strong>重拾思路</strong>…一直到最后的<strong>完美破解</strong>中间经历了许多关键节点，希望对大家有所帮助。</li>
</ul>
<p>每一次逆向的过程都是未知的，有的时候可能会很顺利（直接 <code>mov eax, 0x1</code> + <code>ret</code> 就搞定），有的时候可能会很曲折，有的时候可能还会以失败收尾。我写这篇文章主要是想与大家交流在逆向过程中的常规方法以及遇到困难时的一些解决思路，其实不论是 Bartender 还是其他应用，不论是 Mac 应用还是 iOS 应用，逆向的思路都是相通的，愿各位同学日后可以举一反三。</p>
<p>如果有任何问题欢迎在文章下方留言或在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我，真心希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/macos/" rel="tag">macOS</a><a class="tag-none-link" href="/tags/re/" rel="tag">re</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/wwdc18_llvm/">
      WWDC18 What’s New in LLVM
    </a>
  </h2>
  
  <time>
    6月 24, 2018
  </time>
  <section class="content">
	  <img src="/wwdc18_llvm/wwdc18.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM</a> 作为 Apple 御用的编译基础设施其重要性不言而喻，Apple 从未停止对 LLVM 的维护和更新，并且几乎在每年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/">WWDC</a> 中都有专门的 Session 来针对 LLVM 的新特性做介绍和讲解，刚刚过去的 WWDC18 也不例外。</p>
<p>WWDC18 Session 409 What’s New in LLVM 中 Apple 的工程师们又为我们介绍了 LLVM 最新的特性，这篇文章将会结合 WWDC18 Session 409 给出的 <a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/409t8zw7rumablsh/409/409_whats_new_in_llvm.pdf?dl=1">官方演示文稿</a> 分享一下 LLVM 的新特性并谈谈笔者自己个人对这些特性的拙见。</p>
<blockquote>
<p>Note: 本文不会对官方演示文稿做逐字逐句的翻译工作，亦不会去过多介绍 LLVM 的基本常识。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>ARC 更新</li>
<li>Xcode 10 新增诊断</li>
<li>Clang 静态分析</li>
<li>增加安全性</li>
<li>新指令集扩展</li>
<li>总结</li>
</ul>
<h2 id="ARC-更新"><a href="#ARC-更新" class="headerlink" title="ARC 更新"></a>ARC 更新</h2><p>本次 ARC 更新的亮点在于 C struct 中允许使用 ARC Objective-C 对象。</p>
<p>在之前版本的 Xcode 中尝试在 C struct 的定义中使用 Obj—C 对象，编译器会抛出 <strong>Error: ARC forbids Objective-C objects in struct</strong>，如下图所示：</p>
<img src="/wwdc18_llvm/arc_00.png" class="">
<p>嘛~ 这是因为之前 LLVM 不支持，如果在 Xcode 10 中书写同样的代码则不会有任何 Warning 与 Error：</p>
<img src="/wwdc18_llvm/arc_01.png" class="">
<p>那么直接在 C struct 中使用 Objective-C 对象的话难道就没有内存上的问题吗？Objective-C 所占用的内存空间是何时被销毁的呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC Object Pointers in C Structs!</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> orderFreeFood(<span class="built_in">NSString</span> *name) &#123;	MenuItem item = &#123;		name,		[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>]	&#125;;	<span class="comment">// [item.name retain];</span>	<span class="comment">// [item.price retain];</span>	orderMenuItem(item);	<span class="comment">// [item.name release]; </span></span><br><span class="line">	<span class="comment">// [item.price release];</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，编译器会在 C struct <code>MenuItem</code> 创建后 <code>retain</code> 其中的 ARC Objective-C 对象，并在 <code>orderMenuItem(item);</code> 语句之后，即其他使用 <code>MenuItem item</code> 的函数调用结束之后 <code>release</code> 掉相关 ARC Objective-C 对象。</p>
<p>思考，在<strong>动态内存管理</strong>时，ARC Objective-C 对象的内存管理会有什么不同呢？ </p>
<blockquote>
<p>Note: 动态内存管理（Dynamic Memory Management），指非 <code>int a[100];</code> 或 <code>MenuItem item = &#123;name, [NSNumber numberWithInt:0]&#125;;</code> 这种在决定了使用哪一存储结构之后，就自动决定了作用域和存储时期的代码，这种代码必须服从预先制定的内存管理规则。</p>
</blockquote>
<p>我们知道 C 语言中如果想要灵活的创建一个动态大小的数组需要自己手动开辟、管理、释放相关的内存，示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="type">double</span> *ptd;</span><br><span class="line">	    </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;What is the maximum number of type double entries?&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">	ptd = <span class="built_in">malloc</span>(max * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="keyword">if</span> (ptd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// memory allocation failed</span></span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// some logic</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(ptd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 C struct 中 ARC Objective-C 的动态内存管理是否应该这么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = malloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>答案是<strong>否定</strong>的！</p>
<img src="/wwdc18_llvm/arc_02.png" class="">
<p>可以看到通过 <code>malloc</code> 开辟内存初始化带有 ARC Objective-C 的 C struct 中 ARC Objective-C 指针不会 <code>zero-initialized</code>。</p>
<p>嘛~ 这个时候自然而然的会想起使用 <code>calloc</code> ^_^ </p>
<blockquote>
<p>Note: <code>calloc</code> 和 <code>malloc</code> 均可完成内存分配，不同之处在于 <code>calloc</code> 会将分配过来的内存块中全部位置都置 0（然而要注意，在某些硬件系统中，浮点值 0 不是全部位为 0 来表示的）。</p>
</blockquote>
<p>另一个问题就是 <code>free(items);</code> 语句执行之前，ARC Objective-C 并没有被清理。</p>
<p>Emmmmm… 官方推荐的写法是在 <code>free(items);</code> 之前将 <code>items</code> 内的所有 struct 中使用到的 ARC Objective-C 指针手动职位 <code>nil</code> …</p>
<p>所以在<strong>动态内存管理</strong>时，上面的代码应该这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = calloc(<span class="number">10</span>, <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	<span class="comment">// ARC Object Pointer Fields Must be Cleared Before Deallocation</span>	<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;		items[i].name = <span class="literal">nil</span>;		items[i].price = <span class="literal">nil</span>;	&#125;	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间有种<strong>日了狗</strong>的感觉有木有？</p>
<h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 在 C struct 中增加对 ARC Objective-C 对象字段的支持意味着我们<strong>今后 Objective-C 可以构建跨语言模式的交互操作</strong>。</p>
<blockquote>
<p>Note: 官方声明为了统一 ARC 与 manual retain/release (MRR) 下部分 function 按值传递、返回 struct 对 Objective-C++ ABI 做出了些许调整。 </p>
</blockquote>
<p>值得一提的是 Swift <strong>并不支持</strong>这一特性（2333~ 谁说 Objective-C 的更新都是为了迎合 Swift 的变化）。</p>
<h2 id="Xcode-10-新增诊断"><a href="#Xcode-10-新增诊断" class="headerlink" title="Xcode 10 新增诊断"></a>Xcode 10 新增诊断</h2><h3 id="Swift-与-Objective-C-互通性"><a href="#Swift-与-Objective-C-互通性" class="headerlink" title="Swift 与 Objective-C 互通性"></a>Swift 与 Objective-C 互通性</h3><p>我们都知道 Swift 与 Objective-C 具有一定程度的互通性，即 Swift 与 Objective-C 可以混编，在混编时 Xcode 生成一个头文件将 Swift 可以转化为 Objective-C 的部分接口暴露出来。</p>
<p>不过由于 Swift 与 Objective-C 的兼容性导致用 Swift 实现的部分代码无法转换给 Objective-C 使用。</p>
<p>近些年来 LLVM 一致都在尝试让这两种语言可以更好的互通（这也就是上文中提到 Objective-C 的更新都是为了迎合 Swift 说法的由来），本次 LLVM 支持<strong>将 Swift 中的闭包（Closures）导入 Objective-C</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">performOperation</span>(<span class="params">handler</span>: () -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import “Executor-Swift.h”</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)performOperation:(<span class="type">void</span> (^)(<span class="type">void</span>))handler; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 Swift 中闭包默认都是非逃逸闭包（non-escaping closures），即闭包不应该在函数返回之后执行。</p>
</blockquote>
<p>Objective-C 中与 Swift 闭包对应的就是 Block 了，但是 Objective-C 中的 Block 并没有诸如 Swift 中逃逸与否的限制，那么我们这样将 Swift 的非逃逸闭包转为 Objective-C 中无限制的 Block 岂不是会有问题？</p>
<img src="/wwdc18_llvm/interoperability.png" class="">
<p>别担心，转换过来的闭包（非逃逸）会有 Warnning 提示，而且我们说过一般这种情况下 Apple 的工程师都会在 LLVM 为 Objective-C 加一个宏来迎合 Swift…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning for Missing Noescape Annotations for Method Overrides</span><span class="meta">#import “Executor-Swift.h”</span><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler;<span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">DispatchExecutor</span></span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler &#123;&#125;</span><br><span class="line"><span class="comment">// Programmer must ensure that handler is not called after performOperation returns</span><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="个人观点-1"><a href="#个人观点-1" class="headerlink" title="个人观点"></a>个人观点</h4><p>如果 Swift 5 真的可以做到 ABI 稳定，那么 Swift 与 Objective-C 混编的 App 包大小也应该回归正常，相信很多公司的项目都会慢慢从 Objective-C 转向 Swift。在 Swift 中闭包（Closures）作为一等公民的存在奠定了 Swift 作为函数式语言的根基，本次 LLVM 提供了将 Swift 中的 Closures 与 Objective-C 中的 Block 互通转换的支持无疑是很有必要的。</p>
<h3 id="使用-pragma-pack-打包-Struct-成员"><a href="#使用-pragma-pack-打包-Struct-成员" class="headerlink" title="使用 #pragma pack 打包 Struct 成员"></a>使用 <code>#pragma pack</code> 打包 Struct 成员</h3><p>Emmmmm… 老实说这一节的内容更底层，所以可能会比较晦涩，希望自己可以表述清楚吧。在 C 语言中 struct 有 <strong>内存布局（memory layout）</strong> 的概念，C 语言允许编译器为每个基本类型指定一些<strong>对齐方式</strong>，通常情况下是以类型的大小为标准对齐，但是它是<strong>特定于实现</strong>的。</p>
<p>嘛~ 还是举个例子吧，就拿 WWDC18 官方演示文稿中的吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> &#123;</span> </span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="comment">// 2 byte padding </span></span><br><span class="line">	<span class="type">uint32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，编译器为了对齐内存布局不得不在 <code>Struct</code> 的第二字段与第三字段之间插入 2 个 byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p><strong>这样本该占用 6 byte 的 struct 就占用了 8 byte，尽管其中只有 6 byte 的数据。</strong></p>
<p>C 语言允许每个远程现代编译器实现 <code>#pragma pack</code>，它允许程序猿对填充进行控制来依从 ABI。</p>
<blockquote>
<p>From C99 §6.7.2.1: </p>
<p>12 Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type.</p>
<p>13 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
</blockquote>
<p>实际上关于 <code>#pragma pack</code> 的相关信息可以在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/preprocessor/pack">MSDN page</a> 中找到。</p>
<p>LLVM 本次也加入了对 <code>#pragma pack</code> 的支持，使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (push, 1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PackedStruct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="type">uint32_t</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (pop)</span></span><br></pre></td></tr></table></figure>
<p>经过 <code>#pragma pack</code> 之后我们的 struct 对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   1   |</span><br><span class="line">|   a   | </span><br><span class="line">|   b   |</span><br><span class="line">|  c(1) |</span><br><span class="line">|  c(2) |</span><br><span class="line">|  c(3) |</span><br><span class="line">|  c(4) |</span><br></pre></td></tr></table></figure>
<p>其实 <code>#pragma pack (push, 1)</code> 中的 <code>1</code> 就是对齐字节数，如果设置为 <code>4</code> 那么对齐方式又会变回到最初的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p>值得一提的是，如果你使用了 <code>#pragma pack (push, n)</code> 之后忘记写 <code>#pragma pack (pop)</code> 的话，Xcode 10 会抛出 warning：</p>
<img src="/wwdc18_llvm/pack.png" class="">
<h4 id="个人观点-2"><a href="#个人观点-2" class="headerlink" title="个人观点"></a>个人观点</h4><p>嘛~ 当在网络层面传输 struct 时，通过 <code>#pragma pack</code> 自定义内存布局的对齐方式可以为用户节约更多流量。</p>
<h2 id="Clang-静态分析"><a href="#Clang-静态分析" class="headerlink" title="Clang 静态分析"></a>Clang 静态分析</h2><p>Xcode 一直都提供静态分析器（Static Analyzer），使用 Clang Static Analyzer 可以帮助我们找出边界情况以及难以发觉的 Bug。</p>
<img src="/wwdc18_llvm/static_analyzer_00.jpg" class="">
<p>点击 Product -&gt; Analyze 或者使用快捷键 Shift+Command+B 就可以静态分析当前构建的项目了，当然也可以在项目的 Build Settings 中设置构建项目时自动执行静态分析（个人不推荐）：</p>
<img src="/wwdc18_llvm/static_analyzer_01.jpg" class="">
<p>本地静态分析器有以下提升：</p>
<ul>
<li>GCD 性能反模式</li>
<li>自动释放变量超出自动释放池</li>
<li>性能和可视化报告的提升</li>
</ul>
<h3 id="GCD-性能反模式"><a href="#GCD-性能反模式" class="headerlink" title="GCD 性能反模式"></a>GCD 性能反模式</h3><p>在之前某些迫不得已的情况下，我们可能需要使用 GCD 信号（<code>dispatch_semaphore_t</code>）来阻塞某些异步操作，并将阻塞后得到的最终的结果同步返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task;</span><br><span class="line">	dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这样写有什么问题呢？</p>
<p>上述代码存在通过使用异步线程执行任务来阻塞当前线程，而 Task 队列通常优先级较低，所以会导致<strong>优先级反转</strong>。</p>
<p>那么 Xcode 10 之后我们应该怎么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line"><span class="type">id</span> remoteObjectProxy = [<span class="keyword">self</span>.connection synchronousRemoteObjectProxyWithErrorHandler:</span><br><span class="line">	^(<span class="built_in">NSError</span> *error) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %@&quot;</span>, error); &#125;];</span><br><span class="line">[remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>如果可能的话，尽量使用 <code>synchronous</code> 版本的 API。或者，使用 <code>asynchronous</code> 方式的 API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123; </span><br><span class="line">	completionHandler(task);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可以在 build settings 下启用 GCD 性能反模式的静态分析检查：</p>
<img src="/wwdc18_llvm/static_analyzer_gcd_00.png" class="">
<h3 id="自动释放变量超出自动释放池"><a href="#自动释放变量超出自动释放池" class="headerlink" title="自动释放变量超出自动释放池"></a>自动释放变量超出自动释放池</h3><p>众所周知，使用 <code>__autoreleasing</code> 修饰符修饰的变量会在自动释放池离开时被释放（release）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	__autoreleasing <span class="built_in">NSError</span> *err = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种看似不需要我们注意的点往往就是引起程序 Crash 的隐患：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123; </span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				*error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嘛~ 上述代码是会引起 Crash 的，你可以指出为什么吗？</p>
<p>Objective-C 在 ARC（Automatic Reference Counting）下会隐式使用 <code>__autoreleasing</code> 修饰 <code>error</code>，即 <code>NSError *__autoreleasing*</code>。而 <code>-enumerateObjectsUsingBlock:</code> 内部会在迭代 <code>block</code> 时使用 <code>@autoreleasepool</code>，在迭代逻辑中这样做有助于减少内存峰值。</p>
<p>于是 <code>*error</code> 在 <code>-enumerateObjectsUsingBlock:</code> 中被提前 release 掉了，这样在随后读取 <code>*error</code> 时会出现 crash。</p>
<p>Xcode 10 中会给出具有针对性的静态分析警告：</p>
<img src="/wwdc18_llvm/static_analyzer_autoreleasing_00.png" class="">
<p>正确的书写方式应该是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> *__autoreleasing*)error &#123; </span><br><span class="line">	__block <span class="built_in">NSError</span> *localError;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123;</span><br><span class="line">			localError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;];</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		*error = localError;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实早在去年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/411/">WWDC17 Session 411 What’s New in LLVM</a> 中 Xcode 9 就引入了一个需要显示书写 <code>__autoreleasing</code> 的警告。</p>
</blockquote>
<h3 id="性能和可视化报告的提升"><a href="#性能和可视化报告的提升" class="headerlink" title="性能和可视化报告的提升"></a>性能和可视化报告的提升</h3><p>Xcode 10 中静态分析器可以以更高效的方式工作，在相同的分析时间内平均可以发现比之前增加 15% 的 Bug 数量。</p>
<p>不仅仅是性能的提升，Xcode 10 在报告的可视化方面也有所进步。在 Xcode 9 的静态分析器报告页面有着非必要且冗长的 Error Path：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_9.jpg" class="">
<p>Xcode 10 中则对其进行了优化：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_10.jpg" class="">
<h3 id="个人观点-3"><a href="#个人观点-3" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 对于 Xcode 的静态分析，个人认为还是聊胜于无的。不过不建议每次构建项目时都去做静态分析，这样大大增加了构建项目的成本。</p>
<p>个人建议在开发流程中自测完毕提交代码给组内小伙伴们 Code Review 之前做静态分析，可以避免一些 issue 的出现，也可以发现一些代码隐患。有些问题是可以使用静态分析器在提交代码之前就暴露出来的，没必要消耗组内 Code Review 的宝贵人力资源。</p>
<p>还可以在 CI 设置每隔固定是时间间隔去跑一次静态分析，生成报表发到组内小群，根据问题指派责任人去检查是否需要修复（静态分析在比较复杂的代码结构下并不一定准确），这样定期维护从某种角度讲可以保持项目代码的健康状况。</p>
<h2 id="增加安全性"><a href="#增加安全性" class="headerlink" title="增加安全性"></a>增加安全性</h2><h3 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h3><p>Apple 工程师在介绍 Stack Protector 之前很贴心的带领着在场的开发者们复习了一遍栈 Stack 相关的基础知识：</p>
<img src="/wwdc18_llvm/stack_protector_00.png" class="">
<p>如上图，其实就是简单的讲了一下 Stack 的工作方式，如栈帧结构以及函数调用时栈的展开等。每一级的方法调用，都对应了一张相关的活动记录，也被称为<strong>活动帧</strong>。函数的调用栈是由一张张帧结构组成的，所以也称之为<strong>栈帧</strong>。</p>
<p>我们可以看到，栈帧中包含着 <strong>Return Address</strong>，也就是当前活动记录执行结束后要返回的地址。</p>
<p>那么会有什么安全性问题呢？Apple 工程师接着介绍了通过不正当手段修改栈帧 Return Address 从而实现的一些权限提升。嘛~ 也就是历史悠久的 <a target="_blank" rel="noopener" href="http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf">缓冲区溢出攻击</a>。</p>
<img src="/wwdc18_llvm/stack_protector_01.png" class="">
<p>当使用 C 语言中一些不太安全的函数时（比如上图的 <code>strcpy()</code>），就有可能造成缓冲区溢出。</p>
<blockquote>
<p>Note: <code>strcpy()</code> 函数将源字符串复制到指定缓冲区中。但是丫没有指定要复制字符的具体数目！如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会造成<strong>缓冲区溢出</strong>！</p>
</blockquote>
<p>针对缓冲区溢出攻击，LLVM 引入了一块额外的区域（下图绿色区域）来作为栈帧 Return Address 的<strong>护城河</strong>，叫做 Stack Canary，已默认启用：</p>
<img src="/wwdc18_llvm/stack_protector_02.png" class="">
<blockquote>
<p>Note: Canary 译为 “金丝雀”，Stack Canary 的命名源于早期煤矿工人下矿坑时会携带金丝雀来检测矿坑内一氧化碳是否达到危险值，从而判断是否需要逃生。</p>
</blockquote>
<p>根据我们上面对缓冲区溢出攻击的原理分析，大家应该很容易发现 Stack Canary 的防御原理，即缓冲区溢出攻击旨在利用缓冲区溢出来篡改栈帧的 Return Address，加入了 Stack Canary 之后想要篡改 Return Address 就必然会经过 Stack Canary，在当前栈帧执行结束后要使用 Return Address 回溯时先检测 Stack Canary 是否有变动，如果有就调用 <code>abort()</code> 强制退出。</p>
<p>嘛~ 是不是和矿坑中的金丝雀很像呢？</p>
<p>不过 Stack Canary 存在一些局限性：</p>
<ul>
<li>可以在缓冲区溢出攻击时计算 Canary 的区域并伪装 Canary 区域的值，使得 Return Address 被篡改的同时 Canary 区域内容无变化，绕过检测。</li>
<li>再粗暴一点的话，可以通过双重 <code>strcpy()</code> 覆写任意不受内存保护的数据，通过构建合适的溢出字符串，可以达到修改 ELF（Executable and Linking Format）映射的 GOT（Global Offset Table），只要修改了 GOT 中的 <code>_exit()</code> 入口，即便 Canary 检测到了篡改，函数返回前调用 <code>abort()</code> 退出还是会走已经被篡改了的 <code>_exit()</code>。</li>
</ul>
<h3 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h3><p>Stack Protector 是 Xcode 既有的、且默认开启的特性，而 Stack Checking 是 Xcode 10 引入的新特性，主要针对的是 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">Stack Clash</a> 问题。</p>
<img src="/wwdc18_llvm/stack_checking_00.png" class="">
<p>Stack Clash 问题的产生源于 Stack 和 Heap，Stack 是<strong>从上向下</strong>增长的，Heap 则是<strong>自下而上</strong>增长的，两者相向扩展而内存又是有限的。</p>
<p>Stack Checking 的工作原理是在 Stack 区域规定合理的分界线（上图红线），在可变长度缓冲区的函数内部对将要分配的缓冲区大小做校验，如果缓冲区超出分界线则调用 <code>abort()</code> 强制退出。</p>
<blockquote>
<p>Note: LLVM 团队在本次 WWDC18 加入 Stack Checking，大概率是因为去年年中 <a target="_blank" rel="noopener" href="https://www.qualys.com/">Qualys</a> 公布的一份 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">关于 Stack Clash 的报告</a>。</p>
</blockquote>
<h2 id="新指令集扩展"><a href="#新指令集扩展" class="headerlink" title="新指令集扩展"></a>新指令集扩展</h2><img src="/wwdc18_llvm/new_instruction_set_extensions.png" class="">
<p>Emmmmm… 这一节的内容是针对于 iMac Pro 以及 iPhone X 使用的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instruction_set_architecture">指令集架构（ISA - Instruction set architecture）</a> 所做的扩展。坦白说，我对这块并不是很感兴趣，也没有深入的研究，所以就不献丑了…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 WWDC18 Session 409 What’s New in LLVM 中的内容，并分享了我个人对这些内容的拙见，希望能够对各位因为种种原因还没有来得及看 WWDC18 Session 409 的同学有所帮助。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/sony_wh_h900n/">
      Sony WH-H900N 开箱留念
    </a>
  </h2>
  
  <time>
    6月 9, 2018
  </time>
  <section class="content">
	  <img src="/sony_wh_h900n/sony_wh_h900n_00.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>嘛~ 又是一年高考季，每到这个时候我就知道我又长了一岁… </p>
<p>Emmmmm… 最近似乎陷入了创作低谷，已经很久没有更新过博客了，原因嘛… 有很多：</p>
<ul>
<li>一方面是入职之后需要适应新的环境，包括新的团队，新的流程… 从这一点来看人类果然是弱鸡动物，会受到外界环境的变化以及心情等内在因素的影响，至少机器人不会被这些东西困扰吧…</li>
<li>另一方面是不知道应该写什么，或者说自己在这段与新团队的磨合期中眼界提升了很多，很多之前计划去写的文章现在突然没有兴趣了，以前也有过类似的经历… 唯有告诫自己戒掉拖延症，不要错过当前这段时期自己想做的事情哈~</li>
</ul>
<p>另外一个最重要原因就是——<strong>真的没时间</strong>。</p>
<p>自己也想过为什么会这样，除去磨合期种种不熟悉导致的时效问题，还剩下一些客观存在的因素，其中就有办公环境的影响，现在的办公环境比较开放（装修风格和网吧类似 &gt;_&lt;），所以每天都会有 QA 小姐姐们测试订单的声音，PM 小哥哥们撕逼的声音，RD 小伙伴们敲击键盘的声音… 这几种声音在不同的音频攻击着我幼小的心脏和脆弱的神经，影响着我敲代码时的专注程度…</p>
<p>然后可能之前下班回到家后有和我女票抱怨过吧… 结果过生日就收到了这篇文章的主角—— Sony WH-H900N。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Sony WH-H900N</li>
<li>入手渠道</li>
<li>开箱照</li>
<li>上头体验</li>
<li>总结</li>
</ul>
<h2 id="Sony-WH-H900N"><a href="#Sony-WH-H900N" class="headerlink" title="Sony WH-H900N"></a>Sony WH-H900N</h2><img src="/sony_wh_h900n/sony_wh_h900n_01.jpg" class="">
<p>Sony WH-H900N 全称 Sony | h.ear on 2 Wireless NC | WH-H900N，是大法旗下的 h.ear on 2 系列无线蓝牙降噪耳机。</p>
<p>关键词：</p>
<ul>
<li>佩戴良好</li>
<li>隔音良好</li>
<li>听诊器效应轻微</li>
<li>做工优秀</li>
<li>降噪良好</li>
<li>杂食</li>
</ul>
<p>由于我自己平时什么音乐都听一些，偏 ACG 和 Eason Chen 多一些，加上我自己本身是木耳（木头耳朵，指听不出不同耳机的音质区别）所以一直以来对耳机就只有<strong>无线</strong>和<strong>降噪</strong>两个硬性需求，然后自己没有出街听音乐的习惯（主要是觉得车来车往不太安全），所以想要一款<strong>头戴式</strong>的耳机（在办公室和家里听听就好），然后因为头戴式的耳机比较显眼，所以对<strong>颜值</strong>也有了一定的要求…</p>
<p>刚刚好，这些需求 Sony WH-H900N 统统满足了，再次感恩我的女票，想必花了不少心思吧（笑）</p>
<p>配色方面，这款耳机提供了五种配色可供选择：</p>
<ul>
<li>暮光红（目光红，因为这个颜色真的特别少女，据说出街回头率超高）</li>
<li>月光蓝</li>
<li>薄荷绿</li>
<li>浅金</li>
<li>灰黑</li>
</ul>
<p>这几种颜色都是偏哑光质感的，低调的同时满足了绝大多数消费者的个性化选择，我这款就是月光蓝配色的~</p>
<blockquote>
<p>Note: 鉴于网上各种评测贴和买家秀的晒图中出现了各种颜色的月光蓝，所以我这篇文章的所有配图均无任何滤镜和后期处理，希望能够给想买月光蓝的同学提供一些参考和帮助。</p>
</blockquote>
<p>补充，话说我还在大法的官方商城搜到了 WH-H900N FATE 特别版哟~</p>
<img src="/sony_wh_h900n/sony_wh_h900n_fate.jpg" class="">
<h2 id="开箱照"><a href="#开箱照" class="headerlink" title="开箱照"></a>开箱照</h2><img src="/sony_wh_h900n/package.jpg" class="">
<img src="/sony_wh_h900n/storage_box.jpg" class="">
<img src="/sony_wh_h900n/open_storage_box.jpg" class="">
<img src="/sony_wh_h900n/sony_wh_h900n_01.jpg" class="">
<img src="/sony_wh_h900n/sony_wh_h900n_00.jpg" class="">
<img src="/sony_wh_h900n/all_items.jpg" class="">
<p>箱内物品如下：</p>
<ul>
<li>Sony WH-H900N 耳机本体</li>
<li>耳机线材（手感一般，随耳机本体颜色）</li>
<li>充电线（<strong>黑色</strong>）</li>
<li>收纳袋（手感不错的透气帆布材质收纳袋，内衬柔软材料，随耳机本体颜色）</li>
<li>收纳盒（随耳机本体颜色）</li>
</ul>
<p>需要注意的是只有充电线是黑色的，这也就意味着如果你选择的是暮光红这种偏浅色系的配色，充电的时候会…<strong>非！常！丑！</strong>好在这款耳机有大法的快充黑科技加持（其实不如 Apple 的快充黑科技），在低电量时充电 10 分钟可以听 1 小时左右（说明书有写 &amp; 亲测），另外耳机充满电的续航时间为 28 小时（开启降噪），完全可以在家充好电再带去公司使用。</p>
<h2 id="上头体验"><a href="#上头体验" class="headerlink" title="上头体验"></a>上头体验</h2><img src="/sony_wh_h900n/detail_00.jpg" class="">
<p>Emmmmm… 自认木耳，又是理工男的渣渣文笔，就简单叙述一下自己的主观听感吧~</p>
<h3 id="音质"><a href="#音质" class="headerlink" title="音质"></a>音质</h3><p>音质方面个人认为还不错，这款耳机偏中低音，恰好 Eason Chen 的歌普遍都是中低音男声，所以表现很不错，人声清晰，不会感觉距离耳朵很远，又不会感觉靠的太近，可以说是恰到好处吧~ 另外 ACG 女声的表现也很不错，人声甜美，距离适中，声音有厚度。有的耳机人声表现就很单薄，该怎么形容呢？就是感觉人声是耳机从背景音乐中摘出来突兀的放到耳边的，清楚但是与背景音格格不入，像纸片一样突兀且单薄，一带而过的发声…</p>
<h3 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h3><p>首先，耳机的耳垫做工很不错，足够柔软舒适，扣在耳朵上已经可以降低 10%~20% 的环境噪音了，然后开机并开启降噪模式可以瞬间感觉到 &gt;= 80% 的环境噪音都被屏蔽了，剩下的一些声音基本都是附近的人声，且声音小了很多（开始听音乐时外面减弱过的人声就基本听不到了）~ 低频的杂音类似中央空调出风口的声音则完全被屏蔽，我是中午午休时拆箱第一次试戴的，当时正好没人说话，感觉瞬间沉入海底，整个世界都安静了~ </p>
<blockquote>
<p>Note: Sony WH-H900N 支持手势操控，用右手遮盖右耳机，则会降低正在播放的音乐音量，同时暂时关闭降噪，这样非常人性化的便捷设计可以让你很方便的与同事短暂沟通。</p>
</blockquote>
<h3 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h3><p>大法黑科技将蓝牙传输的速率提升很多，在无线状态下依然尽可能的争取音质体验，个人的感觉是比我之前 Beats solo 2 的音质还要稍好一些~</p>
<h3 id="做工"><a href="#做工" class="headerlink" title="做工"></a>做工</h3><p>这款耳机的头梁做工很厚实，保证了长时间佩戴的舒适度（不过耳垫处由于密封性等原因会比较容易出汗，好在公司和家里都有空调，问题不大），这一点和我之前的 Beats solo 2 形成强烈对比，Beats solo 2 的头梁就薄薄一层，拆开之后发现里面只有一层超薄海绵（日了狗了）。</p>
<p>耳机的触感和它偏哑光的颜色保持一致，形容起来大概就是介于磨砂和光面之间的感觉，耳垫柔软舒适有弹性，大爱 Sony 这种优秀扎实的做工品质！</p>
<img src="/sony_wh_h900n/detail_01.jpg" class="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>嘛~ 总得来说呢… Sony WH-H900N 这款耳机非常适合对<strong>无线 &amp; 降噪</strong>有硬性需求的同学，难能可贵的是其在无线 &amp; 降噪的基础上还保证了<strong>高颜值 &amp; 一定的音质</strong>（反正对于我这种木耳来讲足够了）。</p>
<p>补充，<strong>降噪</strong>耳机真的是提升工效的利器，从某种角度看甚至比键盘来的更加粗暴有效（毕竟不需要磨合期）。</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/headset/" rel="tag">headset</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/hackathon5-0/">
      Hackathon 5.0 小记
    </a>
  </h2>
  
  <time>
    5月 26, 2018
  </time>
  <section class="content">
	  <img src="/hackathon5-0/hackathon_5_0.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Emmmmm… 还记得上一次参加 Hackathon 是在 2017 年上海举办的，当时还在 ELSEWHERE 工作的我和公司的小伙伴们一起组团从北京到上海参赛，也是我人生中第一次参加 Hackathon，所以到现在都还印象深刻呢！</p>
<p>这一晃，加入美团·点评也快满三个月了，早就知道美团·点评有公司内部举办 Hackathon 的传统，但没想到这么快就可以参与其中了，想想还有点小激动。其实之前就有看到过同事穿着往届内部 Hackathon 主题 T 恤来公司上班，自己也超想有一件！所以在公司内部发出这次 Hackathon 5.0 的宣传页以及报名表时就毫不犹豫的拉着组里的两位大佬一起报名了哈。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Hackathon</li>
<li>Hackathon 5.0</li>
<li>不同于往届的赛制</li>
<li>嗨 Kr 森</li>
<li>Somewhere</li>
<li>去年的 Hackathon 回忆</li>
<li>总结</li>
</ul>
<h2 id="Hackathon"><a href="#Hackathon" class="headerlink" title="Hackathon"></a>Hackathon</h2><p>Hackathon 译为“黑客马拉松”，旨在用限定的时间做出可用的软件应用。</p>
<p>Hackathon 往往都有一个特定的焦点，其中可能包括使用的编程语言，操作系统，应用程序，API 等等。</p>
<p>不仅仅是程序猿，Hackathon 的参赛人员包含软件开发领域的所有职业，包括平面设计师，界面设计师，产品经理等等，大家在赛前根据计划组队，比赛过程中各司其职，发挥专长，力争为团队拿下好的成绩。</p>
<p>不过随着 Hackathon 的不断发展，现在的 Hackathon 已经不单单是场比赛了，我觉得它更像是让 Hacker 们齐聚一堂盛会和节日。</p>
<h2 id="Hackathon-5-0"><a href="#Hackathon-5-0" class="headerlink" title="Hackathon 5.0"></a>Hackathon 5.0</h2><p>Emmmmm… 为什么叫 Hackathon 5.0 呢？其实感觉这个就是公司内部为了区分每一届 Hackathon 的 Tag 而已。貌似在美团网与大众点评合并之前，两家公司就都有内部举办 Hackathon 的历史，合并之后自然而然的将这一传统延续了下来。</p>
<h2 id="不同于往届的赛制"><a href="#不同于往届的赛制" class="headerlink" title="不同于往届的赛制"></a>不同于往届的赛制</h2><p>往届 Hackathon 大致流程：</p>
<ul>
<li>提前一两周给一个特定范围内的主题</li>
<li>大家根据主题找灵感</li>
<li>线下拉人组队</li>
<li>技术调研保证项目可行性以及确定技术方案</li>
<li>报名参赛</li>
<li>现场开始编码</li>
<li>在规定的时间内（24 小时）完成作品</li>
<li>在完成作品期间抽时间准备 PPT 模拟上台宣讲</li>
<li>评委对参赛队伍的作品初筛</li>
<li>入围的队伍上台决赛答辩</li>
<li>评委给出最终评分决出名次</li>
<li>上台领奖 &amp; 拍照留恋</li>
</ul>
<p>不过这次 Hackathon 5.0 在赛制上为了保证参赛作品的质量，没有明确的限制主题，这就导致有些作品是在赛前做了很久的项目，这些项目不论从体量还是从质量上都跟 24 小时竭尽全力所能产出的作品有着悬殊的差距。</p>
<p>个人认为提前两周公布一个明确的主题范围，大家在两周内做技术调研之后提前在工作之余开始构建项目还是可以接受的，这样可以保证参赛作品的质量同时也可以省去大家通宵熬夜对身体的损耗。主办方出发点是好的，但是任何主题任何项目都可以参赛这点就决定了这场 Hackathon 注定是不太公平的同台竞技，不仅打压了部分第一次参加 Hackathon 的同学以后继续参加的积极性，还掀起了一个不好的势头 —— 以后参赛的作品可能都会是提前很久就开始构建的项目。</p>
<p>嘛~ 上面的个人观点可能有些酸吧… 因为我们战队就是按照老 Hackathon 的赛制准备的（事实上我并不知道美团·点评内部 Hackathon 什么时候举办，也不知道这次的赛制竟然没有限制主题）。</p>
<h2 id="嗨-Kr-森"><a href="#嗨-Kr-森" class="headerlink" title="嗨 Kr 森"></a>嗨 Kr 森</h2><p>嘛~ “嗨 Kr 森”是我们本次参加 Hackathon 5.0 的战队名哈！</p>
<img src="/hackathon5-0/team.jpg" class="">
<p>起这个名字无非就是觉得比较好玩，因为组里连我在内的三人中，有两位都没有参加过公司内部组织的 Hackathon，所以本次参赛的主要目的就是熟悉一下公司内部 Hackathon 的流程，还有混一件 Hackathon 5.0 主题 T 恤衫（笑）。</p>
<h2 id="Somewhere"><a href="#Somewhere" class="headerlink" title="Somewhere"></a>Somewhere</h2><img src="/hackathon5-0/somewhere_00.jpg" class="">
<p>Somewhere 译为“某处”，是我们战队这次拿来参赛的作品。它是一个将 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Augmented_reality">AR</a> 技术结合到地图的项目，旨在帮助用户发现值得消费时间去用心体验的地方。</p>
<p>Emmmmm… 其实关于 Somewhere 还有一个比较文艺的文案是我们当时在写参赛 PPT 时想到的。</p>
<blockquote>
<p>我们一直以来都希望，打开手机，对准想要去的方向。相信总有一处地方，值得我们花些时间在那里。<strong>Somewhere，帮助你发现近在咫尺的美好</strong>。</p>
</blockquote>
<p>Somewhere 参考了 <a target="_blank" rel="noopener" href="https://github.com/ProjectDent/ARKit-CoreLocation">ARKit-CoreLocation</a> 的实现，在其基础上做了一些优化，例如对某一方向重叠在一起的 POI AR Annotations 做了收敛以防止多个 POI AR Annotations 重叠在一起的问题。</p>
<img src="/hackathon5-0/somewhere_01.jpg" class="">
<p>可惜的是 Somewhere 只拿到了入围奖（42 进 10），确实站在评委的角度看 Somewhere 在完成度上面对比获奖作品来说差的太多了…</p>
<h2 id="去年的-Hackathon-回忆"><a href="#去年的-Hackathon-回忆" class="headerlink" title="去年的 Hackathon 回忆"></a>去年的 Hackathon 回忆</h2><p>去年还在 ELSEWHERE 工作时，和公司的小伙伴一起去上海参加中信集团与宝马联合赞助举办的开放式 Hackathon，也是我第一次参加 Hackathon，所以很多细节都记得清清楚楚~</p>
<p>那届 Hackathon 的主题是三选一，其中中信集团的主题之一是我们一直比较感兴趣的区块链相关主题，中信集团想要依靠区块链技术打造其集团下属业务之间的用户信用体系，确实利用区块链超级账本做信用相关的东西是个不错的出发点，从扩展性的角度看区块链技术可以让中信集团以后支持并入其他非集团旗下的外部业务。</p>
<img src="/hackathon5-0/hackathon_sh.jpg" class="">
<p>最后我们的参赛作品“信信”非常幸运的入围，并且在决赛拿到了名次和奖品~</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>平日里有自己感兴趣的技术或者想做的事情，不妨抽空动手写一写 Demo，如果可行的话可以持续抽时间完善，说不定可以拿来作为作品参加下一届公司内部的 Hackathon。</li>
<li>PPT 和作品的核心代码一样重要，初赛宣讲和决赛答辩给出的时间不同，最好准备详略两份 PPT。</li>
<li>核心流程一定要跑通，尤其是涉及到网络，定位等不确定因素时，一定要在上台前确认好当前的状态是否会影响到作品演示。</li>
<li>最受欢迎奖会在第二日的决赛答辩之前给出一个投票页面，在队长群会周知要填写投票页面中关于自己战队的作品简介，一定要及时填写作品简介以免影响得票率。</li>
</ul>
<p>嘛~ 目前准备看一下 WWDC 2018 有没有什么感兴趣的技术点，准备拿来结合生活中的场景做些有趣的东西出来，为 Hackathon 6.0 做准备~</p>
<hr>
<p>Emmmmm… 最后还要感谢战队里面的两位大佬愿意把宣讲和答辩的机会让给我，第一次面对着评委和台下这么多优秀的同事（其中不乏技术大佬）讲话真的是非常紧张的说，果然在回答某些问题上不够巧妙… 不过好在对于项目的宣讲和描述还算比较完整，大佬们也没有责怪我的意思，还给我拍了一张答辩时的照片~</p>
<img src="/hackathon5-0/me.jpg" class="">

    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hackathon/" rel="tag">hackathon</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/ios-rendering-process/">
      深入理解 iOS Rendering Process
    </a>
  </h2>
  
  <time>
    4月 15, 2018
  </time>
  <section class="content">
	  <img src="/ios-rendering-process/rendering.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 最早名为 iPhone OS，是 <a target="_blank" rel="noopener" href="https://www.apple.com/">Apple</a> 公司专门为其硬件设备开发的操作系统，最初于 2007 年随第一代 iPhone 推出，后扩展为支持 Apple 公司旗下的其他硬件设备，如 iPod、iPad 等。</p>
<p>作为一名 iOS Developer，相信大多数人都有写出过造成 iOS 设备卡顿的代码经历，相应的也有过想方设法优化卡顿代码的经验。</p>
<p>本文将从 OpenGL 的角度结合 Apple 官方给出的部分资料，介绍 iOS Rendering Process 的概念及其整个底层渲染管道的各个流程。</p>
<p>相信在理解了 iOS Rendering Process 的底层各个阶段之后，我们可以在平日的开发工作之中写出性能更高的代码，在解决帧率不足的显示卡顿问题时也可以多一些思路~</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>iOS Rendering Process 概念</li>
<li>iOS Rendering 技术框架</li>
<li>OpenGL 主要渲染步骤</li>
<li>OpenGL Render Pipeline</li>
<li>Core Animation Pipeline</li>
<li>Commit Transaction</li>
<li>Animation</li>
<li>全文总结</li>
<li>扩展阅读</li>
</ul>
<h2 id="iOS-Rendering-Process-概念"><a href="#iOS-Rendering-Process-概念" class="headerlink" title="iOS Rendering Process 概念"></a>iOS Rendering Process 概念</h2><p>iOS Rendering Process 译为 iOS 渲染流程，本文特指 iOS 设备从设置将要显示的图元数据到最终在设备屏幕成像的整个过程。</p>
<p>在开始剖析 iOS Rendering Process 之前，我们需要对 iOS 的渲染概念有一个基本的认知：</p>
<h3 id="基于平铺的渲染"><a href="#基于平铺的渲染" class="headerlink" title="基于平铺的渲染"></a>基于平铺的渲染</h3><p>iOS 设备的屏幕分为 N * N 像素的图块，每个图块都适合于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a> 缓存，几何体在图块内被大量拆分，只有在所有几何体全部提交之后才可以进行光栅化（Rasterization）。</p>
<img src="/ios-rendering-process/tile_based_rendering.jpg" class="">
<blockquote>
<p>Note: 这里的光栅化指将屏幕上面被大量拆分出来的几何体渲染为像素点的过程。</p>
</blockquote>
<img src="/ios-rendering-process/rasterization.jpg" class="">
<h2 id="iOS-Rendering-技术框架"><a href="#iOS-Rendering-技术框架" class="headerlink" title="iOS Rendering 技术框架"></a>iOS Rendering 技术框架</h2><p>事实上 iOS 渲染相关的层级划分大概如下：</p>
<img src="/ios-rendering-process/ios_rendering_framework.png" class="">
<h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p>嘛~ 作为一名 iOS Developer 来说，应该对 UIKit 都不陌生，我们日常开发中使用的用户交互组件都来自于 UIKit Framework，我们通过设置 UIKit 组件的 Layout 以及 BackgroundColor 等属性来完成日常的界面绘画工作。</p>
<p>其实 UIKit Framework 自身并不具备在屏幕成像的能力，它主要负责对用户操作事件的响应，事件响应的传递大体是经过逐层的<strong>视图树</strong>遍历实现的。</p>
<blockquote>
<p>那么我们日常写的 UIKit 组件为什么可以呈现在 iOS 设备的屏幕上呢？</p>
</blockquote>
<h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p>Core Animation 其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做 <strong>Layer Kit</strong> 这么一个不怎么和动画有关的名字演变而来的，所以做动画仅仅是 Core Animation 特性的冰山一角。</p>
<p>Core Animation 本质上可以理解为是一个复合引擎，旨在尽可能快的组合屏幕上不同的显示内容。这些显示内容被分解成独立的图层，即 CALayer，CALayer 才是你所能在屏幕上看见的一切的基础。</p>
<p>其实很多同学都应该知道 CALayer，UIKit 中需要在屏幕呈现的组件内部都有一个对应的 CALayer，也就是所谓的 Backing Layer。正是因为一一对应，所以 CALayer 也是树形结构的，我们称之为<strong>图层树</strong>。</p>
<p>视图的职责就是<strong>创建并管理</strong>这个图层，以确保当子视图在层级关系中<strong>添加或者被移除</strong>的时候，<strong>他们关联的图层</strong>也<strong>同样对应在层级关系树当中有相同的操作</strong>。</p>
<blockquote>
<p>但是为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级关系来处理所有事情呢？</p>
</blockquote>
<p>原因在于要做<strong>职责分离</strong>，这样也能<strong>避免很多重复代码</strong>。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，而 Mac OS X 有 AppKit 和 NSView 的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>
<blockquote>
<p>Note: 实际上，这里并不是两个层级关系，而是<strong>四个</strong>，每一个都扮演不同的角色，除了<strong>视图树</strong>和<strong>图层树</strong>之外，还存在<strong>呈现树</strong>和<strong>渲染树</strong>。</p>
</blockquote>
<h3 id="OpenGL-ES-amp-Core-Graphics"><a href="#OpenGL-ES-amp-Core-Graphics" class="headerlink" title="OpenGL ES &amp; Core Graphics"></a>OpenGL ES &amp; Core Graphics</h3><h4 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenGL_ES">OpenGL ES</a> 简称 GLES，即 OpenGL for Embedded Systems，是 OpenGL 的子集，通常面向<strong>图形硬件加速处理单元（GPU）</strong>渲染 2D 和 3D 计算机图形，例如视频游戏使用的计算机图形。</p>
<p>OpenGL ES 专为智能手机，平板电脑，视频游戏机和 PDA 等嵌入式系统而设计 。OpenGL ES 是“历史上应用最广泛的 3D 图形 API”。</p>
<h4 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h4><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphics</a> Framework 基于 Quartz 高级绘图引擎。它提供了具有无与伦比的输出保真度的低级别轻量级 2D 渲染。您可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p>
<blockquote>
<p>Note: 在 Mac OS X 中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。</p>
</blockquote>
<h3 id="Graphics-Hardware"><a href="#Graphics-Hardware" class="headerlink" title="Graphics Hardware"></a>Graphics Hardware</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphics_hardware">Graphics Hardware</a> 译为图形硬件，iOS 设备中也有自己的图形硬件设备，也就是我们经常提及的 GPU。</p>
<p><a href="">图形处理单元（GPU）</a>是一种专用电子电路，旨在快速操作和改变存储器，以加速在用于输出到显示设备的帧缓冲器中创建图像。GPU 被用于嵌入式系统，手机，个人电脑，工作站和游戏控制台。现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在<strong>大块数据并行处理的算法</strong>中比通用 CPU 更有效。</p>
<h2 id="OpenGL-主要渲染步骤"><a href="#OpenGL-主要渲染步骤" class="headerlink" title="OpenGL 主要渲染步骤"></a>OpenGL 主要渲染步骤</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> 全称 Open Graphics Library，译为开放图形库，是用于渲染 2D 和 3D 矢量图形的<strong>跨语言，跨平台</strong>的<strong>应用程序编程接口（API）</strong>。OpenGL 可以直接访问 GPU，以实现硬件加速渲染。</p>
<p>一个用来渲染图像的 OpenGL 程序主要可以大致分为以下几个步骤：</p>
<ul>
<li>设置图元数据</li>
<li>着色器-shader 计算图元数据（位置·颜色·其他）</li>
<li>光栅化-rasterization 渲染为像素</li>
<li>fragment shader，决定最终成像</li>
<li>其他操作（显示·隐藏·融合）</li>
</ul>
<blockquote>
<p>Note: 其实还有一些非必要的步骤，与本文主题不相关，这里点到为止。</p>
</blockquote>
<p>我们日常开发时使用 UIKit 布局视图控件，设置透明度等等都属于<strong>设置图元数据</strong>这步，这也是我们日常开发中可以影响 OpenGL 渲染的主要步骤。</p>
<h2 id="OpenGL-Render-Pipeline"><a href="#OpenGL-Render-Pipeline" class="headerlink" title="OpenGL Render Pipeline"></a>OpenGL Render Pipeline</h2><p>如果有同学看过 WWDC 的一些演讲稿或者接触过一些 OpenGL 知识，应该对 Render Pipeline 这个专业术语并不陌生。</p>
<p>不过 Render Pipeline 实在是一个初次见面不太容易理解的词，它译为<strong>渲染管道</strong>，也有译为渲染管线的…</p>
<p>其实 Render Pipeline 指的是<strong>从应用程序数据转换到最终渲染的图像之间的一系列数据处理过程</strong>。</p>
<p>好比我们上文中提到的 OpenGL 主要渲染步骤一样，我们开发应用程序时在<strong>设置图元数据</strong>这步为视图控件的设定布局，背景颜色，透明度以及阴影等等数据。</p>
<p>下面以 OpenGL 4.5 的 Render Pipeline 为例介绍一下：</p>
<img src="/ios-rendering-process/opengl_rendering_pipeline.png" class="">
<p>这些图元数据流入 OpenGL 中，传入<strong>顶点着色器（vetex shader）</strong>，然后顶点着色器对其进行着色器内部的处理后流出。之后可能进入<strong>细分着色阶段（tessellation shading stage）</strong>，其中又有可能分为细分控制着色器和细分赋值着色器两部分处理，还可能会进入<strong>几何着色阶段（geometry shading stage）</strong>，数据从中传递。最后都会走<strong>片元着色阶段（fragment shading stage）</strong>。</p>
<blockquote>
<p>Note: 图元数据是以 copy 的形式流入 shader 的，shader 一般会以特殊的<strong>类似全局变量的形式</strong>接收数据。</p>
</blockquote>
<p>OpenGL 在最终成像之前还会经历一个阶段名为<strong>计算着色阶段（compute shaing stage）</strong>，这个阶段 OpenGL 会计算最终要在屏幕中成像的像素位置以及颜色，如果在之前提交代码时用到了 CALayer 会引起 <strong>blending</strong> 的显示效果（例如 Shadow）或者视图颜色或内容图片的 alpha 通道开启，都将会加大这个阶段 OpenGL 的工作量。</p>
<h2 id="Core-Animation-Pipeline"><a href="#Core-Animation-Pipeline" class="headerlink" title="Core Animation Pipeline"></a>Core Animation Pipeline</h2><p>上文说到了 iOS 设备之所以可以成像不是因为 UIKit 而是因为 LayerKit，即 Core Animation。</p>
<p>Core Animation 图层，即 CALayer 中包含一个属性 contents，我们可以通过给这个属性赋值来<strong>控制 CALayer 成像的内容</strong>。这个属性的类型定义为 id，在程序编译时不论我们给 contents 赋予任何类型的值，都是可以编译通过的。但实践中，<strong>如果 contents 赋值类型不是 CGImage，那么你将会得到一个空白图层</strong>。</p>
<blockquote>
<p>Note: 造成 contents 属性的奇怪表现的原因是 Mac OS X 的历史包袱，它之所以被定义为 id 类型是因为在 Mac OS X 中这个属性对 CGImage 和 NSImage 类型的值都起作用。但是在 iOS 中，如果你赋予一个 UIImage 属性的值，仅仅会得到一个空白图层。</p>
</blockquote>
<p>说完 Core Animation 的 contents 属性，下面介绍一下 iOS 中 Core Animation Pipeline：</p>
<ul>
<li>在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层</li>
<li>Core Animation 图层相关的数据提交到 iOS Render Server，即 OpenGL ES &amp; Core Graphics</li>
<li>Render Server 将与 GPU 通信把数据经过处理之后传递给 GPU</li>
<li>GPU 调用 iOS 当前设备渲染相关的图形设备 Display</li>
</ul>
<img src="/ios-rendering-process/core_animation_pipeline.png" class="">
<blockquote>
<p>Note: 由于 iOS 设备目前的显示屏最大支持 <strong>60 FPS</strong> 的刷新率，所以每个处理间隔为 16.67 ms。</p>
</blockquote>
<p>可以看到从 Commit Transaction 之后我们的图元数据就将会在下一次 RunLoop 时被 Application 发送给底层的 Render Server，底层 Render Server 直接面向 GPU 经过一系列的数据处理将处理完毕的数据传递给 GPU，然后 GPU 负责渲染工作，根据当前 iOS 设备的屏幕计算图像<strong>像素位置以及像素 alpha 通道混色计算</strong>等等最终在当前 iOS 设备的显示屏中呈现图像。</p>
<blockquote>
<p>嘛~ 由于 Core Animation Pipeline 中 Render Server 包含 OpenGL ES &amp; Core Graphics，其中 OpenGL ES 的渲染可以参考上文 OpenGL Render Pipeline 理解。</p>
</blockquote>
<h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>Core Animation Pipeline 的整个管线中 iOS 常规开发一般可以影响到的范围也就仅仅是在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层这一级，即 <strong>Commit Transaction 之前的一些操作</strong>。</p>
<p>那么在 Commit Transaction 之前我们一般要做的事情有哪些？</p>
<ul>
<li>Layout，构建视图</li>
<li>Display，绘制视图</li>
<li>Prepare，额外的 Core Animation 工作</li>
<li>Commit，打包图层并将它们发送到 Render Server</li>
</ul>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>在 Layout 阶段我们能做的是把 constraint 写的尽量高效，iOS 的 Layout Constraint 类似于 Android 的 Relative Layout。</p>
<blockquote>
<p>Note: Emmmmm… 据观察 iOS 的 Layout Constraint 在书写时应该尽量少的依赖于视图树中同层级的兄弟视图节点，它会拖慢整个视图树的 Layout 计算过程。</p>
</blockquote>
<p><strong>这个阶段的 Layout 计算工作是在 CPU 完成的</strong>，包括 <code>layoutSubviews</code> 方法的重载，<code>addSubview:</code> 方法填充子视图等</p>
<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p>其实这里的 Display 仅仅是我们设置 iOS 设备要最终成像的图元数据而已，重载视图 <code>drawRect:</code> 方法可以自定义 UIView 的显示，其原理是在 <code>drawRect:</code> 方法内部绘制 bitmap。</p>
<blockquote>
<p>Note: 重载 <code>drawRect:</code> 方法绘制 bitmap 过程<strong>使用 CPU 和 内存</strong>。</p>
</blockquote>
<p>所以重载 <code>drawRect:</code> 使用不当会造成 CPU 负载过重，App 内存飙升等问题。</p>
<h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>这个步骤属于附加步骤，一般处理图像的解码 &amp; 转换等操作。</p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>Commit 步骤指打包图层并将它们发送到 Render Server。</p>
<blockquote>
<p>Note: Commit 操作会<strong>递归执行</strong>，由于图层和视图一样是以树形结构存在的，当图层树过于复杂时 Commit 操作的开销也会非常大。</p>
</blockquote>
<h4 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h4><p>CATransaction 是 Core Animation 中用于将多个图层树操作分配到渲染树的<strong>原子更新</strong>中的机制，对图层树的每个修改都必须是事务的一部分。</p>
<p>CATransaction 类没有属性或者实例方法，并且也不能用 <code>+alloc</code> 和 <code>-init</code> 方法创建它，我们只能用类方法 <code>+begin</code> 和 <code>+commit</code> 分别来入栈或者出栈。</p>
<p>事实上任何可动画化的图层属性都会被添加到栈顶的事务，你可以通过 <code>+setAnimationDuration:</code> 方法设置当前事务的动画时间，或者通过 <code>+animationDuration</code> 方法来获取时长值（默认 0.25 秒）。</p>
<p>Core Animation 在每个 RunLoop 周期中自动开始一次新的事务，即使你不显式地使用 <code>[CATransaction begin]</code> 开始一次事务，在一个特定 RunLoop 循环中的任何属性的变化都会被收集起来，然后做一次 0.25 秒的动画（CALayer 隐式动画）。</p>
<blockquote>
<p>Note: CATransaction 支持<strong>嵌套</strong>。</p>
</blockquote>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>对于 App 用户交互体验提升最明显的工作莫过于使用动画了，那么 iOS 是如何处理动画的渲染过程的呢？</p>
<p>日常开发中如果不是特别复杂的动画我们一般会使用 UIView Animation 实现，iOS 将 UIView Animation 的处理过程分为以下三个阶段：</p>
<ul>
<li>调用 <code>animateWithDuration:animations:</code> 方法</li>
<li>在 Animation Block 中进行 Layout，Display，Prepare，Commit</li>
<li>Render Server 根据 Animation 逐帧渲染</li>
</ul>
<img src="/ios-rendering-process/animation.png" class="">
<blockquote>
<p>Note: 原理是 <code>animateWithDuration:animations:</code> 内部使用了 CATransaction 来将整个 Animation Block 中的代码作为原子操作 commit 给了 RunLoop。</p>
</blockquote>
<h3 id="基于-CATransaction-实现链式动画"><a href="#基于-CATransaction-实现链式动画" class="headerlink" title="基于 CATransaction 实现链式动画"></a>基于 CATransaction 实现链式动画</h3><p>事实上大多数的动画交互都是有动画执行顺序的，尽管 UIView Animation 很强大，但是在写一些顺序动画时使用 UIView Animation 只能在 <code>+ (void)animateWithDuration:delay:options:animations:completion:</code> 方法的 completion block 中层级嵌套，写成一坨一坨 block 堆砌而成的代码，实在是难以阅读更别提后期维护了。</p>
<p>在得知 UIView Animation 使用了 CATransaction 时，我们不禁会想到这个 completion block 是不是也是基于 CATransaction 实现的呢？</p>
<p>Bingo！CATransaction 中有 <code>+completionBlock</code> 以及 <code>+setCompletionBlock:</code> 方法可以对应于 UIView Animation 的 completion block 的书写。</p>
<blockquote>
<p>Note: 我的一个开源库 <a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator"><strong>LSAnimator - 可多链式动画库</strong></a> 在<strong>动画顺序链接时也用到了 CATransaction</strong>。</p>
</blockquote>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>结合上下文不难梳理出一个 iOS <strong>最基本的完整渲染经过（Rendering pass）</strong>。</p>
<img src="/ios-rendering-process/rendering_pass.png" class="">
<h3 id="性能检测思路"><a href="#性能检测思路" class="headerlink" title="性能检测思路"></a>性能检测思路</h3><p>基于整篇文章的内容归纳一下我们在日常的开发工作中遇到性能问题时检测问题代码的思路：</p>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">建议</th>
<th style="text-align:center">检测工具</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">目标帧率</td>
<td style="text-align:center">60 FPS</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">CPU or GPU</td>
<td style="text-align:center">降低使用率节约能耗</td>
<td style="text-align:center">Time Profiler instrument</td>
</tr>
<tr>
<td style="text-align:center">不必要的 CPU 渲染</td>
<td style="text-align:center">GPU 渲染更理想，但要清楚 CPU 渲染在何时有意义</td>
<td style="text-align:center">Time Profiler instrument</td>
</tr>
<tr>
<td style="text-align:center">过多的 offscreen passes</td>
<td style="text-align:center">越少越好</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">过多的 blending</td>
<td style="text-align:center">越少越好</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">奇怪的图片格式或大小</td>
<td style="text-align:center">避免实时转换或调整大小</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">开销昂贵的视图或特效</td>
<td style="text-align:center">理解当前方案的开销成本</td>
<td style="text-align:center">Xcode View Debugger</td>
</tr>
<tr>
<td style="text-align:center">想象不到的层次结构</td>
<td style="text-align:center">了解实际的视图层次结构</td>
<td style="text-align:center">Xcode View Debugger</td>
</tr>
</tbody>
</table>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2014/419/">WWDC2014-Advanced Graphics and Animations for iOS Apps</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li>
</ul>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/opengl/" rel="tag">opengl</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/hhkb-bt/">
      HHKB 开箱留念
    </a>
  </h2>
  
  <time>
    4月 5, 2018
  </time>
  <section class="content">
	  <img src="/hhkb-bt/hhkb_c_00.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Emmmmm… 这个清明节本来打算去青海湖骑行的，不过因为北京 4 月飞雪的天气骤变加上自己没注意添衣… 最终还是没能出了帝都 ╮(╯▽╰)╭ </p>
<p>不过这也省下了一些开销~ 于是用本来准备出去踏青的 💰 入了一把垂涎已久的键盘，也就是本文的主角 —— HHKB 酱！</p>
<p>嘛~ 知道 HHKB 是在 2015 年，记得还是在某乎的一篇回答中看到的，答主是一个妹子，大意是这个妹子偷偷看到了程序猿男票的购物车中躺着一把 HHKB，然后这个对键盘一窍不通的妹子历尽波折将 HHKB 入手送给自己程序猿男票的暖心小故事。</p>
<p>当时的我刚刚毕业一年左右吧，也是正想买一把键盘来敲代码，提升自己的输出（事实证明，并没有太大帮助 ^_^||），见证自己的成长（这个打油的键帽们可以证明哟）。于是就搜到了这篇回答，看得我心里一暖，无比羡慕答主男票的同时自己默默的继续浏览其他关于键盘的东西…</p>
<p>最后在 Filco 和 HHKB 之间纠结挣扎了许久，选择了 Filco 87 青轴奶绿配色，不过想入一把 HHKB 的种子却埋在了心里…</p>
<p>有了大 F 的陪伴，HHKB 的艹长得依旧很快，每次在使用 ctrl maping command 键时心里的艹都会拔高一截，尤其是最近已经到了不能不拔的地步…</p>
<p>所以趁着这次机会，果断入手，写篇文章记录一下自己的开箱感受，说不定对某些同学有帮助呢~</p>
<blockquote>
<p>Note: 前排提示，多图预警！</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>HHKB</li>
<li>入手渠道</li>
<li>开箱照</li>
<li>手感体验</li>
<li>键帽</li>
<li>总结</li>
</ul>
<h2 id="HHKB"><a href="#HHKB" class="headerlink" title="HHKB"></a>HHKB</h2><p>HHKB 全称 Happy Hacking Keyboard，于 1996 年 12 月 20 日诞生于日本，系 <a target="_blank" rel="noopener" href="http://www.fujitsu.com/jp/">富士通</a> 旗下子公司 PFU 生产的紧凑型键盘，以逼格甚高的键盘配列、优秀流畅的敲击手感、高昂的售价为外设发烧友和码农们所熟知，亦以被 Hackers 钟爱而闻名。</p>
<p>关于 HHKB 的评测贴很多，这里只挑一些我认为值得聊得点来写：</p>
<ul>
<li>HHKB 的键盘配列为何如此设计？</li>
<li>什么是静电容轴？</li>
<li>谁捧红了 HHKB？</li>
</ul>
<h3 id="标志性配列"><a href="#标志性配列" class="headerlink" title="标志性配列"></a>标志性配列</h3><p>HHKB 是由日本 Hacker <a target="_blank" rel="noopener" href="https://www.pfu.fujitsu.com/hhkeyboard/dr_wada.html">和田英一</a> 和 PFU 研究所共同设计，从名字就可以看出此系列键盘的用户定位是 Hacker，这块键盘的配列从第一代设计至今未变，可以说是 HHKB 的标志性配列。</p>
<p>键盘非 67 键的普通主键区小键盘传统配列，为了 Hackers 可以更好的在 Emacs 和 Vim 下使用，键盘将高频键位 —— Ctrl 上移至 Cap 处，然后砍掉了 Cap… 并默认把 Esc 键下沉至低频键位 ~ 处，同时还把 Del 键下沉至 | 键处，甚至砍掉了 67 键配列中大多数人认为高频使用的方向键！</p>
<h3 id="静电容轴"><a href="#静电容轴" class="headerlink" title="静电容轴"></a>静电容轴</h3><p>HHKB 既不是大多数人用的量产薄膜键盘，也不是近些年来逐渐火热的机械键盘，而是采用了 <a target="_blank" rel="noopener" href="http://www.topre.co.jp/en/">Topre</a> 无接触式电容开关设计。</p>
<ul>
<li>普通薄膜键盘的触发开关是在橡胶下黏一块导电薄膜，通过这个导电薄膜触发按键开关。</li>
<li>机械键盘在机械轴体内部加入铜片，按键时通过机械轴体轴心挤压铜片触发按键开关。</li>
<li>静电容键盘通过碗状橡胶触发开关，触发原理是在按键过程中电极间距改变产生电容值变化，进而触发键盘讯号。</li>
</ul>
<blockquote>
<p>Note: 很多同学对机械键盘有误解，其实机械键盘轴体内部也是有弹簧的，轴体回弹也是依靠这个弹簧实现。</p>
</blockquote>
<h3 id="钟爱-HHKB-的大神"><a href="#钟爱-HHKB-的大神" class="headerlink" title="钟爱 HHKB 的大神"></a>钟爱 HHKB 的大神</h3><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Richard_Stallman">Richard Stallman</a>，GUN Emacs &amp; GCC 大佬。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>，C艹 之父。</li>
</ul>
<h2 id="入手渠道"><a href="#入手渠道" class="headerlink" title="入手渠道"></a>入手渠道</h2><p>我入手的是 HHKB Professional BT (Bluetooth) 版本，主要是看中了无线的优势，毕竟对于 Mac 来说，一个键盘占用一个 USB 接口太过奢侈了…</p>
<p>截止至下单时，日亚的售价是 29700 日元，约合人民币 1750 元。</p>
<p>某猫有一家认证过的 HHKB 官方旗舰店，售价 2388 元人民币，店铺限时活动 -200 元，加上满 200 即减 20 的满减活动，最终下单价为 2088 元。</p>
<p>考虑到行货保修问题，以及海淘邮寄可能出现的一些状况果断选择了国行。</p>
<h2 id="开箱照"><a href="#开箱照" class="headerlink" title="开箱照"></a>开箱照</h2><p>嘛~ 快递没什么好说的，店家包顺丰次日达，顺丰的服务一如既往的让人满意。</p>
<p>清明小长假第一天就到了，开箱签收之后洗手拍照留念（笑）。</p>
<blockquote>
<p>Note: 再次提示，多图预警！</p>
</blockquote>
<img src="/hhkb-bt/hhkb_00.jpg" class="">
<img src="/hhkb-bt/hhkb_01.jpg" class="">
<img src="/hhkb-bt/hhkb_02.jpg" class="">
<img src="/hhkb-bt/hhkb_03.jpg" class="">
<img src="/hhkb-bt/hhkb_04.jpg" class="">
<img src="/hhkb-bt/hhkb_05.jpg" class="">
<img src="/hhkb-bt/hhkb_06.jpg" class="">
<img src="/hhkb-bt/hhkb_07.jpg" class="">
<img src="/hhkb-bt/hhkb_08.jpg" class="">
<img src="/hhkb-bt/hhkb_09.jpg" class="">
<img src="/hhkb-bt/hhkb_10.jpg" class="">
<p>嘛~ 吐槽一下，HHKB Pro BT 的这个电池仓略丑，好在宝宝敲键盘的时候看不到它…</p>
<h2 id="手感体验"><a href="#手感体验" class="headerlink" title="手感体验"></a>手感体验</h2><p>买之前体验了同事的 HHKB Pro Type-S 和 HHKB Pro BT，对比发现手感上并无太大偏差，不过虽然 Type-S 缩短键程没有特别明显的手感体验差异，但是静音是真的差了一个梯度。BT 版本的声音并不吵，个人感觉应该比 Filco 红轴要略小，开放式办公应该问题不大。</p>
<p>不过讲真，HHKB 的手感并没有网上传的那么绵软流畅，质感也差了手边 Filco 青轴一段距离，也可能是我青轴用多了吧…</p>
<p>具体描述的话，HHKB 的手感略柔和，没有青轴按下按键触发开关时的清脆声，整体给我的感觉有点神似红轴，但是又不像红轴那样一触到底…</p>
<p>HHKB 和 Filco 都是信仰之物，上面的比较也是在较为苛刻的程度上我个人主观感受而已，毕竟这个价位的东西了，使用体验都会让人感到很舒服~</p>
<p>在蓝牙连接状态下敲代码，完全没有误敲，重复触发以及遗漏触发的情况，个人感觉还是十分满意哈~</p>
<h2 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a>键帽</h2><p>Emmmmm… 一开始并没有入 HHKB 的官方彩色键帽套装，理由是贵… 而且怕自己用不惯的话不方便退货。</p>
<p>不过在连续敲了两天键盘之后，感觉手感真的是玄学啊~ 慢慢的竟然有点喜欢 HHKB 这种静电容轴的手感了，尽管目前仍然认为不及我的大 F 青轴，但是并不排斥~</p>
<p>终于在网上看了很多搭配了 HHKB 官方彩色键帽的毒图之后，下单入手！</p>
<p>嘛~ 头图就是搭配了彩色键帽之后的 HHKB (＾Ｕ＾)ノ~ＹＯ</p>
<img src="/hhkb-bt/hhkb_c_00.jpg" class="">
<img src="/hhkb-bt/hhkb_c_01.jpg" class="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>HHKB 键盘配列不太适合 Windows 用户，不过非常适合 Mac OS X 下使用，一但养成肌肉记忆将会非常方便。</li>
<li>HHKB 手感偏绵软，给我个人的感觉还算比较舒服，但是不及大 F 青轴的手感。</li>
<li>HHKB Pro BT 蓝牙连接使用体验极好，没有遗漏以及重复触发按键的情况出现。</li>
<li>彩色键帽真的是可以瞬间提升 HHKB 极具内敛的颜值。</li>
</ul>
<p>最后放一下已经服役了将近 3 年的大 F 和新伙伴的合影。</p>
<img src="/hhkb-bt/iterative_filco.jpg" class="">
<img src="/hhkb-bt/iterative_hhkb.jpg" class="">


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/keyboard/" rel="tag">keyboard</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/oc_class_properties/">
      巧用 Objective-C Class Properties 解耦
    </a>
  </h2>
  
  <time>
    3月 25, 2018
  </time>
  <section class="content">
	  <img src="/oc_class_properties/oc_class_properties.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Emmmmm… Objective-C Class Properties 早在 WWDC 2016 中就已经公示，给 Objective-C 加入这个特性主要是为了与 Swift 类型属性相互操作。</p>
<p>官方是这么说明的：</p>
<blockquote>
<p>Interoperate with Swift type properties.</p>
</blockquote>
<p>嘛~ 虽然是为了配合 Swift 加入的新特性，不过聊胜于无哈！</p>
<blockquote>
<p>Note: 值得一提的是 Objective-C Class Properties 语法特性虽然是 WWDC 2016 加入的，不过由于是 Xcode 8 中 LLVM Compiler 的特性，因此也适用于 iOS 10 之前的部署版本哟~</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>LLVM</li>
<li>Objective-C Class Properties</li>
<li>解耦</li>
<li>总结</li>
</ul>
<h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><img src="/oc_class_properties/llvm.jpg" class="">
<p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM 官网</a> 对于 LLVM 的定义：</p>
<blockquote>
<p>Note: The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. </p>
</blockquote>
<p>Emmmmm… 有趣的是，有的文章把 LLVM 强行展开为 “low level virtual machine” 译为 “低级别虚拟机”，不过在 <a target="_blank" rel="noopener" href="https://llvm.org/">LLVM 官网</a> 可以看到官方明示 LLVM 与传统的虚拟机<strong>没有一毛钱关系</strong>，名称 “LLVM” 本身<strong>不是缩写</strong>，它仅仅是项目的名称而已~</p>
<p>嘛~ 可能有的同学不能理解为何 LLVM 是一个编译器工具链集合？这就要从 Apple 的编译器历史讲起咯~ </p>
<p>很久很久以前… 算了，我感觉要跑题了（囧），这里简单列一下 Apple 采用过的编译方案吧：</p>
<ul>
<li>GCC</li>
<li>LLVM &amp; GCC</li>
<li>LLVM Compiler</li>
</ul>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a> 是一套由 GNU 开发的编程语言编译器，最初作为 <a target="_blank" rel="noopener" href="http://www.gnu.org/gnu/thegnuproject.html">GNU 操作系统</a> 的编译器使用，后面发展成为类 Unix 操作系统以及 Apple Mac OS X 操作系统的标准编译器。</p>
<p>原本 GCC 仅能处理 C 语言的编译，不过 GCC 很快扩展以支持 C++，之后的 GCC 越发全面，支持 Objective-C，Fortran，Ada，以及 Go 语言。</p>
<p>值得一提的是 GCC 是一套以 GPL 以及 LGPL 许可证锁发行的 100% 自由软件，这意味着<strong>用户可以自由地运行，拷贝，分发，学习，修改并改进该软件</strong>。</p>
<h3 id="LLVM-amp-GCC"><a href="#LLVM-amp-GCC" class="headerlink" title="LLVM &amp; GCC"></a>LLVM &amp; GCC</h3><p>LLVM 我们前面介绍过了，是模块化 &amp; 可重用性编译器以及工具链技术集合。</p>
<p>LLVM 能够进行程序语言的 <strong>编译期优化、链接优化、在线编译优化、代码生成</strong>。</p>
<h3 id="LLVM-Compiler"><a href="#LLVM-Compiler" class="headerlink" title="LLVM Compiler"></a>LLVM Compiler</h3><p>前面介绍过 GCC 支持很多语言，系统架构庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中顺位（优先级）较低。此外，GCC 作为一个纯粹的编译系统，在与 IDE 配合方面的表现也很差。</p>
<p>So，Apple 决定从零开始写 C，C++，Objective-C 的编译器 Clang。</p>
<p>至此，Apple 彻底与 GCC 了断。</p>
<h2 id="Objective-C-Class-Properties"><a href="#Objective-C-Class-Properties" class="headerlink" title="Objective-C Class Properties"></a>Objective-C Class Properties</h2><img src="/oc_class_properties/oc_feature.jpg" class="">
<p>Objective-C Class Properties 作为 Objective-C 新语法特性在 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/405/">WWDC2016 What’s New in LLVM</a> 中公示，表示 Xcode 8 之后可以使用这一新语法特性。</p>
<p>使用方式很简单：</p>
<ul>
<li>Declared with <code>class</code> flag </li>
<li>Accessed with dot syntax</li>
<li>Never synthesized</li>
<li>Use <code>@dynamic</code> to defer to runtime</li>
</ul>
<h3 id="Declared-with-class-flag"><a href="#Declared-with-class-flag" class="headerlink" title="Declared with class flag"></a>Declared with <code>class</code> flag</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyType</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>) <span class="built_in">NSString</span> *someString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Accessed-with-dot-syntax"><a href="#Accessed-with-dot-syntax" class="headerlink" title="Accessed with dot syntax"></a>Accessed with dot syntax</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;format string: %@&quot;</span>, MyType.someString);</span><br></pre></td></tr></table></figure>
<h3 id="Never-synthesized"><a href="#Never-synthesized" class="headerlink" title="Never synthesized"></a>Never synthesized</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyType</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *_someString = <span class="literal">nil</span>;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)someString &#123; <span class="keyword">return</span> _someString; &#125;</span><br><span class="line">+ (<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)newString &#123; _someString = newString; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Use-dynamic-to-defer-to-runtime"><a href="#Use-dynamic-to-defer-to-runtime" class="headerlink" title="Use @dynamic to defer to runtime"></a>Use <code>@dynamic</code> to defer to runtime</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyType</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> (<span class="keyword">class</span>) someString;</span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL) name &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>笔者在做项目组件下沉时，遇到一个问题，正好适用于 Objective-C Class Properties 发挥：将要下沉的组件库中某系统类 Categroy 引用了业务层某方法。</p>
<img src="/oc_class_properties/before_decoupling.png" class="">
<p>业务层应该依赖于将要下沉的组件，而组件既然要下沉就不应该再反过来依赖上层业务实现！</p>
<p>按照常规思路，想要把上层业务中被依赖的部分一起随组件下沉，但是发现被依赖的部分虽然也属于一个较为基础的模块，不过此模块现阶段不做下沉…</p>
<p>后来经过组内大佬指点，使用 Objective-C Class Properties 解决了这个问题，即将上层业务被依赖的部分化作将要下沉组件依赖方系统类 Categroy 的 Class Properties。</p>
<blockquote>
<p>Note: 在 Categroy 中写 Objective-C Class Properties 需要使用 Runtime 关联方法。</p>
</blockquote>
<img src="/oc_class_properties/after_decoupling.png" class="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>介绍了 LLVM 顺便提到了 Apple 的编译系统发展简史。</li>
<li>使用官方 Demo 简单介绍了 Objective-C Class Properties 语法特性的书写方式。</li>
<li>提供了一种巧妙使用 Objective-C Class Properties 解耦的思路。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017_2018/">
      嘛~ 又一年了啊...
    </a>
  </h2>
  
  <time>
    3月 10, 2018
  </time>
  <section class="content">
	  <img src="/2017_2018/sd.jpeg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Emmmmm… 不知不觉已经一个多月没有提笔写文章了。</p>
<p>年前的一段时间确实比较忙，一方面想要尽可能的站好最后一班岗，把公司交给自己的事情做好；另一方面也在寻找新的机会，幸运的是在这一过程中得到了很多牛人的赏识和认可，获得了一些帮助以及内推机会，真的很感恩。</p>
<p>这次看机会都是在比较知名的项目或大厂中寻找的，前前后后忙碌了一个多月的时间，分别面试了头条，知乎，美团·点评，新浪，阿里巴巴这 5 家公司。</p>
<p>比较遗憾的是由于面试头条的时间点在 1 月 初，清楚记得元旦时期自己的三天假期基本都投入到了个人开源项目 <a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator">LSAnimator</a> 的迭代中，准备不充分加上较长时间没有参加过正式面试导致最后没能通过，辜负了彬哥的内推（囧）。</p>
<p>值得庆幸的是后面几家公司都如愿拿到了 offer，尤其在拿到阿里巴巴口头 offer 之后的欣喜若狂仿佛就在昨天（笑），不过由于个人原因没能加入阿里巴巴，最后选择了美团·点评核心部门的 offer。</p>
<p>本来想趁着春招之际把自己年前的面试经历总结一下，写一篇面试攻略。转念一想自己的博客里面还是应该记录一些自己的想法，于是才有这一篇水文出来（笑）。</p>
<blockquote>
<p>嘛~ 既然是水文，就不会有什么干货在后面粗线了。想了解上述公司面试流程以及面试题的同学可以就此打住，不用再往下看了，以免浪费时间哟~</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>迁徙</li>
<li>ELSEWHERE</li>
<li>未来</li>
</ul>
<h2 id="迁徙"><a href="#迁徙" class="headerlink" title="迁徙"></a>迁徙</h2><p>回顾 2017 年的大事，应该就是从深圳迁徙到北京了吧… 从 14 年毕业之后就去了深圳，这一待就是 3 年，不知不觉已经对那座年轻的城市有了一些感情，一下子回到北方竟还有些舍不得。</p>
<p>还记得刚毕业的那段日子，住在公司提供的应届生宿舍里，与其他小伙伴吃在一起，住在一起。随后从公司宿舍搬出来，拿着仅够维持在深圳生活的工资，过着紧张而迷茫的日子。拿出自己一年多攒下的钱买了人生中第一台 Mac 和 iPhone，开始自学 iOS 开发并且第一次跳槽。</p>
<p>后面又经历了许许多多的第一次，也包括这次迁徙。</p>
<p>嘛~ 毕竟是北方长大的孩子，初来北京的感觉就是亲切，这里的建筑，植物，小吃… 一切的一切都有着久违的亲切感。</p>
<h2 id="ELSEWHERE"><a href="#ELSEWHERE" class="headerlink" title="ELSEWHERE"></a>ELSEWHERE</h2><img src="/2017_2018/hutong.jpg" class="">
<p>来北京的第一份工作是在皇城根儿旁边的胡同里，一如既往的创业公司（笑），貌似除了校招去的公司是比较大的上市公司之外，自从转了 iOS 开发之后的几次选择都选了创业公司… </p>
<p>当时清楚记得是 CTO 亲自面试，见面的第一印象就是很亲切和善，风度翩翩。聊了聊发现公司虽然是初创团队，但是每个人的素质和背景都很出众，尤其是研发团队的综合素质很高，我一个 211 垫底大学进去的时候不敢大声说话（笑）。</p>
<p>半年多的工作中，兢兢业业，生怕因为自己的失误拖了整个团队的后腿，好在一直没有出什么纰漏，上级对我的工作也比较满意，在里面与各位同事相处的也很愉快…</p>
<p>不过好事多磨，团队内部也发生过一些摩擦，带我一起去胡同里面小学打球的两个大哥先后离职，最后我也由于种种原因离开了…</p>
<p>虽然相处时间算不上长，但是在 ELSEWHERE 的这段时间成长很多，与大家相处的也很愉快，特别是研发部的小伙伴们，现在还一直有来往呢。也许，下次搬家会考虑在一起合租一套大房子呢~</p>
<p>这里也被我命名为 ELSEWHERE，旨在纪念这段来北京后的第一份工作，也顺便祝福 ELSEWHERE 能杀出重围，越走越远吧…</p>
<img src="/2017_2018/elsewhere.jpeg" class="">
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>想自己毕业三年有余，却一事无成…</p>
<p>说出来自己都想笑，一直选择创业公司是因为想要改变世界…</p>
<p>自己当初在大学里拿到奖牌后吹过的牛逼还历历在目…</p>
<p>以前一直不懂为什么社会是个大染缸，现在身上已经被沾染上一些社会的颜色之后才明白这个比喻是多么的贴切而又无可奈何。时间也确实是一把利器，这才三年多的光景，就把梦想越磨越小，小到不见…</p>
<p>对自己说，也许现在我还没有创业的资本，等日后多些积累定要卷土重来…</p>
<p>对自己说，也许去大厂并非只是做一颗螺丝钉，毕竟用户量大，自己做的事情即使再小再微不足道，都是可以对用户端有些许影响的，从某种意义上讲也实现了改变人们的生活，改变了世界…</p>
<p>以后的事，谁又能说的准呢？只希望自己可以变得越来越强…</p>
<img src="/2017_2018/cat.jpg" class="">


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/summary/" rel="tag">summary</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/aspects/">
      从 Aspects 源码中我学到了什么？
    </a>
  </h2>
  
  <time>
    1月 17, 2018
  </time>
  <section class="content">
	  <img src="/aspects/aspects.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP (Aspect-oriented programming)</a> 译为 “面向切面编程”，是通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>Emmmmm…AOP 目前是较为热门的一个话题，尽管你也许没有听说过它，但是你的项目中可能已经渗入了它，例如：用户统计（不添加一行代码即实现对所有 ViewController 的跟踪日志）。</p>
<p>对于 iOS 开发者而言，无外乎 Swift 和 Objective-C 两种主流开发语言：</p>
<ul>
<li>Swift 受限于 ABI 尚未稳定，动态性依赖 <code>dynamic</code> 修饰符，在 Runtime 没有留给我们太多的发挥空间（前几日新增了 <code>swift-5.0-branch</code> 分支，写这篇文章时看了一眼 <code>181 commits behind master</code> 😂）。</li>
<li>Objective-C 在动态性上相对 Swift 具有无限大的优势，这几年 Objective-C Runtime 相关文章多如牛毛，相信现在的 iOSer 都具备一定的 Runtime 相关知识。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/steipete/Aspects">Aspects</a> 作为 Objective-C 语言编写的 AOP 库，适用于 iOS 和 Mac OS X，使用体验简单愉快，已经在 GitHub 摘得 5k+ Star。Aspects 内部实现比较健全，考虑到了 Hook 安全方面可能发生的种种问题，非常值得我们学习。</p>
<blockquote>
<p>Note: 本文内引用 Aspects 源码版本为 v1.4.2，要求读者具备一定的 Runtime 知识。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>AOP 简介</li>
<li>Aspects 简介</li>
<li>Aspects 结构剖析</li>
<li>Aspects 核心代码剖析</li>
<li>优秀 AOP 库应该具备的特质</li>
<li>总结</li>
</ul>
<h2 id="AOP-简介"><a href="#AOP-简介" class="headerlink" title="AOP 简介"></a>AOP 简介</h2><img src="/aspects/aop.jpg" class="">
<blockquote>
<p>在<strong>运行时，动态地</strong>将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP (Aspect-oriented programming)</a>，即 “面向切面编程” 是一种编程范式，或者说是一种编程思想，它解决了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">OOP (Object-oriented programming)</a> 的延伸问题。</p>
<h3 id="什么时候需要使用-AOP"><a href="#什么时候需要使用-AOP" class="headerlink" title="什么时候需要使用 AOP"></a>什么时候需要使用 AOP</h3><p>光是给个概念可能初次接触 AOP 的人还是无法 Get 到其中微秒，拿我们前言中举的例子🌰，假设随着我们所在的公司逐步发展，之前第三方的用户页面统计已经不能满足需求了，公司要求实现一个我们自己的用户页面统计。</p>
<p>嘛~ 我们来理一下 OOP 思想下该怎么办？</p>
<ul>
<li>一个熟悉 OOP 思想的程序猿会理所应当的想到要把用户页面统计这一任务放到 ViewController 中；</li>
<li>考虑到一个个的手动添加统计代码要死人（而且还会漏，以后新增 ViewController 也要手动加），于是想到了 OOP 思想中的继承；</li>
<li>不巧由于项目久远，所有的 ViewController 都是直接继承自系统类 UIViewController（笑），此时选择抽一个项目 RootViewController，替换所有 ViewController 继承 RootViewController；</li>
<li>然后在 RootViewController 的 <code>viewWillAppear:</code> 和 <code>viewWillDisappear:</code> 方法加入时间统计代码，记录 ViewController 以及 Router 传参。</li>
</ul>
<p>你会想，明明 OOP 也能解决问题是不是？不要急，再假设你们公司有多个 App，你被抽调至基础技术组专门给这些 App 写<strong>通用</strong>组件，要把之前实现过的用户页面统计重新以<strong>通用</strong>的形式实现，提供给你们公司所有的 App 使用。</p>
<p>MMP，使用标准 OOP 思想貌似无解啊…这个时候就是 AOP 的用武之地了。</p>
<p>这里简单给个思路：Hook UIViewController 的 <code>viewWillAppear:</code> 和 <code>viewWillDisappear:</code> 方法，在原方法执行之后记录需要统计的信息上报即可。</p>
<blockquote>
<p>Note: 简单通过 Method Swizzling 来 Hook 不是不可以，但是有很多安全隐患！</p>
</blockquote>
<h2 id="Aspects-简介"><a href="#Aspects-简介" class="headerlink" title="Aspects 简介"></a>Aspects 简介</h2><img src="/aspects/aspects_logo.jpg" class="">
<p><a target="_blank" rel="noopener" href="https://github.com/steipete/Aspects">Aspects</a> 是一个使用起来简单愉快的 AOP 库，使用 Objective-C 编写，适用于 iOS 与 Mac OS X。</p>
<blockquote>
<p>Aspects 内部实现考虑到了很多 Hook 可能引发的问题，笔者在看源码的过程中抠的比较细，真的是受益匪浅。</p>
</blockquote>
<p>Aspects 简单易用，作者通过在 <code>NSObject (Aspects)</code> 分类中暴露出的两个接口分别提供了对实例和 Class 的 Hook 实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Aspects</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(<span class="type">id</span>)block</span><br><span class="line">                            error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(<span class="type">id</span>)block</span><br><span class="line">                            error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Aspects 支持实例 Hook，相较其他 Objective-C AOP 库而言可操作粒度更小，适合的场景更加多样化。作为使用者无需进行更多的操作即可 Hook 指定实例或者 Class 的指定 SEL，AspectOptions 参数可以指定 Hook 的点，以及是否执行一次之后就撤销 Hook。</p>
<h2 id="Aspects-结构剖析"><a href="#Aspects-结构剖析" class="headerlink" title="Aspects 结构剖析"></a>Aspects 结构剖析</h2><img src="/aspects/aspects_struct.png" class="">
<p>Emmmmm…尽管 Aspects 只有不到千行的源码，但是其内部实现考虑到了很多 Hook 相关的安全问题和其他细节，对比其他 Objective-C AOP 开源项目来说 Aspects 更为健全，所以我自己在扒 Aspects 源码时也看的比较仔细。</p>
<h3 id="Aspects-内部结构"><a href="#Aspects-内部结构" class="headerlink" title="Aspects 内部结构"></a>Aspects 内部结构</h3><p>Aspects 内部定义了两个协议：</p>
<ul>
<li>AspectToken - 用于注销 Hook</li>
<li>AspectInfo - 嵌入 Hook 中的 Block 首位参数</li>
</ul>
<p>此外 Aspects 内部还定义了 4 个类：</p>
<ul>
<li>AspectInfo - 切面信息，遵循 AspectInfo 协议</li>
<li>AspectIdentifier - 切面 ID，<strong>应该</strong>遵循 AspectToken 协议（作者漏掉了，已提 PR）</li>
<li>AspectsContainer - 切面容器</li>
<li>AspectTracker - 切面跟踪器</li>
</ul>
<p>以及一个结构体：</p>
<ul>
<li>AspectBlockRef - 即 <code>_AspectBlock</code>，充当内部 Block</li>
</ul>
<p>如果你扒一遍源码，还会发现两个内部静态全局变量：</p>
<ul>
<li><code>static NSMutableDictionary *swizzledClassesDict;</code></li>
<li><code>static NSMutableSet *swizzledClasses;</code></li>
</ul>
<p>现在你也许还不能理解为什么要定义这么多东西，别急~ 我们后面都会分析到。</p>
<h3 id="Aspects-协议"><a href="#Aspects-协议" class="headerlink" title="Aspects 协议"></a>Aspects 协议</h3><p>按照上面列出的顺序，先来介绍一些 Aspects 声明的协议。</p>
<h4 id="AspectToken"><a href="#AspectToken" class="headerlink" title="AspectToken"></a>AspectToken</h4><p>AspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook，内部规定遵守此协议的对象须实现 <code>remove</code> 方法。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 不透明的 Aspect Token，用于注销 Hook</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AspectToken</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 注销一个 aspect.</span></span><br><span class="line"><span class="comment">/// 返回 YES 表示注销成功，否则返回 NO</span></span><br><span class="line">- (<span class="type">BOOL</span>)remove;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="AspectInfo"><a href="#AspectInfo" class="headerlink" title="AspectInfo"></a>AspectInfo</h4><p>AspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，我们在 Hook 时添加切面的 Block 第一个参数就遵守此协议。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// AspectInfo 协议是我们块语法的第一个参数。</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AspectInfo</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当前被 Hook 的实例</span></span><br><span class="line">- (<span class="type">id</span>)instance;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 被 Hook 方法的原始 invocation</span></span><br><span class="line">- (<span class="built_in">NSInvocation</span> *)originalInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 所有方法参数（装箱之后的）惰性执行</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)arguments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 装箱是一个开销昂贵操作，所以用到再去执行。</p>
</blockquote>
<h3 id="Aspects-内部类"><a href="#Aspects-内部类" class="headerlink" title="Aspects 内部类"></a>Aspects 内部类</h3><p>接着协议，我们下面详细介绍一下 Aspects 的内部类。</p>
<h4 id="AspectInfo-1"><a href="#AspectInfo-1" class="headerlink" title="AspectInfo"></a>AspectInfo</h4><blockquote>
<p>Note: AspectInfo 在这里是一个 Class，其遵守上文中讲到的 AspectInfo 协议，不要混淆。</p>
</blockquote>
<p>AspectInfo 类定义：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">AspectInfo</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithInstance:(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span>)instance invocation:(<span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) <span class="type">id</span> instance;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *arguments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInvocation</span> *originalInvocation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 关于装箱，对于提供一个 NSInvocation 就可以拿到其 <code>arguments</code> 这一点上，ReactiveCocoa 团队提供了很大贡献（细节见 Aspects 内部 NSInvocation 分类）。</p>
</blockquote>
<p>AspectInfo 比较简单，参考 ReactiveCocoa 团队提供的 NSInvocation 参数通用方法可将参数装箱为 NSValue，简单来说 AspectInfo 扮演了一个提供 Hook 信息的角色。</p>
<h4 id="AspectIdentifier"><a href="#AspectIdentifier" class="headerlink" title="AspectIdentifier"></a>AspectIdentifier</h4><p>AspectIdentifier 类定义：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectIdentifier</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)identifierWithSelector:(SEL)selector object:(<span class="type">id</span>)object options:(AspectOptions)options block:(<span class="type">id</span>)block error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)invokeWithInfo:(<span class="type">id</span>&lt;AspectInfo&gt;)info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL selector;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="type">id</span> block;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMethodSignature</span> *blockSignature;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="type">id</span> object;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AspectOptions options;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: AspectIdentifier 实际上是添加切面的 Block 的第一个参数，其应该遵循 AspectToken 协议，事实上也的确如此，其提供了 <code>remove</code> 方法的实现。</p>
</blockquote>
<p>AspectIdentifier 内部需要注意的是由于使用 Block 来写 Hook 中我们加的料，这里生成了 <code>blockSignature</code>，在 AspectIdentifier 初始化的过程中会去判断 <code>blockSignature</code> 与入参 <code>object</code> 的 <code>selector</code> 得到的 <code>methodSignature</code> 的兼容性，兼容性判断成功才会顺利初始化。</p>
<h4 id="AspectsContainer"><a href="#AspectsContainer" class="headerlink" title="AspectsContainer"></a>AspectsContainer</h4><p>AspectsContainer 类定义：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectsContainer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;</span><br><span class="line">- (<span class="type">BOOL</span>)removeAspect:(<span class="type">id</span>)aspect;</span><br><span class="line">- (<span class="type">BOOL</span>)hasAspects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *beforeAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *insteadAspects;</span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">copy</span>) <span class="built_in">NSArray</span> *afterAspects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>AspectsContainer 作为切面的容器类，<strong>关联</strong>指定对象的指定方法，内部有三个切面队列，分别容纳关联指定对象的指定方法中相对应 AspectOption 的 Hook：</p>
<ul>
<li><code>NSArray *beforeAspects;</code> - AspectPositionBefore</li>
<li><code>NSArray *insteadAspects;</code> - AspectPositionInstead</li>
<li><code>NSArray *afterAspects;</code> - AspectPositionAfter</li>
</ul>
<p>为什么要说关联呢？因为 AspectsContainer 是在 NSObject 分类中通过 AssociatedObject 方法与当前要 Hook 的目标关联在一起的。</p>
<blockquote>
<p>Note: 关联目标是 Hook 之后的 Selector，即 <code>aliasSelector</code>（原始 SEL 名称加 <code>aspects_</code> 前缀对应的 SEL）。</p>
</blockquote>
<h4 id="AspectTracker"><a href="#AspectTracker" class="headerlink" title="AspectTracker"></a>AspectTracker</h4><p>AspectTracker 类定义：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AspectTracker</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) Class trackedClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *selectorNames;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) AspectTracker *parentEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>AspectTracker 作为切面追踪器，原理大致如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the selector as being modified.</span></span><br><span class="line">currentClass = klass;</span><br><span class="line">AspectTracker *parentTracker = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    AspectTracker *tracker = swizzledClassesDict[currentClass];</span><br><span class="line">    <span class="keyword">if</span> (!tracker) &#123;</span><br><span class="line">        tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker];</span><br><span class="line">        swizzledClassesDict[(<span class="type">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)currentClass] = tracker;</span><br><span class="line">    &#125;</span><br><span class="line">    [tracker.selectorNames addObject:selectorName];</span><br><span class="line">    <span class="comment">// All superclasses get marked as having a subclass that is modified.</span></span><br><span class="line">    parentTracker = tracker;</span><br><span class="line">&#125;<span class="keyword">while</span> ((currentClass = class_getSuperclass(currentClass)));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 聪明的你应该已经注意到了全局变量 <code>swizzledClassesDict</code> 中的 <code>value</code> 对应着 AspectTracker 指针。</p>
</blockquote>
<p>嘛~ 就是说 AspectTracker 是从下而上追踪，最底层的 <code>parentEntry</code> 为 <code>nil</code>，父类的 <code>parentEntry</code> 为子类的 <code>tracker</code>。</p>
<h3 id="Aspects-内部结构体"><a href="#Aspects-内部结构体" class="headerlink" title="Aspects 内部结构体"></a>Aspects 内部结构体</h3><h4 id="AspectBlockRef"><a href="#AspectBlockRef" class="headerlink" title="AspectBlockRef"></a>AspectBlockRef</h4><p>AspectBlockRef，即 <code>struct _AspectBlock</code>，其定义如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _AspectBlock &#123;</span><br><span class="line">	__unused Class isa;</span><br><span class="line">	AspectBlockFlags flags;</span><br><span class="line">	__unused <span class="type">int</span> reserved;</span><br><span class="line">	<span class="type">void</span> (__unused *invoke)(<span class="keyword">struct</span> _AspectBlock *block, ...);</span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> reserved;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> size;</span><br><span class="line">		<span class="comment">// requires AspectBlockFlagsHasCopyDisposeHelpers</span></span><br><span class="line">		<span class="type">void</span> (*<span class="keyword">copy</span>)(<span class="type">void</span> *dst, <span class="keyword">const</span> <span class="type">void</span> *src);</span><br><span class="line">		<span class="type">void</span> (*dispose)(<span class="keyword">const</span> <span class="type">void</span> *);</span><br><span class="line">		<span class="comment">// requires AspectBlockFlagsHasSignature</span></span><br><span class="line">		<span class="keyword">const</span> <span class="type">char</span> *signature;</span><br><span class="line">		<span class="keyword">const</span> <span class="type">char</span> *layout;</span><br><span class="line">	&#125; *descriptor;</span><br><span class="line">	<span class="comment">// imported variables</span></span><br><span class="line">&#125; *AspectBlockRef;</span><br></pre></td></tr></table></figure>
<p>Emmmmm…没什么特别的，大家应该比较眼熟吧。</p>
<blockquote>
<p>Note: <code>__unused</code> 宏定义实际上是 <code>__attribute__((unused))</code> GCC 定语，旨在告诉编译器“如果我没有在后面使用到这个变量也别警告我”。</p>
</blockquote>
<p>嘛~ 想起之前自己挖的坑还没有填，事实上自己也不知道什么时候填（笑）：</p>
<ul>
<li>之前挖坑说要写一篇文章记录一些阅读源码时发现的代码书写技巧</li>
<li>之前挖坑说要封装一个 WKWebView 给群里的兄弟参考</li>
</ul>
<p>不要急~ 你瞧伦家不是都记得嘛（至于什么时候填坑嘛就…咳咳）</p>
<h3 id="Aspects-静态全局变量"><a href="#Aspects-静态全局变量" class="headerlink" title="Aspects 静态全局变量"></a>Aspects 静态全局变量</h3><h4 id="static-NSMutableDictionary-swizzledClassesDict"><a href="#static-NSMutableDictionary-swizzledClassesDict" class="headerlink" title="static NSMutableDictionary *swizzledClassesDict;"></a><code>static NSMutableDictionary *swizzledClassesDict;</code></h4><p><code>static NSMutableDictionary *swizzledClassesDict;</code> 在 Aspects 中扮演着已混写类字典的角色，其内部结构应该是这样的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Class : AspectTracker *&gt;</span><br></pre></td></tr></table></figure>
<p>Aspects 内部提供了专门访问这个全局字典的方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *aspect_getSwizzledClassesDict() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableDictionary</span> *swizzledClassesDict;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        swizzledClassesDict = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> swizzledClassesDict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个全局变量可以简单理解为记录整个 Hook 影响的 Class 包含其 SuperClass 的追踪记录的全局字典。</p>
<h4 id="static-NSMutableSet-swizzledClasses"><a href="#static-NSMutableSet-swizzledClasses" class="headerlink" title="static NSMutableSet *swizzledClasses;"></a><code>static NSMutableSet *swizzledClasses;</code></h4><p><code>static NSMutableSet *swizzledClasses;</code> 在 Aspects 中担当记录已混写类的角色，其内部结构如下：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">NSStringFromClass</span>(Class)&gt;</span><br></pre></td></tr></table></figure>
<p>Aspects 内部提供一个用于修改这个全局变量内容的方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> _aspect_modifySwizzledClasses(<span class="type">void</span> (^block)(<span class="built_in">NSMutableSet</span> *swizzledClasses)) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *swizzledClasses;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">        swizzledClasses = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">@synchronized</span>(swizzledClasses) &#123;</span><br><span class="line">        block(swizzledClasses);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 注意 <code>@synchronized(swizzledClasses)</code>。</p>
</blockquote>
<p>这个全局变量记录了 <code>forwardInvocation:</code> 被混写的的类名称。</p>
<blockquote>
<p>Note: 注意在用途上与 <code>static NSMutableDictionary *swizzledClassesDict;</code> 区分理解。</p>
</blockquote>
<h2 id="Aspects-核心代码剖析"><a href="#Aspects-核心代码剖析" class="headerlink" title="Aspects 核心代码剖析"></a>Aspects 核心代码剖析</h2><img src="/aspects/aspects_core.png" class="">
<p>嘛~ Aspects 的整体实现代码不超过一千行，而且考虑的情况也比较全面，非常值得大家花时间去读一下，这里我只准备给出自己对其核心代码的理解。</p>
<h3 id="Hook-Class-amp-amp-Hook-Instance"><a href="#Hook-Class-amp-amp-Hook-Instance" class="headerlink" title="Hook Class &amp;&amp; Hook Instance"></a>Hook Class &amp;&amp; Hook Instance</h3><p>Aspects 不光支持 Hook Class 还支持 Hook Instance，这提供了更小粒度的控制，配合 Hook 的撤销功能可以更加灵活精准的做我们想做的事~</p>
<p>Aspects 为了能区别 Class 和 Instance 的逻辑，实现了名为 <code>aspect_hookClass</code> 的方法，我认为其中的实现值得我用一部分篇幅来单独讲解，也觉得读者们有必要花点时间理解这里的实现逻辑。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class aspect_hookClass(<span class="built_in">NSObject</span> *<span class="keyword">self</span>, <span class="built_in">NSError</span> **error) &#123;</span><br><span class="line">    <span class="comment">// 断言 self</span></span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// class</span></span><br><span class="line">    Class statedClass = <span class="keyword">self</span>.class;</span><br><span class="line">    <span class="comment">// isa</span></span><br><span class="line">    Class baseClass = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(baseClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 已经子类化过了</span></span><br><span class="line">    <span class="keyword">if</span> ([className hasSuffix:AspectsSubclassSuffix]) &#123;</span><br><span class="line">        <span class="keyword">return</span> baseClass;</span><br><span class="line">        <span class="comment">// 我们混写了一个 class 对象，而非一个单独的 object</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (class_isMetaClass(baseClass)) &#123;</span><br><span class="line">        <span class="comment">// baseClass 是元类，则 self 是 Class 或 MetaClass，混写 self</span></span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace((Class)<span class="keyword">self</span>);</span><br><span class="line">        <span class="comment">// 可能是一个 KVO&#x27;ed class。混写就位。也要混写 meta classes。</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (statedClass != baseClass) &#123;</span><br><span class="line">        <span class="comment">// 当 .class 和 isa 指向不同的情况，混写 baseClass</span></span><br><span class="line">        <span class="keyword">return</span> aspect_swizzleClassInPlace(baseClass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认情况下，动态创建子类</span></span><br><span class="line">    <span class="comment">// 拼接子类后缀 AspectsSubclassSuffix</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">    <span class="comment">// 尝试用拼接后缀的名称获取 isa</span></span><br><span class="line">    Class subclass = objc_getClass(subclassName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找不到 isa，代表还没有动态创建过这个子类</span></span><br><span class="line">    <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 class pair，baseClass 作为新类的 superClass，类名为 subclassName</span></span><br><span class="line">        subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (subclass == <span class="literal">nil</span>) &#123; <span class="comment">// 返回 nil，即创建失败</span></span><br><span class="line">            <span class="built_in">NSString</span> *errrorDesc = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;objc_allocateClassPair failed to allocate class %s.&quot;</span>, subclassName];</span><br><span class="line">            AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 混写 forwardInvocation:</span></span><br><span class="line">        aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">        <span class="comment">// subClass.class = statedClass</span></span><br><span class="line">        aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">        <span class="comment">// subClass.isa.class = statedClass</span></span><br><span class="line">        aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">        <span class="comment">// 注册新类</span></span><br><span class="line">        objc_registerClassPair(subclass);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 覆盖 isa</span></span><br><span class="line">    object_setClass(<span class="keyword">self</span>, subclass);</span><br><span class="line">    <span class="keyword">return</span> subclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实这里的难点就在于对 <code>.class</code> 和 <code>object_getClass</code> 的区分。</p>
</blockquote>
<ul>
<li><code>.class</code> 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身</li>
<li><code>object_getClass</code> 返回 <code>isa</code> 指针的指向</li>
</ul>
<blockquote>
<p>Note: 动态创建一个 Class 的完整步骤也是我们应该注意的。</p>
</blockquote>
<ul>
<li>objc_allocateClassPair</li>
<li>class_addMethod</li>
<li>class_addIvar</li>
<li>objc_registerClassPair</li>
</ul>
<p>嘛~ 难点和重点都讲完了，大家结合注释理解其中的逻辑应该没什么困难了，有什么问题可以找我一起交流~</p>
<h3 id="Hook-的实现"><a href="#Hook-的实现" class="headerlink" title="Hook 的实现"></a>Hook 的实现</h3><p>在上面 <code>aspect_hookClass</code> 方法中，不仅仅是返回一个要 Hook 的 Class，期间还做了一些细节操作，不论是 Class 还是 Instance，都会调用 <code>aspect_swizzleForwardInvocation</code> 方法，这个方法没什么难点，简单贴一下代码让大家有个印象：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> aspect_swizzleForwardInvocation(Class klass) &#123;</span><br><span class="line">    <span class="comment">// 断言 klass</span></span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(klass);</span><br><span class="line">    <span class="comment">// 如果没有 method，replace 实际上会像是 class_addMethod 一样</span></span><br><span class="line">    IMP originalImplementation = class_replaceMethod(klass, <span class="keyword">@selector</span>(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    <span class="comment">// 拿到 originalImplementation 证明是 replace 而不是 add，情况少见</span></span><br><span class="line">    <span class="keyword">if</span> (originalImplementation) &#123;</span><br><span class="line">        <span class="comment">// 添加 AspectsForwardInvocationSelectorName 的方法，IMP 为原生 forwardInvocation:</span></span><br><span class="line">        class_addMethod(klass, <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName), originalImplementation, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    AspectLog(<span class="string">@&quot;Aspects: %@ is now aspect aware.&quot;</span>, <span class="built_in">NSStringFromClass</span>(klass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法就是把要 Hook 的目标 Class 的 <code>forwardInvocation:</code> 混写了，混写之后 <code>forwardInvocation:</code> 的具体实现在 <code>__ASPECTS_ARE_BEING_CALLED__</code> 中，里面能看到 invoke 标识位的不同是如何实现的，还有一些其他的实现细节：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏定义，以便于我们有一个更明晰的 stack trace</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aspect_invoke(aspects, info) \</span></span><br><span class="line"><span class="meta">for (AspectIdentifier *aspect in aspects) &#123;\</span></span><br><span class="line"><span class="meta">    [aspect invokeWithInfo:info];\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \</span></span><br><span class="line"><span class="meta">        aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \</span></span><br><span class="line"><span class="meta">    &#125; \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> __ASPECTS_ARE_BEING_CALLED__(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSObject</span> *<span class="keyword">self</span>, SEL selector, <span class="built_in">NSInvocation</span> *invocation) &#123;</span><br><span class="line">    <span class="comment">// __unsafe_unretained NSObject *self 不解释了</span></span><br><span class="line">    <span class="comment">// 断言 self, invocation</span></span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(invocation);</span><br><span class="line">    <span class="comment">// 从 invocation 可以拿到很多东西，比如 originalSelector</span></span><br><span class="line">    SEL originalSelector = invocation.selector;</span><br><span class="line">    <span class="comment">// originalSelector 加前缀得到 aliasSelector</span></span><br><span class="line">    SEL aliasSelector = aspect_aliasForSelector(invocation.selector);</span><br><span class="line">    <span class="comment">// 用 aliasSelector 替换 invocation.selector</span></span><br><span class="line">    invocation.selector = aliasSelector;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Instance 的容器</span></span><br><span class="line">    AspectsContainer *objectContainer = objc_getAssociatedObject(<span class="keyword">self</span>, aliasSelector);</span><br><span class="line">    <span class="comment">// Class 的容器</span></span><br><span class="line">    AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(<span class="keyword">self</span>), aliasSelector);</span><br><span class="line">    AspectInfo *info = [[AspectInfo alloc] initWithInstance:<span class="keyword">self</span> invocation:invocation];</span><br><span class="line">    <span class="built_in">NSArray</span> *aspectsToRemove = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.beforeAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.beforeAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instead hooks.</span></span><br><span class="line">    <span class="type">BOOL</span> respondsToAlias = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123;</span><br><span class="line">        <span class="comment">// 如果有任何 insteadAspects 就直接替换了</span></span><br><span class="line">        aspect_invoke(classContainer.insteadAspects, info);</span><br><span class="line">        aspect_invoke(objectContainer.insteadAspects, info);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">// 否则正常执行</span></span><br><span class="line">        <span class="comment">// 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke</span></span><br><span class="line">        Class klass = object_getClass(invocation.target);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123;</span><br><span class="line">                [invocation invoke];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After hooks.</span></span><br><span class="line">    aspect_invoke(classContainer.afterAspects, info);</span><br><span class="line">    aspect_invoke(objectContainer.afterAspects, info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有 hook，则执行原始实现（通常会抛出异常）</span></span><br><span class="line">    <span class="keyword">if</span> (!respondsToAlias) &#123;</span><br><span class="line">        invocation.selector = originalSelector;</span><br><span class="line">        SEL originalForwardInvocationSEL = <span class="built_in">NSSelectorFromString</span>(AspectsForwardInvocationSelectorName);</span><br><span class="line">        <span class="comment">// 如果可以响应 originalForwardInvocationSEL，表示之前是 replace method 而非 add method</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:originalForwardInvocationSEL]) &#123;</span><br><span class="line">            ((<span class="type">void</span>( *)(<span class="type">id</span>, SEL, <span class="built_in">NSInvocation</span> *))objc_msgSend)(<span class="keyword">self</span>, originalForwardInvocationSEL, invocation);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span> doesNotRecognizeSelector:invocation.selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除 aspectsToRemove 队列中的 AspectIdentifier，执行 remove</span></span><br><span class="line">    [aspectsToRemove makeObjectsPerformSelector:<span class="keyword">@selector</span>(remove)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> aspect_invoke</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>aspect_invoke</code> 宏定义的作用域。</p>
</blockquote>
<ul>
<li>代码实现对应了 Hook 的 AspectOptions 参数的 Before，Instead 和 After。</li>
<li><code>aspect_invoke</code> 中 <code>aspectsToRemove</code> 是一个 NSArray，里面容纳着需要被销户的 Hook，即 AspectIdentifier（之后会调用 <code>remove</code> 移除）。</li>
<li>遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke 实现代码。</li>
</ul>
<h3 id="Block-Hook"><a href="#Block-Hook" class="headerlink" title="Block Hook"></a>Block Hook</h3><p>Aspects 让我们在指定 Class 或 Instance 的特定 Selector 执行时，根据 AspectOptions 插入我们自己的 Block 做 Hook，而这个 Block 内部有我们想要的有关于当前 Target 和 Selector 的信息，我们来看一下 Aspects 是怎么办到的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)invokeWithInfo:(<span class="type">id</span>&lt;AspectInfo&gt;)info &#123;</span><br><span class="line">    <span class="built_in">NSInvocation</span> *blockInvocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:<span class="keyword">self</span>.blockSignature];</span><br><span class="line">    <span class="built_in">NSInvocation</span> *originalInvocation = info.originalInvocation;</span><br><span class="line">    <span class="built_in">NSUInteger</span> numberOfArguments = <span class="keyword">self</span>.blockSignature.numberOfArguments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 偏执。我们已经在 hook 注册的时候检查过了，（不过这里我们还要检查）。</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123;</span><br><span class="line">        AspectLogError(<span class="string">@&quot;Block has too many arguments. Not calling %@&quot;</span>, info);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block 的 `self` 将会是 AspectInfo。可选的。</span></span><br><span class="line">    <span class="keyword">if</span> (numberOfArguments &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        [blockInvocation setArgument:&amp;info atIndex:<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 简历参数分配内存 argBuf 然后从 originalInvocation 取 argument 赋值给 blockInvocation</span></span><br><span class="line">    <span class="type">void</span> *argBuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> idx = <span class="number">2</span>; idx &lt; numberOfArguments; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="type">char</span> *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];</span><br><span class="line">		<span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">		<span class="built_in">NSGetSizeAndAlignment</span>(type, &amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// reallocf 优点，如果创建内存失败会自动释放之前的内存，讲究</span></span><br><span class="line">		<span class="keyword">if</span> (!(argBuf = reallocf(argBuf, argSize))) &#123;</span><br><span class="line">            AspectLogError(<span class="string">@&quot;Failed to allocate memory for block invocation.&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		[originalInvocation getArgument:argBuf atIndex:idx];</span><br><span class="line">		[blockInvocation setArgument:argBuf atIndex:idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行</span></span><br><span class="line">    [blockInvocation invokeWithTarget:<span class="keyword">self</span>.block];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放 argBuf</span></span><br><span class="line">    <span class="keyword">if</span> (argBuf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        free(argBuf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑两个问题：</p>
<ul>
<li><code>[blockInvocation setArgument:&amp;info atIndex:1];</code> 为什么要在索引 1 处插入呢？</li>
<li><code>for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++)</code> 为什么要从索引 2 开始遍历参数呢？</li>
</ul>
<p>嘛~ 如果你对 Block 的 Runtime 结构以及执行过程下断点研究一下就全都明白了，感兴趣的同学有疑问可以联系我（与真正勤奋好学的人交流又有谁会不乐意呢？笑~）</p>
<h2 id="优秀-AOP-库应该具备的特质"><a href="#优秀-AOP-库应该具备的特质" class="headerlink" title="优秀 AOP 库应该具备的特质"></a>优秀 AOP 库应该具备的特质</h2><img src="/aspects/aspects_rank.jpg" class="">
<ul>
<li>良好的使用体验</li>
<li>可控粒度小</li>
<li>使用 Block 做 Hook</li>
<li>支持撤销 Hook</li>
<li>安全性</li>
</ul>
<h3 id="良好的使用体验"><a href="#良好的使用体验" class="headerlink" title="良好的使用体验"></a>良好的使用体验</h3><p>Aspects 使用 NSObject + Categroy 的方式提供接口，非常巧妙的涵盖了 Instance 和 Class。</p>
<p>Aspects 提供的接口保持高度一致（本着<strong>易用，简单，方便</strong>的原则设计接口和整个框架的实现会让你的开源项目更容易被人们接纳和使用）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(<span class="type">id</span>)block</span><br><span class="line">                            error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                      withOptions:(AspectOptions)options</span><br><span class="line">                       usingBlock:(<span class="type">id</span>)block</span><br><span class="line">                            error:(<span class="built_in">NSError</span> **)error;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实接口这里对于 <code>block</code> 的参数自动补全可以更进一步，不过 Aspects 当初是没有办法做到的，单从接口设计这块已经很优秀了。</p>
</blockquote>
<h3 id="可控粒度小"><a href="#可控粒度小" class="headerlink" title="可控粒度小"></a>可控粒度小</h3><p>Aspects 不仅支持大部分 AOP 框架应该做到的对于 Class 的 Hook，还支持粒度更小的 Instance Hook，而其在内部实现中为了支持 Instance Hook 所做的代码也非常值得我们参考和学习（已在上文 <strong>Aspects 核心代码剖析</strong> 处单独分析）。</p>
<p>为使用者提供更为自由的 Hook 方式以达到更加精准的控制是每个使用者乐于见到的事。</p>
<h3 id="使用-Block-做-Hook"><a href="#使用-Block-做-Hook" class="headerlink" title="使用 Block 做 Hook"></a>使用 Block 做 Hook</h3><p>Aspects 使用 Block 来做 Hook 应该考虑到了很多东西，支持使用者通过在 Block 中获取到相关的信息，书写自己额外的操作就可以实现 Hook 需求。</p>
<h3 id="支持撤销-Hook"><a href="#支持撤销-Hook" class="headerlink" title="支持撤销 Hook"></a>支持撤销 Hook</h3><p>Aspects 还支持撤销之前做的 Hook 以及已混写的 Method，为了实现这个功能 Aspects 设计了全局容器，把 Hook 和混写用全局容器做记录，让一切都可以复原，这不正是我们想要的吗？</p>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>嘛~ 我们在学习 Runtime 的时候，就应该看到过不少文章讲解 Method Swizzling 要注意的安全性问题，由于用到了大量 Runtime 方法，加上 AOP 是面向整个切面的，所以一单发现问题就会比较严重，涉及的面会比较广，而且难以调试。</p>
<blockquote>
<p>Note: 我们不能因为容易造成问题就可以回避 Method Swizzling，就好比大学老师讲到递归时强调容易引起循环调用，很多人就在内心回避使用递归，甚至于非常适合使用递归来写的算法题（这里指递归来写会易读写、易维护）只会用复杂的方式来思考。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章简单介绍了 AOP 的概念，希望能给各位读者对 AOP 思想的理解提供微薄的帮助。</li>
<li>文章系统的剖析了 Aspects 开源库的内部结构，希望能让大家在浏览 Aspects 源码时快速定位代码位置，找到核心内容。</li>
<li>文章重点分析了 Aspects 的核心代码，提炼了一些笔者认为值得注意的点，但愿可以在大家扒源码时提供一些指引。</li>
<li>文章结尾总结了 Aspects 作为一个比较优秀的 AOP 所具备的一些特质。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/aop/" rel="tag">aop</a><a class="tag-none-link" href="/tags/hook/" rel="tag">hook</a>
	  </div>
    

  </section>
</article>
  
</section>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
