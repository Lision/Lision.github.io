<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2018/6 | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/archives/2018/06/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	


	<section class="page-header archive">
    <h1>- <span>2018.6</span> -</h1>
  </section>




<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/wwdc18_llvm/">
      WWDC18 What’s New in LLVM
    </a>
  </h2>
  
  <time>
    6月 24, 2018
  </time>
  <section class="content">
	  <img src="/wwdc18_llvm/wwdc18.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM</a> 作为 Apple 御用的编译基础设施其重要性不言而喻，Apple 从未停止对 LLVM 的维护和更新，并且几乎在每年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/">WWDC</a> 中都有专门的 Session 来针对 LLVM 的新特性做介绍和讲解，刚刚过去的 WWDC18 也不例外。</p>
<p>WWDC18 Session 409 What’s New in LLVM 中 Apple 的工程师们又为我们介绍了 LLVM 最新的特性，这篇文章将会结合 WWDC18 Session 409 给出的 <a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/409t8zw7rumablsh/409/409_whats_new_in_llvm.pdf?dl=1">官方演示文稿</a> 分享一下 LLVM 的新特性并谈谈笔者自己个人对这些特性的拙见。</p>
<blockquote>
<p>Note: 本文不会对官方演示文稿做逐字逐句的翻译工作，亦不会去过多介绍 LLVM 的基本常识。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>ARC 更新</li>
<li>Xcode 10 新增诊断</li>
<li>Clang 静态分析</li>
<li>增加安全性</li>
<li>新指令集扩展</li>
<li>总结</li>
</ul>
<h2 id="ARC-更新"><a href="#ARC-更新" class="headerlink" title="ARC 更新"></a>ARC 更新</h2><p>本次 ARC 更新的亮点在于 C struct 中允许使用 ARC Objective-C 对象。</p>
<p>在之前版本的 Xcode 中尝试在 C struct 的定义中使用 Obj—C 对象，编译器会抛出 <strong>Error: ARC forbids Objective-C objects in struct</strong>，如下图所示：</p>
<img src="/wwdc18_llvm/arc_00.png" class="">
<p>嘛~ 这是因为之前 LLVM 不支持，如果在 Xcode 10 中书写同样的代码则不会有任何 Warning 与 Error：</p>
<img src="/wwdc18_llvm/arc_01.png" class="">
<p>那么直接在 C struct 中使用 Objective-C 对象的话难道就没有内存上的问题吗？Objective-C 所占用的内存空间是何时被销毁的呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC Object Pointers in C Structs!</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> orderFreeFood(<span class="built_in">NSString</span> *name) &#123;	MenuItem item = &#123;		name,		[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>]	&#125;;	<span class="comment">// [item.name retain];</span>	<span class="comment">// [item.price retain];</span>	orderMenuItem(item);	<span class="comment">// [item.name release]; </span></span><br><span class="line">	<span class="comment">// [item.price release];</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，编译器会在 C struct <code>MenuItem</code> 创建后 <code>retain</code> 其中的 ARC Objective-C 对象，并在 <code>orderMenuItem(item);</code> 语句之后，即其他使用 <code>MenuItem item</code> 的函数调用结束之后 <code>release</code> 掉相关 ARC Objective-C 对象。</p>
<p>思考，在<strong>动态内存管理</strong>时，ARC Objective-C 对象的内存管理会有什么不同呢？ </p>
<blockquote>
<p>Note: 动态内存管理（Dynamic Memory Management），指非 <code>int a[100];</code> 或 <code>MenuItem item = &#123;name, [NSNumber numberWithInt:0]&#125;;</code> 这种在决定了使用哪一存储结构之后，就自动决定了作用域和存储时期的代码，这种代码必须服从预先制定的内存管理规则。</p>
</blockquote>
<p>我们知道 C 语言中如果想要灵活的创建一个动态大小的数组需要自己手动开辟、管理、释放相关的内存，示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="type">double</span> *ptd;</span><br><span class="line">	    </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;What is the maximum number of type double entries?&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">	ptd = <span class="built_in">malloc</span>(max * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="keyword">if</span> (ptd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// memory allocation failed</span></span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// some logic</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(ptd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 C struct 中 ARC Objective-C 的动态内存管理是否应该这么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = malloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>答案是<strong>否定</strong>的！</p>
<img src="/wwdc18_llvm/arc_02.png" class="">
<p>可以看到通过 <code>malloc</code> 开辟内存初始化带有 ARC Objective-C 的 C struct 中 ARC Objective-C 指针不会 <code>zero-initialized</code>。</p>
<p>嘛~ 这个时候自然而然的会想起使用 <code>calloc</code> ^_^ </p>
<blockquote>
<p>Note: <code>calloc</code> 和 <code>malloc</code> 均可完成内存分配，不同之处在于 <code>calloc</code> 会将分配过来的内存块中全部位置都置 0（然而要注意，在某些硬件系统中，浮点值 0 不是全部位为 0 来表示的）。</p>
</blockquote>
<p>另一个问题就是 <code>free(items);</code> 语句执行之前，ARC Objective-C 并没有被清理。</p>
<p>Emmmmm… 官方推荐的写法是在 <code>free(items);</code> 之前将 <code>items</code> 内的所有 struct 中使用到的 ARC Objective-C 指针手动职位 <code>nil</code> …</p>
<p>所以在<strong>动态内存管理</strong>时，上面的代码应该这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = calloc(<span class="number">10</span>, <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	<span class="comment">// ARC Object Pointer Fields Must be Cleared Before Deallocation</span>	<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;		items[i].name = <span class="literal">nil</span>;		items[i].price = <span class="literal">nil</span>;	&#125;	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间有种<strong>日了狗</strong>的感觉有木有？</p>
<h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 在 C struct 中增加对 ARC Objective-C 对象字段的支持意味着我们<strong>今后 Objective-C 可以构建跨语言模式的交互操作</strong>。</p>
<blockquote>
<p>Note: 官方声明为了统一 ARC 与 manual retain/release (MRR) 下部分 function 按值传递、返回 struct 对 Objective-C++ ABI 做出了些许调整。 </p>
</blockquote>
<p>值得一提的是 Swift <strong>并不支持</strong>这一特性（2333~ 谁说 Objective-C 的更新都是为了迎合 Swift 的变化）。</p>
<h2 id="Xcode-10-新增诊断"><a href="#Xcode-10-新增诊断" class="headerlink" title="Xcode 10 新增诊断"></a>Xcode 10 新增诊断</h2><h3 id="Swift-与-Objective-C-互通性"><a href="#Swift-与-Objective-C-互通性" class="headerlink" title="Swift 与 Objective-C 互通性"></a>Swift 与 Objective-C 互通性</h3><p>我们都知道 Swift 与 Objective-C 具有一定程度的互通性，即 Swift 与 Objective-C 可以混编，在混编时 Xcode 生成一个头文件将 Swift 可以转化为 Objective-C 的部分接口暴露出来。</p>
<p>不过由于 Swift 与 Objective-C 的兼容性导致用 Swift 实现的部分代码无法转换给 Objective-C 使用。</p>
<p>近些年来 LLVM 一致都在尝试让这两种语言可以更好的互通（这也就是上文中提到 Objective-C 的更新都是为了迎合 Swift 说法的由来），本次 LLVM 支持<strong>将 Swift 中的闭包（Closures）导入 Objective-C</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">performOperation</span>(<span class="params">handler</span>: () -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import “Executor-Swift.h”</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)performOperation:(<span class="type">void</span> (^)(<span class="type">void</span>))handler; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 Swift 中闭包默认都是非逃逸闭包（non-escaping closures），即闭包不应该在函数返回之后执行。</p>
</blockquote>
<p>Objective-C 中与 Swift 闭包对应的就是 Block 了，但是 Objective-C 中的 Block 并没有诸如 Swift 中逃逸与否的限制，那么我们这样将 Swift 的非逃逸闭包转为 Objective-C 中无限制的 Block 岂不是会有问题？</p>
<img src="/wwdc18_llvm/interoperability.png" class="">
<p>别担心，转换过来的闭包（非逃逸）会有 Warnning 提示，而且我们说过一般这种情况下 Apple 的工程师都会在 LLVM 为 Objective-C 加一个宏来迎合 Swift…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning for Missing Noescape Annotations for Method Overrides</span><span class="meta">#import “Executor-Swift.h”</span><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler;<span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">DispatchExecutor</span></span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler &#123;&#125;</span><br><span class="line"><span class="comment">// Programmer must ensure that handler is not called after performOperation returns</span><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="个人观点-1"><a href="#个人观点-1" class="headerlink" title="个人观点"></a>个人观点</h4><p>如果 Swift 5 真的可以做到 ABI 稳定，那么 Swift 与 Objective-C 混编的 App 包大小也应该回归正常，相信很多公司的项目都会慢慢从 Objective-C 转向 Swift。在 Swift 中闭包（Closures）作为一等公民的存在奠定了 Swift 作为函数式语言的根基，本次 LLVM 提供了将 Swift 中的 Closures 与 Objective-C 中的 Block 互通转换的支持无疑是很有必要的。</p>
<h3 id="使用-pragma-pack-打包-Struct-成员"><a href="#使用-pragma-pack-打包-Struct-成员" class="headerlink" title="使用 #pragma pack 打包 Struct 成员"></a>使用 <code>#pragma pack</code> 打包 Struct 成员</h3><p>Emmmmm… 老实说这一节的内容更底层，所以可能会比较晦涩，希望自己可以表述清楚吧。在 C 语言中 struct 有 <strong>内存布局（memory layout）</strong> 的概念，C 语言允许编译器为每个基本类型指定一些<strong>对齐方式</strong>，通常情况下是以类型的大小为标准对齐，但是它是<strong>特定于实现</strong>的。</p>
<p>嘛~ 还是举个例子吧，就拿 WWDC18 官方演示文稿中的吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> &#123;</span> </span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="comment">// 2 byte padding </span></span><br><span class="line">	<span class="type">uint32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，编译器为了对齐内存布局不得不在 <code>Struct</code> 的第二字段与第三字段之间插入 2 个 byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p><strong>这样本该占用 6 byte 的 struct 就占用了 8 byte，尽管其中只有 6 byte 的数据。</strong></p>
<p>C 语言允许每个远程现代编译器实现 <code>#pragma pack</code>，它允许程序猿对填充进行控制来依从 ABI。</p>
<blockquote>
<p>From C99 §6.7.2.1: </p>
<p>12 Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type.</p>
<p>13 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
</blockquote>
<p>实际上关于 <code>#pragma pack</code> 的相关信息可以在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/preprocessor/pack">MSDN page</a> 中找到。</p>
<p>LLVM 本次也加入了对 <code>#pragma pack</code> 的支持，使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (push, 1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PackedStruct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="type">uint32_t</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (pop)</span></span><br></pre></td></tr></table></figure>
<p>经过 <code>#pragma pack</code> 之后我们的 struct 对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   1   |</span><br><span class="line">|   a   | </span><br><span class="line">|   b   |</span><br><span class="line">|  c(1) |</span><br><span class="line">|  c(2) |</span><br><span class="line">|  c(3) |</span><br><span class="line">|  c(4) |</span><br></pre></td></tr></table></figure>
<p>其实 <code>#pragma pack (push, 1)</code> 中的 <code>1</code> 就是对齐字节数，如果设置为 <code>4</code> 那么对齐方式又会变回到最初的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p>值得一提的是，如果你使用了 <code>#pragma pack (push, n)</code> 之后忘记写 <code>#pragma pack (pop)</code> 的话，Xcode 10 会抛出 warning：</p>
<img src="/wwdc18_llvm/pack.png" class="">
<h4 id="个人观点-2"><a href="#个人观点-2" class="headerlink" title="个人观点"></a>个人观点</h4><p>嘛~ 当在网络层面传输 struct 时，通过 <code>#pragma pack</code> 自定义内存布局的对齐方式可以为用户节约更多流量。</p>
<h2 id="Clang-静态分析"><a href="#Clang-静态分析" class="headerlink" title="Clang 静态分析"></a>Clang 静态分析</h2><p>Xcode 一直都提供静态分析器（Static Analyzer），使用 Clang Static Analyzer 可以帮助我们找出边界情况以及难以发觉的 Bug。</p>
<img src="/wwdc18_llvm/static_analyzer_00.jpg" class="">
<p>点击 Product -&gt; Analyze 或者使用快捷键 Shift+Command+B 就可以静态分析当前构建的项目了，当然也可以在项目的 Build Settings 中设置构建项目时自动执行静态分析（个人不推荐）：</p>
<img src="/wwdc18_llvm/static_analyzer_01.jpg" class="">
<p>本地静态分析器有以下提升：</p>
<ul>
<li>GCD 性能反模式</li>
<li>自动释放变量超出自动释放池</li>
<li>性能和可视化报告的提升</li>
</ul>
<h3 id="GCD-性能反模式"><a href="#GCD-性能反模式" class="headerlink" title="GCD 性能反模式"></a>GCD 性能反模式</h3><p>在之前某些迫不得已的情况下，我们可能需要使用 GCD 信号（<code>dispatch_semaphore_t</code>）来阻塞某些异步操作，并将阻塞后得到的最终的结果同步返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task;</span><br><span class="line">	dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这样写有什么问题呢？</p>
<p>上述代码存在通过使用异步线程执行任务来阻塞当前线程，而 Task 队列通常优先级较低，所以会导致<strong>优先级反转</strong>。</p>
<p>那么 Xcode 10 之后我们应该怎么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line"><span class="type">id</span> remoteObjectProxy = [<span class="keyword">self</span>.connection synchronousRemoteObjectProxyWithErrorHandler:</span><br><span class="line">	^(<span class="built_in">NSError</span> *error) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %@&quot;</span>, error); &#125;];</span><br><span class="line">[remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>如果可能的话，尽量使用 <code>synchronous</code> 版本的 API。或者，使用 <code>asynchronous</code> 方式的 API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123; </span><br><span class="line">	completionHandler(task);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可以在 build settings 下启用 GCD 性能反模式的静态分析检查：</p>
<img src="/wwdc18_llvm/static_analyzer_gcd_00.png" class="">
<h3 id="自动释放变量超出自动释放池"><a href="#自动释放变量超出自动释放池" class="headerlink" title="自动释放变量超出自动释放池"></a>自动释放变量超出自动释放池</h3><p>众所周知，使用 <code>__autoreleasing</code> 修饰符修饰的变量会在自动释放池离开时被释放（release）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	__autoreleasing <span class="built_in">NSError</span> *err = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种看似不需要我们注意的点往往就是引起程序 Crash 的隐患：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123; </span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				*error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嘛~ 上述代码是会引起 Crash 的，你可以指出为什么吗？</p>
<p>Objective-C 在 ARC（Automatic Reference Counting）下会隐式使用 <code>__autoreleasing</code> 修饰 <code>error</code>，即 <code>NSError *__autoreleasing*</code>。而 <code>-enumerateObjectsUsingBlock:</code> 内部会在迭代 <code>block</code> 时使用 <code>@autoreleasepool</code>，在迭代逻辑中这样做有助于减少内存峰值。</p>
<p>于是 <code>*error</code> 在 <code>-enumerateObjectsUsingBlock:</code> 中被提前 release 掉了，这样在随后读取 <code>*error</code> 时会出现 crash。</p>
<p>Xcode 10 中会给出具有针对性的静态分析警告：</p>
<img src="/wwdc18_llvm/static_analyzer_autoreleasing_00.png" class="">
<p>正确的书写方式应该是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> *__autoreleasing*)error &#123; </span><br><span class="line">	__block <span class="built_in">NSError</span> *localError;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123;</span><br><span class="line">			localError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;];</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		*error = localError;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实早在去年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/411/">WWDC17 Session 411 What’s New in LLVM</a> 中 Xcode 9 就引入了一个需要显示书写 <code>__autoreleasing</code> 的警告。</p>
</blockquote>
<h3 id="性能和可视化报告的提升"><a href="#性能和可视化报告的提升" class="headerlink" title="性能和可视化报告的提升"></a>性能和可视化报告的提升</h3><p>Xcode 10 中静态分析器可以以更高效的方式工作，在相同的分析时间内平均可以发现比之前增加 15% 的 Bug 数量。</p>
<p>不仅仅是性能的提升，Xcode 10 在报告的可视化方面也有所进步。在 Xcode 9 的静态分析器报告页面有着非必要且冗长的 Error Path：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_9.jpg" class="">
<p>Xcode 10 中则对其进行了优化：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_10.jpg" class="">
<h3 id="个人观点-3"><a href="#个人观点-3" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 对于 Xcode 的静态分析，个人认为还是聊胜于无的。不过不建议每次构建项目时都去做静态分析，这样大大增加了构建项目的成本。</p>
<p>个人建议在开发流程中自测完毕提交代码给组内小伙伴们 Code Review 之前做静态分析，可以避免一些 issue 的出现，也可以发现一些代码隐患。有些问题是可以使用静态分析器在提交代码之前就暴露出来的，没必要消耗组内 Code Review 的宝贵人力资源。</p>
<p>还可以在 CI 设置每隔固定是时间间隔去跑一次静态分析，生成报表发到组内小群，根据问题指派责任人去检查是否需要修复（静态分析在比较复杂的代码结构下并不一定准确），这样定期维护从某种角度讲可以保持项目代码的健康状况。</p>
<h2 id="增加安全性"><a href="#增加安全性" class="headerlink" title="增加安全性"></a>增加安全性</h2><h3 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h3><p>Apple 工程师在介绍 Stack Protector 之前很贴心的带领着在场的开发者们复习了一遍栈 Stack 相关的基础知识：</p>
<img src="/wwdc18_llvm/stack_protector_00.png" class="">
<p>如上图，其实就是简单的讲了一下 Stack 的工作方式，如栈帧结构以及函数调用时栈的展开等。每一级的方法调用，都对应了一张相关的活动记录，也被称为<strong>活动帧</strong>。函数的调用栈是由一张张帧结构组成的，所以也称之为<strong>栈帧</strong>。</p>
<p>我们可以看到，栈帧中包含着 <strong>Return Address</strong>，也就是当前活动记录执行结束后要返回的地址。</p>
<p>那么会有什么安全性问题呢？Apple 工程师接着介绍了通过不正当手段修改栈帧 Return Address 从而实现的一些权限提升。嘛~ 也就是历史悠久的 <a target="_blank" rel="noopener" href="http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf">缓冲区溢出攻击</a>。</p>
<img src="/wwdc18_llvm/stack_protector_01.png" class="">
<p>当使用 C 语言中一些不太安全的函数时（比如上图的 <code>strcpy()</code>），就有可能造成缓冲区溢出。</p>
<blockquote>
<p>Note: <code>strcpy()</code> 函数将源字符串复制到指定缓冲区中。但是丫没有指定要复制字符的具体数目！如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会造成<strong>缓冲区溢出</strong>！</p>
</blockquote>
<p>针对缓冲区溢出攻击，LLVM 引入了一块额外的区域（下图绿色区域）来作为栈帧 Return Address 的<strong>护城河</strong>，叫做 Stack Canary，已默认启用：</p>
<img src="/wwdc18_llvm/stack_protector_02.png" class="">
<blockquote>
<p>Note: Canary 译为 “金丝雀”，Stack Canary 的命名源于早期煤矿工人下矿坑时会携带金丝雀来检测矿坑内一氧化碳是否达到危险值，从而判断是否需要逃生。</p>
</blockquote>
<p>根据我们上面对缓冲区溢出攻击的原理分析，大家应该很容易发现 Stack Canary 的防御原理，即缓冲区溢出攻击旨在利用缓冲区溢出来篡改栈帧的 Return Address，加入了 Stack Canary 之后想要篡改 Return Address 就必然会经过 Stack Canary，在当前栈帧执行结束后要使用 Return Address 回溯时先检测 Stack Canary 是否有变动，如果有就调用 <code>abort()</code> 强制退出。</p>
<p>嘛~ 是不是和矿坑中的金丝雀很像呢？</p>
<p>不过 Stack Canary 存在一些局限性：</p>
<ul>
<li>可以在缓冲区溢出攻击时计算 Canary 的区域并伪装 Canary 区域的值，使得 Return Address 被篡改的同时 Canary 区域内容无变化，绕过检测。</li>
<li>再粗暴一点的话，可以通过双重 <code>strcpy()</code> 覆写任意不受内存保护的数据，通过构建合适的溢出字符串，可以达到修改 ELF（Executable and Linking Format）映射的 GOT（Global Offset Table），只要修改了 GOT 中的 <code>_exit()</code> 入口，即便 Canary 检测到了篡改，函数返回前调用 <code>abort()</code> 退出还是会走已经被篡改了的 <code>_exit()</code>。</li>
</ul>
<h3 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h3><p>Stack Protector 是 Xcode 既有的、且默认开启的特性，而 Stack Checking 是 Xcode 10 引入的新特性，主要针对的是 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">Stack Clash</a> 问题。</p>
<img src="/wwdc18_llvm/stack_checking_00.png" class="">
<p>Stack Clash 问题的产生源于 Stack 和 Heap，Stack 是<strong>从上向下</strong>增长的，Heap 则是<strong>自下而上</strong>增长的，两者相向扩展而内存又是有限的。</p>
<p>Stack Checking 的工作原理是在 Stack 区域规定合理的分界线（上图红线），在可变长度缓冲区的函数内部对将要分配的缓冲区大小做校验，如果缓冲区超出分界线则调用 <code>abort()</code> 强制退出。</p>
<blockquote>
<p>Note: LLVM 团队在本次 WWDC18 加入 Stack Checking，大概率是因为去年年中 <a target="_blank" rel="noopener" href="https://www.qualys.com/">Qualys</a> 公布的一份 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">关于 Stack Clash 的报告</a>。</p>
</blockquote>
<h2 id="新指令集扩展"><a href="#新指令集扩展" class="headerlink" title="新指令集扩展"></a>新指令集扩展</h2><img src="/wwdc18_llvm/new_instruction_set_extensions.png" class="">
<p>Emmmmm… 这一节的内容是针对于 iMac Pro 以及 iPhone X 使用的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instruction_set_architecture">指令集架构（ISA - Instruction set architecture）</a> 所做的扩展。坦白说，我对这块并不是很感兴趣，也没有深入的研究，所以就不献丑了…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 WWDC18 Session 409 What’s New in LLVM 中的内容，并分享了我个人对这些内容的拙见，希望能够对各位因为种种原因还没有来得及看 WWDC18 Session 409 的同学有所帮助。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/sony_wh_h900n/">
      Sony WH-H900N 开箱留念
    </a>
  </h2>
  
  <time>
    6月 9, 2018
  </time>
  <section class="content">
	  <img src="/sony_wh_h900n/sony_wh_h900n_00.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>嘛~ 又是一年高考季，每到这个时候我就知道我又长了一岁… </p>
<p>Emmmmm… 最近似乎陷入了创作低谷，已经很久没有更新过博客了，原因嘛… 有很多：</p>
<ul>
<li>一方面是入职之后需要适应新的环境，包括新的团队，新的流程… 从这一点来看人类果然是弱鸡动物，会受到外界环境的变化以及心情等内在因素的影响，至少机器人不会被这些东西困扰吧…</li>
<li>另一方面是不知道应该写什么，或者说自己在这段与新团队的磨合期中眼界提升了很多，很多之前计划去写的文章现在突然没有兴趣了，以前也有过类似的经历… 唯有告诫自己戒掉拖延症，不要错过当前这段时期自己想做的事情哈~</li>
</ul>
<p>另外一个最重要原因就是——<strong>真的没时间</strong>。</p>
<p>自己也想过为什么会这样，除去磨合期种种不熟悉导致的时效问题，还剩下一些客观存在的因素，其中就有办公环境的影响，现在的办公环境比较开放（装修风格和网吧类似 &gt;_&lt;），所以每天都会有 QA 小姐姐们测试订单的声音，PM 小哥哥们撕逼的声音，RD 小伙伴们敲击键盘的声音… 这几种声音在不同的音频攻击着我幼小的心脏和脆弱的神经，影响着我敲代码时的专注程度…</p>
<p>然后可能之前下班回到家后有和我女票抱怨过吧… 结果过生日就收到了这篇文章的主角—— Sony WH-H900N。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Sony WH-H900N</li>
<li>入手渠道</li>
<li>开箱照</li>
<li>上头体验</li>
<li>总结</li>
</ul>
<h2 id="Sony-WH-H900N"><a href="#Sony-WH-H900N" class="headerlink" title="Sony WH-H900N"></a>Sony WH-H900N</h2><img src="/sony_wh_h900n/sony_wh_h900n_01.jpg" class="">
<p>Sony WH-H900N 全称 Sony | h.ear on 2 Wireless NC | WH-H900N，是大法旗下的 h.ear on 2 系列无线蓝牙降噪耳机。</p>
<p>关键词：</p>
<ul>
<li>佩戴良好</li>
<li>隔音良好</li>
<li>听诊器效应轻微</li>
<li>做工优秀</li>
<li>降噪良好</li>
<li>杂食</li>
</ul>
<p>由于我自己平时什么音乐都听一些，偏 ACG 和 Eason Chen 多一些，加上我自己本身是木耳（木头耳朵，指听不出不同耳机的音质区别）所以一直以来对耳机就只有<strong>无线</strong>和<strong>降噪</strong>两个硬性需求，然后自己没有出街听音乐的习惯（主要是觉得车来车往不太安全），所以想要一款<strong>头戴式</strong>的耳机（在办公室和家里听听就好），然后因为头戴式的耳机比较显眼，所以对<strong>颜值</strong>也有了一定的要求…</p>
<p>刚刚好，这些需求 Sony WH-H900N 统统满足了，再次感恩我的女票，想必花了不少心思吧（笑）</p>
<p>配色方面，这款耳机提供了五种配色可供选择：</p>
<ul>
<li>暮光红（目光红，因为这个颜色真的特别少女，据说出街回头率超高）</li>
<li>月光蓝</li>
<li>薄荷绿</li>
<li>浅金</li>
<li>灰黑</li>
</ul>
<p>这几种颜色都是偏哑光质感的，低调的同时满足了绝大多数消费者的个性化选择，我这款就是月光蓝配色的~</p>
<blockquote>
<p>Note: 鉴于网上各种评测贴和买家秀的晒图中出现了各种颜色的月光蓝，所以我这篇文章的所有配图均无任何滤镜和后期处理，希望能够给想买月光蓝的同学提供一些参考和帮助。</p>
</blockquote>
<p>补充，话说我还在大法的官方商城搜到了 WH-H900N FATE 特别版哟~</p>
<img src="/sony_wh_h900n/sony_wh_h900n_fate.jpg" class="">
<h2 id="开箱照"><a href="#开箱照" class="headerlink" title="开箱照"></a>开箱照</h2><img src="/sony_wh_h900n/package.jpg" class="">
<img src="/sony_wh_h900n/storage_box.jpg" class="">
<img src="/sony_wh_h900n/open_storage_box.jpg" class="">
<img src="/sony_wh_h900n/sony_wh_h900n_01.jpg" class="">
<img src="/sony_wh_h900n/sony_wh_h900n_00.jpg" class="">
<img src="/sony_wh_h900n/all_items.jpg" class="">
<p>箱内物品如下：</p>
<ul>
<li>Sony WH-H900N 耳机本体</li>
<li>耳机线材（手感一般，随耳机本体颜色）</li>
<li>充电线（<strong>黑色</strong>）</li>
<li>收纳袋（手感不错的透气帆布材质收纳袋，内衬柔软材料，随耳机本体颜色）</li>
<li>收纳盒（随耳机本体颜色）</li>
</ul>
<p>需要注意的是只有充电线是黑色的，这也就意味着如果你选择的是暮光红这种偏浅色系的配色，充电的时候会…<strong>非！常！丑！</strong>好在这款耳机有大法的快充黑科技加持（其实不如 Apple 的快充黑科技），在低电量时充电 10 分钟可以听 1 小时左右（说明书有写 &amp; 亲测），另外耳机充满电的续航时间为 28 小时（开启降噪），完全可以在家充好电再带去公司使用。</p>
<h2 id="上头体验"><a href="#上头体验" class="headerlink" title="上头体验"></a>上头体验</h2><img src="/sony_wh_h900n/detail_00.jpg" class="">
<p>Emmmmm… 自认木耳，又是理工男的渣渣文笔，就简单叙述一下自己的主观听感吧~</p>
<h3 id="音质"><a href="#音质" class="headerlink" title="音质"></a>音质</h3><p>音质方面个人认为还不错，这款耳机偏中低音，恰好 Eason Chen 的歌普遍都是中低音男声，所以表现很不错，人声清晰，不会感觉距离耳朵很远，又不会感觉靠的太近，可以说是恰到好处吧~ 另外 ACG 女声的表现也很不错，人声甜美，距离适中，声音有厚度。有的耳机人声表现就很单薄，该怎么形容呢？就是感觉人声是耳机从背景音乐中摘出来突兀的放到耳边的，清楚但是与背景音格格不入，像纸片一样突兀且单薄，一带而过的发声…</p>
<h3 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h3><p>首先，耳机的耳垫做工很不错，足够柔软舒适，扣在耳朵上已经可以降低 10%~20% 的环境噪音了，然后开机并开启降噪模式可以瞬间感觉到 &gt;= 80% 的环境噪音都被屏蔽了，剩下的一些声音基本都是附近的人声，且声音小了很多（开始听音乐时外面减弱过的人声就基本听不到了）~ 低频的杂音类似中央空调出风口的声音则完全被屏蔽，我是中午午休时拆箱第一次试戴的，当时正好没人说话，感觉瞬间沉入海底，整个世界都安静了~ </p>
<blockquote>
<p>Note: Sony WH-H900N 支持手势操控，用右手遮盖右耳机，则会降低正在播放的音乐音量，同时暂时关闭降噪，这样非常人性化的便捷设计可以让你很方便的与同事短暂沟通。</p>
</blockquote>
<h3 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h3><p>大法黑科技将蓝牙传输的速率提升很多，在无线状态下依然尽可能的争取音质体验，个人的感觉是比我之前 Beats solo 2 的音质还要稍好一些~</p>
<h3 id="做工"><a href="#做工" class="headerlink" title="做工"></a>做工</h3><p>这款耳机的头梁做工很厚实，保证了长时间佩戴的舒适度（不过耳垫处由于密封性等原因会比较容易出汗，好在公司和家里都有空调，问题不大），这一点和我之前的 Beats solo 2 形成强烈对比，Beats solo 2 的头梁就薄薄一层，拆开之后发现里面只有一层超薄海绵（日了狗了）。</p>
<p>耳机的触感和它偏哑光的颜色保持一致，形容起来大概就是介于磨砂和光面之间的感觉，耳垫柔软舒适有弹性，大爱 Sony 这种优秀扎实的做工品质！</p>
<img src="/sony_wh_h900n/detail_01.jpg" class="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>嘛~ 总得来说呢… Sony WH-H900N 这款耳机非常适合对<strong>无线 &amp; 降噪</strong>有硬性需求的同学，难能可贵的是其在无线 &amp; 降噪的基础上还保证了<strong>高颜值 &amp; 一定的音质</strong>（反正对于我这种木耳来讲足够了）。</p>
<p>补充，<strong>降噪</strong>耳机真的是提升工效的利器，从某种角度看甚至比键盘来的更加粗暴有效（毕竟不需要磨合期）。</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/headset/" rel="tag">headset</a>
	  </div>
    

  </section>
</article>
  
</section>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
