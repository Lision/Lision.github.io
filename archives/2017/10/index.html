<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2017/10 | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/archives/2017/10/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	


	<section class="page-header archive">
    <h1>- <span>2017.10</span> -</h1>
  </section>




<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/yycache/">
      从 YYCache 源码 Get 到如何设计一个优秀的缓存
    </a>
  </h2>
  
  <time>
    10月 30, 2017
  </time>
  <section class="content">
	  <img src="/yycache/how_to_design_a_good_cache.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中总会用到各种缓存，但是各位有没有考虑过什么样的缓存才能被叫做优秀的缓存，或者说优秀的缓存应该具备哪些特质？</p>
<p><strong>闭上眼睛，想一想如果面试官让你设计一个缓存你会怎么回答？</strong></p>
<p>本文将结合 YYCache 的源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 是一个线程安全的高性能键值缓存（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 是在 2015 年发布到 Github 的，由于其代码质量很高，在短时间内就收获了大量的 Star（目前已经 1w+ Star 了），而且在 iOS 各大社区反响广泛，Google 一下也是漫天赞叹。</p>
<p>YYKit 作者是 <a target="_blank" rel="noopener" href="https://github.com/ibireme">@ibireme</a>，原名郭曜源（猜测 YY 前缀来源于曜源？），是我个人非常喜欢的国人开发者（何止喜欢，简直是迷弟😘）。</p>
<p>YYCache 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加难能可贵的是它的性能还非常高。</p>
<img src="/yycache/performance_yymemorycache.jpg" class="">
<img src="/yycache/performance_yydiskcache.jpg" class="">
<p>我对它的评价是<strong>小而美</strong>，这种小而美的缓存源码对于我们今天的主题太合适不过了（本文中 YYCache 源码版本为 v1.0.4）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYCache 简介</li>
<li>YYMemoryCache 细节剖析</li>
<li>YYDiskCache 细节剖析</li>
<li>优秀的缓存应该具备哪些特质</li>
<li>总结</li>
</ul>
<h2 id="YYCache-简介"><a href="#YYCache-简介" class="headerlink" title="YYCache 简介"></a>YYCache 简介</h2><img src="/yycache/yycache.jpg" class="">
<p>简单把 YYCache 从头到尾撸了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了。</p>
<p>由于代码整体阅读难度不是非常大，本文不会去逐字逐句的解读源码，而是提炼 YYCache 作为一个小而美的缓存实现了哪些缓存该具备的特质，并且分析实现细节。</p>
<p>我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。</p>
<blockquote>
<p>通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的代码我做了简化，只保留了最基本的代码（我认为作者在最初设计 YYCache 雏形时很可能也只是提供了这些基本的接口），其他的接口只是通过调用基本的接口再附加对应处理代码而成。</p>
<blockquote>
<p>Note: 其实源码中作者用了一些技巧性的宏，例如 <code>NS_ASSUME_NONNULL_BEGIN</code> 与 <code>NS_ASSUME_NONNULL_END</code> 来通过编译器层检测入参是否为空并给予警告，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a>。</p>
<p>类似上述的编码技巧还有很多，我并非不想与大家分享我 get 到的这些编码技巧，只是觉得它与本文的主题似乎不太相符。我准备在之后专门写一篇文章来与大家分享我在阅读各大源码库过程中 get 到的编码技巧（感兴趣的话可以 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">关注我</a>）。</p>
</blockquote>
<p>从代码中我们可以看到 YYCache 中持有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，类似于 iOS 原生的字典类接口（增删改查）。</p>
<h2 id="YYMemoryCache-细节剖析"><a href="#YYMemoryCache-细节剖析" class="headerlink" title="YYMemoryCache 细节剖析"></a>YYMemoryCache 细节剖析</h2><img src="/yycache/yymemorycache.jpg" class="">
<p>YYMemoryCache 是一个高速的内存缓存，用于存储键值对。它与 NSDictionary 相反，Key 被保留并且不复制。API 和性能类似于 NSCache，所有方法都是线程安全的。</p>
<p>YYMemoryCache 对象与 NSCache 的不同之处在于：</p>
<ul>
<li>YYMemoryCache 使用 LRU(least-recently-used) 算法来驱逐对象；NSCache 的驱逐方式是非确定性的。</li>
<li>YYMemoryCache 提供 age、cost、count 三种方式控制缓存；NSCache 的控制方式是不精确的。</li>
<li>YYMemoryCache 可以配置为在收到内存警告或者 App 进入后台时自动逐出对象。</li>
</ul>
<blockquote>
<p>Note: YYMemoryCache 中的 <code>Access Methods</code> 消耗时长通常是稳定的 <code>(O(1))</code>。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount; <span class="comment">// 缓存对象总数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost; <span class="comment">// 缓存对象总开销</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 5s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning; <span class="comment">// 是否应该在收到内存警告时删除所有缓存内对象</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground; <span class="comment">// 是否应该在 App 进入后台时删除所有缓存内对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到内存警告时自定义处理缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到 App 进入后台时自定义处理缓存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseOnMainThread; <span class="comment">// 是否在主线程释放对象，默认 NO，有些对象（例如 UIView/CALayer）应该在主线程释放</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseAsynchronously; <span class="comment">// 是否异步释放对象，默认 YES</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)objectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count; <span class="comment">// 用 LRU 算法删除对象，直到 totalCount &lt;= count</span></span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost; <span class="comment">// 用 LRU 算法删除对象，直到 totalCost &lt;= cost</span></span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age; <span class="comment">// 用 LRU 算法删除对象，直到所有到期对象全部被删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYMemoryCache 的定义代码比较简单~ 该有的注释我已经加到了上面，这里 LRU 算法的实现我准备单独拎出来放到后面和（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）一起讲。我们这里只需要再关注一下 YYMemoryCache 是如何做到线程安全的。</p>
<h3 id="YYMemoryCache-是如何做到线程安全的"><a href="#YYMemoryCache-是如何做到线程安全的" class="headerlink" title="YYMemoryCache 是如何做到线程安全的"></a>YYMemoryCache 是如何做到线程安全的</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYMemoryCache</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 线程锁，旨在保证 YYMemoryCache 线程安全</span></span><br><span class="line">    _YYLinkedMap *_lru; <span class="comment">// _YYLinkedMap，YYMemoryCache 通过它间接操作缓存对象</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _queue; <span class="comment">// 串行队列，用于 YYMemoryCache 的 trim 操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这里 ibireme 选择使用 <code>pthread_mutex</code> 线程锁来确保 YYMemoryCache 的线程安全。</p>
<blockquote>
<p>有趣的是，这里 ibireme 使用 <code>pthread_mutex</code> 是有一段小故事的。在最初 YYMemoryCache 这里使用的锁是 <code>OSSpinLock</code> 自旋锁（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 备注-关于锁），后面有人在 Github 向作者提 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel/issues/43">issue</a> 反馈 <code>OSSpinLock</code> 不安全，经过作者的确认（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a>）最后选择用 <code>pthread_mutex</code> 替代 <code>OSSpinLock</code>。</p>
</blockquote>
<img src="/yycache/lock_benchmark.jpg" class="">
<p>上面是 ibireme 在确认 <code>OSSpinLock</code> 不再安全之后为了寻找替代方案做的简单性能测试，对比了一下几种能够替代 <code>OSSpinLock</code> 锁的性能。在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a> 文末的评论中，我找到了作者使用 <code>pthread_mutex</code> 的原因。</p>
<blockquote>
<p>ibireme: 苹果员工说 libobjc 里 <code>spinlock</code> 是用了一些私有方法 (<code>mach_thread_switch</code>)，贡献出了高线程的优先来避免优先级反转的问题，但是我翻了下 libdispatch 的源码倒是没发现相关逻辑，也可能是我忽略了什么。在我的一些测试中，<code>OSSpinLock</code> 和 <code>dispatch_semaphore</code> 都不会产生特别明显的死锁，所以我也无法确定用 <code>dispatch_semaphore</code> 代替 <code>OSSpinLock</code> 是否正确。能够肯定的是，用 <code>pthread_mutex</code> 是安全的。</p>
</blockquote>
<h3 id="YYLinkedMapNode-与-YYLinkedMap"><a href="#YYLinkedMapNode-与-YYLinkedMap" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code></h3><p>上文介绍了 YYMemoryCache，其实 YYMemoryCache 并不直接操作缓存对象，而是通过内部的 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 来间接的操作缓存对象。这两个类对于上文中提到的 LRU 缓存算法的理解至关重要，所以我把他们俩单独拎出来放在这里详细解读一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 中的一个节点。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    <span class="type">id</span> _key;</span><br><span class="line">    <span class="type">id</span> _value;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost; <span class="comment">// 记录开销，对应 YYMemoryCache 提供的 cost 控制</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">// 记录时间，对应 YYMemoryCache 提供的 age 控制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYMemoryCache 内的一个链表。</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// 不要直接设置该对象</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;</span><br><span class="line">    _YYLinkedMapNode *_head; <span class="comment">// MRU, 最常用节点，不要直接修改它</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// LRU, 最少用节点，不要直接修改它</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseOnMainThread; <span class="comment">// 对应 YYMemoryCache 的 releaseOnMainThread</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseAsynchronously; <span class="comment">// 对应 YYMemoryCache 的 releaseAsynchronously</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表操作，看接口名称应该不需要注释吧~</span></span><br><span class="line">- (<span class="type">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line">- (<span class="type">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便大家阅读，我标注了必要的中文注释。其实对数据结构与算法不陌生的同学应该一眼就看的出来 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 这俩货的本质。没错，丫就是双向链表节点和双向链表。</p>
<p><code>_YYLinkedMapNode</code> 作为双向链表节点，除了基本的 <code>_prev</code>、<code>_next</code>，还有键值缓存基本的 <code>_key</code> 与 <code>_value</code>，<strong>我们可以把 <code>_YYLinkedMapNode</code> 理解为 YYMemoryCache 中的一个缓存对象</strong>。</p>
<p><code>_YYLinkedMap</code> 作为由 <code>_YYLinkedMapNode</code> 节点组成的双向链表，使用 <code>CFMutableDictionaryRef _dic</code> 字典存储 <code>_YYLinkedMapNode</code>。这样在确保 <code>_YYLinkedMapNode</code> 被强引用的同时，能够利用字典的 Hash 快速定位用户要访问的缓存对象，这样既符合了键值缓存的概念又省去了自己实现的麻烦（笑）。</p>
<p>嘛~ 总得来说 YYMemoryCache 是通过使用 <code>_YYLinkedMap</code> 双向链表来操作 <code>_YYLinkedMapNode</code> 缓存对象节点的。</p>
<h3 id="LRU-least-recently-used-算法的实现"><a href="#LRU-least-recently-used-算法的实现" class="headerlink" title="LRU(least-recently-used) 算法的实现"></a>LRU(least-recently-used) 算法的实现</h3><p>上文我们认清了 <code>_YYLinkedMap</code> 与 <code>_YYLinkedMapNode</code> 本质上就是双向链表和链表节点，这里我们简单讲一下 YYMemoryCache 是如何利用双向链表实现 LRU(least-recently-used) 算法的。</p>
<h4 id="缓存替换策略"><a href="#缓存替换策略" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h4><p>首先 LRU 是缓存替换策略（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Cache replacement policies</a>）的一种，还有很多缓存替换策略诸如：</p>
<ul>
<li>First In First Out (FIFO)</li>
<li>Last In First Out (LIFO)</li>
<li>Time aware Least Recently Used (TLRU)</li>
<li>Most Recently Used (MRU)</li>
<li>Pseudo-LRU (PLRU)</li>
<li>Random Replacement (RR)</li>
<li>Segmented LRU (SLRU)</li>
<li>Least-Frequently Used (LFU)</li>
<li>Least Frequent Recently Used (LFRU)</li>
<li>LFU with Dynamic Aging (LFUDA)</li>
<li>Low Inter-reference Recency Set (LIRS)</li>
<li>Adaptive Replacement Cache (ARC)</li>
<li>Clock with Adaptive Replacement (CAR)</li>
<li>Multi Queue (MQ) caching algorithm|Multi Queue (MQ)</li>
<li>Pannier: Container-based caching algorithm for compound objects</li>
</ul>
<p>是不是被唬到了？不要担心，我这里会表述的尽量易懂。</p>
<h4 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h4><img src="/yycache/cache_hit_ratio.png" class="">
<p>为什么有这么多缓存替换策略，或者说搞这么多名堂究竟是为了什么呢？</p>
<p>答案是提高缓存命中率，那么何谓缓存命中率呢？</p>
<p>Google 一下自然是有不少解释，不过很多都是 web 相关的，而且不说人话（很难理解），我个人非常讨厌各种不说人话的“高深”抽象概念。</p>
<p>这里抖了好几抖胆才敢谈一下我对于缓存命中率的理解（限于 YYCache 和 iOS 开发）。</p>
<ul>
<li>缓存命中 = 用户要访问的缓存对象在高速缓存中，我们直接在高速缓存中通过 Hash 将其找到并返回给用户。</li>
<li>缓存命中率 = 用户要访问的缓存对象在高速缓存中被我们访问到的概率。</li>
</ul>
<p>既然谈到了自己的理解，我索性说个够。</p>
<ul>
<li>缓存丢失 = 由于高速缓存数量有限（占据内存等原因），所以用户要访问的缓存对象很有可能被我们从有限的高速缓存中淘汰掉了，我们可能会将其存储于低速的磁盘缓存中（如果磁盘缓存还有资源的话），那么就要从磁盘缓存中获取该缓存对象以返回给用户，这种情况我理解为（高速）缓存未命中，即缓存丢失（并不是真的被我们丢掉了，但肯定是被我们从高速缓存淘汰掉了）。</li>
</ul>
<p>缓存命中是 cache-hit，那么如果你玩游戏，可以理解为这次 hit miss 了（笑，有人找我开黑吗）。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>首先来讲一下 LRU 的概念让大家有一个基本的认识。LRU(least-recently-used) 翻译过来是“最近最少使用”，顾名思义这种缓存替换策略是基于用户最近最少访问过的缓存对象而建立。</p>
<p>我认为 LRU 缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。</p>
<h4 id="YYLinkedMapNode-与-YYLinkedMap-实现-LRU"><a href="#YYLinkedMapNode-与-YYLinkedMap-实现-LRU" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap 实现 LRU"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 实现 LRU</h4><p>YYCache 作者通过 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 双向链表实现 LRU 缓存替换策略的思路其实很简捷清晰，我们一步一步来看。</p>
<p>双向链表中有头结点和尾节点：</p>
<ul>
<li>头结点 = 链表中用户最近一次使用（访问）的缓存对象节点，MRU。</li>
<li>尾节点 = 链表中用户已经很久没有再次使用（访问）的缓存对象节点，LRU。</li>
</ul>
<p>如何让头结点和尾节点指向我们想指向的缓存对象节点？我们结合代码来看：</p>
<ul>
<li>在用户使用（访问）时更新缓存节点信息，并将其移动至双向链表头结点。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)objectForKey:(<span class="type">id</span>)key &#123;</span><br><span class="line">    <span class="comment">// 判断入参</span></span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 找到对应缓存节点</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 更新缓存节点时间，并将其移动至双向链表头结点</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 返回找到的缓存节点 value</span></span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在用户设置缓存对象时，判断入参 key 对应的缓存对象节点是否存在？存在则更新缓存对象节点并将节点移动至链表头结点；不存在则根据入参生成新的缓存对象节点并插入链表表头。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setObject:(<span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    <span class="comment">// 判断入参，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 判断入参 key 对应的缓存对象节点是否存在</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存在则更新缓存对象节点并将节点移动至链表头结点</span></span><br><span class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class="line">        _lru-&gt;_totalCost += cost;</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在则根据入参生成新的缓存对象节点并插入链表表头</span></span><br><span class="line">        node = [_YYLinkedMapNode new];</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_key = key;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru insertNodeAtHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入、更新节点之后是否超过了限制 cost、count，如果超过则 trim，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在资源不足时，从双线链表的尾节点（LRU）开始清理缓存，释放资源。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里拿 count 资源举例，cost、age 自己举一反三</span></span><br><span class="line">- (<span class="type">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="comment">// 判断 countLimit 为 0，则全部清空缓存，省略</span></span><br><span class="line">    <span class="comment">// 判断 _lru-&gt;_totalCount &lt;= countLimit，没有超出资源限制则不作处理，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class="line">                <span class="comment">// 从双线链表的尾节点（LRU）开始清理缓存，释放资源</span></span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程</span></span><br><span class="line">            <span class="comment">// 对比 sleep 用 usleep 能更好的利用 CPU 时间</span></span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要在主线程释放，采取释放缓存对象操作</span></span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 是不是感觉敲简单？上面代码去掉了可能会分散大家注意力的代码，我们这里仅仅讨论 LRU 的实现，其余部分的具体实现源码也非常简单，我觉得没必要贴出来单独讲解，感兴趣的同学可以自己去 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 下载源码查阅。</p>
<h4 id="异步释放技巧"><a href="#异步释放技巧" class="headerlink" title="异步释放技巧"></a>异步释放技巧</h4><p>关于上面的异步释放缓存对象的代码，我觉得还是有必要单独拎出来讲一下的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">    [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个技巧 ibireme 在他的另一篇文章 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a> 中有提及：</p>
<blockquote>
<p>Note: 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
</blockquote>
<p>而上面代码中的 YYMemoryCacheGetReleaseQueue 这个队列源码为：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内联 dispatch_queue_t</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码中可以看到 YYMemoryCacheGetReleaseQueue 是一个低优先级 <code>DISPATCH_QUEUE_PRIORITY_LOW</code> 队列，猜测这样设计的原因是可以让 iOS 在系统相对空闲时再来异步释放缓存对象。</p>
<h2 id="YYDiskCache-细节剖析"><a href="#YYDiskCache-细节剖析" class="headerlink" title="YYDiskCache 细节剖析"></a>YYDiskCache 细节剖析</h2><img src="/yycache/yydiskcache.jpg" class="">
<p>YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。</p>
<p>YYDiskCache 具有以下功能：</p>
<ul>
<li>它使用 LRU(least-recently-used) 来删除对象。</li>
<li>支持按 cost，count 和 age 进行控制。</li>
<li>它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。</li>
<li>它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。</li>
</ul>
<blockquote>
<p>Note: 您可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYDiskCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path; <span class="comment">// 缓存路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold; <span class="comment">// 阈值，大于阈值则存储类型为 file；否则存储类型为 sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSData</span> *(^customArchiveBlock)(<span class="type">id</span> object); <span class="comment">// 用来替换 NSKeyedArchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">id</span> (^customUnarchiveBlock)(<span class="built_in">NSData</span> *data); <span class="comment">// 用来替换 NSKeyedUnarchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *(^customFileNameBlock)(<span class="built_in">NSString</span> *key); <span class="comment">// 当一个对象将以 file 的形式保存时，该代码块用来生成指定文件名。如果为 nil，则默认使用 md5(key) 作为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> freeDiskSpaceLimit; <span class="comment">// 缓存应该保留的最小可用磁盘空间（以字节为单位），默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 60s</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> errorLogsEnabled; <span class="comment">// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line">                                 </span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCount;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCost;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Extended Data</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getExtendedDataFromObject:(<span class="type">id</span>)object;</span><br><span class="line">+ (<span class="type">void</span>)setExtendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData toObject:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYDiskCache 结构与 YYMemoryCache 类似，由于很多接口都是基于基本的接口做了扩展所得，这里贴的代码省略了一些接口。代码还是一如既往的干净简洁，相信各位都能看懂。</p>
<p>YYDiskCache 是基于 sqlite 和 file 来做的磁盘缓存，我们的缓存对象可以自由的选择存储类型，下面简单对比一下：</p>
<ul>
<li>sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。</li>
<li>file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。</li>
</ul>
<p>所以 YYDiskCache 使用两者配合，灵活的存储以提高性能。</p>
<h3 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h3><p>NSMapTable 是类似于字典的集合，但具有更广泛的可用内存语义。NSMapTable 是 iOS6 之后引入的类，它基于 NSDictionary 建模，但是具有以下差异：</p>
<ul>
<li>键/值可以选择 “weakly” 持有，以便于在回收其中一个对象时删除对应条目。</li>
<li>它可以包含任意指针（其内容不被约束为对象）。</li>
<li>您可以将 NSMapTable 实例配置为对任意指针进行操作，而不仅仅是对象。</li>
</ul>
<blockquote>
<p>Note: 配置映射表时，请注意，只有 NSMapTableOptions 中列出的选项才能保证其余的 API 能够正常工作，包括复制，归档和快速枚举。 虽然其他 NSPointerFunctions 选项用于某些配置，例如持有任意指针，但并不是所有选项的组合都有效。使用某些组合，NSMapTableOptions 可能无法正常工作，甚至可能无法正确初始化。</p>
</blockquote>
<p>更多信息详见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsmaptable?language=objc">NSMapTable 官方文档</a>。</p>
<p>需要特殊说明的是，YYDiskCache 内部是基于一个单例 NSMapTable 管理的，这点有别于 YYMemoryCache。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSMapTable</span> *_globalInstances; <span class="comment">// 引用管理所有的 YYDiskCache 实例</span></span><br><span class="line"><span class="keyword">static</span> dispatch_semaphore_t _globalInstancesLock; <span class="comment">// YYDiskCache 使用 dispatch_semaphore 保障 NSMapTable 线程安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> YYDiskCache *_YYDiskCacheGetGlobal(<span class="built_in">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="type">id</span> cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做也会提升不少性能。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="comment">// 判断是否可以成功初始化，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先从 NSMapTable 单例中根据 path 获取 YYDiskCache 实例，如果获取到就直接返回该实例</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有获取到则初始化一个 YYDiskCache 实例</span></span><br><span class="line">    <span class="comment">// 要想初始化一个 YYDiskCache 首先要初始化一个 YYKVStorage</span></span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据刚才得到的 kv 和 path 入参初始化一个 YYDiskCache 实例，代码太长省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启递归清理，会根据 _autoTrimInterval 对 YYDiskCache trim</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    <span class="comment">// 向 NSMapTable 单例注册新生成的 YYDiskCache 实例</span></span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// App 生命周期通知相关代码，省略</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中找到了作者使用 dispatch_semaphore 作为 YYDiskCache 锁的原因：</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<h3 id="YYKVStorageItem-与-YYKVStorage"><a href="#YYKVStorageItem-与-YYKVStorage" class="headerlink" title="YYKVStorageItem 与 YYKVStorage"></a>YYKVStorageItem 与 YYKVStorage</h3><p>刚才在 YYDiskCache 的初始化源码中，我们不难发现一个类 YYKVStorage。与 YYMemoryCache 相对应的，YYDiskCache 也不会直接操作缓存对象（sqlite/file），而是通过 YYKVStorage 来间接的操作缓存对象。</p>
<p>从这一点上不难发现，YYKVStorage 等价于 YYMemoryCache 中的双向链表 <code>_YYLinkedMap</code>，而对应于 <code>_YYLinkedMap</code> 中的节点 <code>_YYLinkedMapNode</code>，YYKVStorage 中也有一个类 YYKVStorageItem 充当着与缓存对象一对一的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorageItem 是 YYKVStorage 中用来存储键值对和元数据的类</span></span><br><span class="line"><span class="comment">// 通常情况下，我们不应该直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">///&lt; key</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">///&lt; value</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">///&lt; filename (nil if inline)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> size;                             <span class="comment">///&lt; value&#x27;s size in bytes</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> modTime;                          <span class="comment">///&lt; modification unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> accessTime;                       <span class="comment">///&lt; last access unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">///&lt; extended data (nil if no extended data)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYKVStorage 是基于 sqlite 和文件系统的键值存储。</span></span><br><span class="line"><span class="comment"> 通常情况下，我们不应该直接使用这个类。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @warning </span></span><br><span class="line"><span class="comment">  这个类的实例是 *非* 线程安全的，你需要确保</span></span><br><span class="line"><span class="comment">  只有一个线程可以同时访问该实例。如果你真的</span></span><br><span class="line"><span class="comment">  需要在多线程中处理大量的数据，应该分割数据</span></span><br><span class="line"><span class="comment">  到多个 KVStorage 实例（分片）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorage</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;        <span class="comment">/// storage 路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYKVStorageType type;  <span class="comment">/// storage 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> errorLogsEnabled;           <span class="comment">/// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path type:(YYKVStorageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Save Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Remove Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Items</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Storage Status</span></span><br><span class="line">- (<span class="type">BOOL</span>)itemExistsForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">int</span>)getItemsCount;</span><br><span class="line">- (<span class="type">int</span>)getItemsSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>代码美哭了有木有！？这种代码根本不需要翻译，我觉得相比于逐行的翻译，直接看代码更舒服。这里我们只需要看一下 YYKVStorageType 这个枚举，他决定着 YYKVStorage 的存储类型。</p>
<h4 id="YYKVStorageType"><a href="#YYKVStorageType" class="headerlink" title="YYKVStorageType"></a>YYKVStorageType</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 存储类型，指示“YYKVStorageItem.value”存储在哪里。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @discussion</span></span><br><span class="line"><span class="comment">  通常，将数据写入 sqlite 比外部文件更快，但是</span></span><br><span class="line"><span class="comment">  读取性能取决于数据大小。在我的测试（环境 iPhone 6 64G），</span></span><br><span class="line"><span class="comment">  当数据较大（超过 20KB）时从外部文件读取数据比 sqlite 更快。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class="line">    YYKVStorageTypeFile = <span class="number">0</span>, <span class="comment">// value 以文件的形式存储于文件系统</span></span><br><span class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>, <span class="comment">// value 以二进制形式存储于 sqlite</span></span><br><span class="line">    YYKVStorageTypeMixed = <span class="number">2</span>, <span class="comment">// value 将根据你的选择基于上面两种形式混合存储</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 YYKVStorageType 的注释中标记了作者写 YYCache 时做出的测试结论，大家也可以基于自己的环境去测试验证作者的说法（这一点是可以讨论的，我们可以根据自己的测试来设置 YYDiskCache 中的 inlineThreshold 阈值）。</p>
<blockquote>
<p>如果想要了解更多的信息可以点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/intern-v-extern-blob.html">Internal Versus External BLOBs in SQLite</a> 查阅 SQLite 官方文档。</p>
</blockquote>
<h4 id="YYKVStorage-性能优化细节"><a href="#YYKVStorage-性能优化细节" class="headerlink" title="YYKVStorage 性能优化细节"></a>YYKVStorage 性能优化细节</h4><p>上文说到 YYKVStorage 可以基于 SQLite 和文件系统做磁盘存储，这里再提一些我阅读源码发现到的有趣细节：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYKVStorage</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">CFMutableDictionaryRef</span> _dbStmtCache; <span class="comment">// 焦点集中在这里</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>CFMutableDictionaryRef _dbStmtCache;</code> 是 YYKVStorage 中的私有成员，它是一个可变字典充当着 sqlite3_stmt 缓存的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite3_stmt *)_dbPrepareStmt:(<span class="built_in">NSString</span> *)sql &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> _dbCheck] || sql.length == <span class="number">0</span> || !_dbStmtCache) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt</span></span><br><span class="line">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class="built_in">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql));</span><br><span class="line">    <span class="keyword">if</span> (!stmt) &#123;</span><br><span class="line">        <span class="comment">// 如果没有缓存再从新生成一个 sqlite3_stmt</span></span><br><span class="line">        <span class="type">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 生成结果异常则根据错误日志开启标识打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite stmt prepare error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成成功则放入 _dbStmtCache 缓存</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql), stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlite3_reset(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以省去一些重复生成 sqlite3_stmt 的开销。</p>
<blockquote>
<p>sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。</p>
</blockquote>
<p>更多关于 SQLite 的信息请点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/docs.html">SQLite 官方文档</a> 查阅。</p>
<h2 id="优秀的缓存应该具备哪些特质"><a href="#优秀的缓存应该具备哪些特质" class="headerlink" title="优秀的缓存应该具备哪些特质"></a>优秀的缓存应该具备哪些特质</h2><img src="/yycache/good_cache.jpg" class="">
<p>嘛~ 我们回到文章最初提到的问题，优秀的缓存应该具备哪些特质？</p>
<p>如果跟着文章一步步读到这里，相信很容易举出以下几点：</p>
<ul>
<li>内存缓存和磁盘缓存</li>
<li>线程安全</li>
<li>缓存控制</li>
<li>缓存替换策略</li>
<li>缓存命中率</li>
<li>性能</li>
</ul>
<p>我们简单的总结一下 YYCache 源码中是如何体现这些特质的。</p>
<h3 id="内存缓存和磁盘缓存"><a href="#内存缓存和磁盘缓存" class="headerlink" title="内存缓存和磁盘缓存"></a>内存缓存和磁盘缓存</h3><p>YYCache 是由内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。</p>
<p>在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果说 YYCache 这个类是一个纯逻辑层的缓存类（指 YYCache 的接口实现全部是调用其他类完成），那么 YYMemoryCache 与 YYDiskCache 还是做了一些事情的（并没有 YYCache 当甩手掌柜那么轻松），其中最显而易见的就是 YYMemoryCache 与 YYDiskCache 为 YYCache 保证了线程安全。</p>
<p>YYMemoryCache 使用了 <code>pthread_mutex</code> 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 <code>dispatch_semaphore</code>，上文已经给出了作者选择这些锁的原因。</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>YYCache 提供了三种控制维度，分别是：cost、count、age。这已经满足了绝大多数开发者的需求，我们在自己设计缓存时也可以根据自己的使用环境提供合适的控制方式。</p>
<h3 id="缓存替换策略-1"><a href="#缓存替换策略-1" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h3><p>在上文解析 YYCache 源码的时候，介绍了缓存替换策略的概念并且列举了很多经典的策略。YYCache 使用了双向链表（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）实现了 LRU(least-recently-used) 策略，旨在提高 YYCache 的缓存命中率。</p>
<h3 id="缓存命中率-1"><a href="#缓存命中率-1" class="headerlink" title="缓存命中率"></a>缓存命中率</h3><p>这一概念是在上文解析 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 小节介绍的，我们在自己设计缓存时不一定非要使用 LRU 策略，可以根据我们的实际使用环境选择最适合我们自己的缓存替换策略。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>其实性能这个东西是隐而不见的，又是到处可见的（笑）。它从我们最开始设计一个缓存架构时就被带入，一直到我们具体的实现细节中慢慢成形，最后成为了我们设计出来的缓存优秀与否的决定性因素。</p>
<p>上文中剖析了太多 YYCache 中对于性能提升的实现细节：</p>
<ul>
<li>异步释放缓存对象</li>
<li>锁的选择</li>
<li>使用 NSMapTable 单例管理的 YYDiskCache</li>
<li>YYKVStorage 中的 <code>_dbStmtCache</code></li>
<li>甚至使用 CoreFoundation 来换取微乎其微的性能提升</li>
</ul>
<p>看到这里是不是恍然大悟，性能是怎么来的？就是这样对于每一个细节的极致追求一点一滴积少成多抠出来的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的解读了 YYCache 源码，相信可以让各位读者对 YYCache 的整体架构有一个清晰的认识。</li>
<li>文章结合作者 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中的内容对 YYCache 具体功能点实现源码做了深入剖析，再用我自己的理解表述出来，希望可以对读者理解 YYCache 中具体功能的实现提供帮助。</li>
<li>根据我自己的源码理解，把我认为做的不错的提升性能的源码细节单独拎出来做出详细分析。</li>
<li>总结归纳出“一个优秀缓存需要具备哪些特质？”这一问题的答案，希望大家在面试中如果被问及“如何设计一个缓存”这类问题时可以游刃有余。额，至少可以为大家提供一些回答思路，抛砖引玉（笑）。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yycache/" rel="tag">yycache</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/ios_native_js/">
      iOS 与 JS 交互开发知识总结
    </a>
  </h2>
  
  <time>
    10月 23, 2017
  </time>
  <section class="content">
	  <img src="/ios_native_js/hybrid.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而说到 Native 与 JS 交互，就不得不提一嘴 Hybrid。</p>
<p>Hybrid 的翻译结果并不是很文明（擦汗，不知道为啥很多翻译软件会译为“杂种”，但我更喜欢将它翻译为“混合、混血”），Hybrid Mobile App 我对它的理解为通过 Web 网络技术（如 HTML，CSS 和 JavaScript）与 Native 相结合的混合移动应用程序。</p>
<p>那么我们来看一下 Hybrid 对比 Native 有哪些优劣：</p>
<img src="/ios_native_js/hybrid_vs_native.jpg" class="">
<p>因为 Hybrid 的灵活性（更改 Web 页面不必重新发版）以及通用性（一份 H5 玩遍所有平台）再加上门槛低（前端猿可以无痛上手开撸）的优势，所以在非核心功能模块使用 Web 通过 Hybrid 的方式来实现可能从各方面都会优于 Native。而 Native 则可以在核心功能和设备硬件的调用上为 JS 提供强有力的支持。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Hybrid 的发展简史</li>
<li>JavaScriptCore 简介</li>
<li>iOS Native 与 JS 交互的方法</li>
<li>WKWebView 与 JS 交互的特有方法</li>
<li>JS 通过 Native 调用 iOS 设备摄像头的 Demo</li>
<li>总结</li>
</ul>
<h2 id="Hybrid-的发展简史"><a href="#Hybrid-的发展简史" class="headerlink" title="Hybrid 的发展简史"></a>Hybrid 的发展简史</h2><p>下面简述一下 Hybrid 的发展史：</p>
<h3 id="1-H5-发布"><a href="#1-H5-发布" class="headerlink" title="1.H5 发布"></a>1.H5 发布</h3><img src="/ios_native_js/html5.png" class="">
<p>Html5 是在 2014 年 9 月份正式发布的，这一次的发布做了一个最大的改变就是“从以前的 XML 子集升级成为一个独立集合”。</p>
<h3 id="2-H5-渗入-Mobile-App-开发"><a href="#2-H5-渗入-Mobile-App-开发" class="headerlink" title="2.H5 渗入 Mobile App 开发"></a>2.H5 渗入 Mobile App 开发</h3><p>Native APP 开发中有一个 webview 的组件（Android 中是 webview，iOS 有 UIWebview和 WKWebview），这个组件可以加载 Html 文件。</p>
<p>在 H5 大行其道之前，webview 加载的 web 页面很单调（因为只能加载一些静态资源），自从 H5 火了之后，前端猿们开发的 H5 页面在 webview 中的表现不俗使得 H5 开发慢慢渗透到了 Mobile App 开发中来。</p>
<h3 id="3-Hybrid-现状"><a href="#3-Hybrid-现状" class="headerlink" title="3.Hybrid 现状"></a>3.Hybrid 现状</h3><p>虽然目前已经出现了 RN 和 Weex 这些使用 JS 写 Native App 的技术，但是 Hybrid 仍然没有被淘汰，市面上大多数应用都不同程度的引入了 Web 页面。</p>
<h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>JavaScriptCore 这个库是 Apple 在 iOS 7 之后加入到标准库的，它对 iOS Native 与 JS 做交互调用产生了划时代的影响。</p>
<p>JavaScriptCore 大体是由 4 个类以及 1 个协议组成的：</p>
<img src="/ios_native_js/javascriptcore_framework.jpg" class="">
<ul>
<li>JSContext 是 JS 执行上下文，你可以把它理解为 JS 运行的环境。</li>
<li>JSValue 是对 JavaScript 值的引用，任何 JS 中的值都可以被包装为一个 JSValue。</li>
<li>JSManagedValue 是对 JSValue 的包装，加入了“conditional retain”。</li>
<li>JSVirtualMachine 表示 JavaScript 执行的独立环境。</li>
</ul>
<p>还有 JSExport 协议：</p>
<blockquote>
<p>实现将 Objective-C 类及其实例方法，类方法和属性导出为 JavaScript 代码的协议。</p>
</blockquote>
<p>这里的 JSContext，JSValue，JSManagedValue 相对比较好理解，下面我们把 JSVirtualMachine 单拎出来说明一下：</p>
<h3 id="JSVirtualMachine-的用法和其与-JSContext-的关系"><a href="#JSVirtualMachine-的用法和其与-JSContext-的关系" class="headerlink" title="JSVirtualMachine 的用法和其与 JSContext 的关系"></a>JSVirtualMachine 的用法和其与 JSContext 的关系</h3><img src="/ios_native_js/jsvirtualmachine.jpg" class="">
<p>官方文档的介绍：</p>
<blockquote>
<p>JSVirtualMachine 实例表示用于 JavaScript 执行的独立环境。 您使用此类有两个主要目的：支持并发 JavaScript 执行，并管理 JavaScript 和 Objective-C 或 Swift 之间桥接的对象的内存。</p>
</blockquote>
<p>关于 JSVirtualMachine 的使用，一般情况下我们不用手动去创建 JSVirtualMachine。因为当我们获取 JSContext 时，获取到的 JSContext 从属于一个 JSVirtualMachine。</p>
<p>每个 JavaScript 上下文（JSContext 对象）都属于一个 JSVirtualMachine。 每个 JSVirtualMachine 可以包含多个上下文，允许在上下文之间传递值（JSValue 对象）。 但是，每个 JSVirtualMachine 是不同的，即我们不能将一个 JSVirtualMachine 中创建的值传递到另一个 JSVirtualMachine 中的上下文。</p>
<p>JavaScriptCore API 是线程安全的 —— 例如，我们可以从任何线程创建 JSValue 对象或运行 JS 脚本 - 但是，尝试使用相同 JSVirtualMachine 的所有其他线程将被阻塞。 要在多个线程上同时（并发）运行 JavaScript 脚本，请为每个线程使用单独的 JSVirtualMachine 实例。</p>
<h3 id="JSValue-与-JavaScript-的转换表"><a href="#JSValue-与-JavaScript-的转换表" class="headerlink" title="JSValue 与 JavaScript 的转换表"></a>JSValue 与 JavaScript 的转换表</h3><table>
<thead>
<tr>
<th>OBJECTIVE-C</th>
<th>JAVASCRIPT</th>
<th>JSVALUE CONVERT</th>
<th>JSVALUE CONSTRUCTOR</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil</td>
<td>undefined</td>
<td></td>
<td>valueWithUndefinedInContext</td>
</tr>
<tr>
<td>NSNull</td>
<td>null</td>
<td></td>
<td>valueWithNullInContext:</td>
</tr>
<tr>
<td>NSString</td>
<td>string</td>
<td>toString</td>
<td></td>
</tr>
<tr>
<td>NSNumber</td>
<td>number, boolean</td>
<td>toNumber<br />toBool<br />toDouble<br />toInt32<br />toUInt32</td>
<td>valueWithBool:inContext:<br />valueWithDouble:inContext:<br />valueWithInt32:inContext:<br />valueWithUInt32:inContext:</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Object object</td>
<td>toDictionary</td>
<td>valueWithNewObjectInContext:</td>
</tr>
<tr>
<td>NSArray</td>
<td>Array object</td>
<td>toArray</td>
<td>valueWithNewArrayInContext:</td>
</tr>
<tr>
<td>NSDate</td>
<td>Date object</td>
<td>toDate</td>
<td></td>
</tr>
<tr>
<td>NSBlock</td>
<td>Function object</td>
<td></td>
<td></td>
</tr>
<tr>
<td>id</td>
<td>Wrapper object</td>
<td>toObject<br />toObjectOfClass:</td>
<td>valueWithObject:inContext:</td>
</tr>
<tr>
<td>Class</td>
<td>Constructor object</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="iOS-Native-与-JS-交互"><a href="#iOS-Native-与-JS-交互" class="headerlink" title="iOS Native 与 JS 交互"></a>iOS Native 与 JS 交互</h2><p>对于 iOS Native 与 JS 交互我们先从调用方向上分为两种情况来看：</p>
<ul>
<li>JS 调用 Native</li>
<li>Native 调用 JS</li>
</ul>
<img src="/ios_native_js/call_eachother.jpg" class="">
<h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>其实 JS 调用 iOS Native 也分为两种实现方式：</p>
<ul>
<li>假 Request 方法</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="假-Request-方法"><a href="#假-Request-方法" class="headerlink" title="假 Request 方法"></a>假 Request 方法</h4><p>原理：其实这种方式就是利用了 webview 的代理方法，在 webview 开始请求的时候截获请求，判断请求是否为约定好的假请求。如果是假请求则表示是 JS 想要按照约定调用我们的 Native 方法，按照约定去执行我们的 Native 代码就好。</p>
<h5 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 代理有用于截获请求的函数，在里面做判断就好：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>WKWebView 有两个代理，一个是 WKNavigationDelegate，另一个是 WKUIDelegate。WKUIDelegate 我们在下面的章节会讲到，这里我们需要设置并实现它的 WKNavigationDelegate 方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>decisionHandler</code> 是当你的应用程序决定是允许还是取消导航时，要调用的代码块。 该代码块使用单个参数，它必须是枚举类型 <code>WKNavigationActionPolicy</code> 的常量之一。如果不调用 <code>decisionHandler</code> 会引起 crash。</p>
</blockquote>
<p>这里补充一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callNative</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">loadURL</span>(<span class="string">&quot;your_func_name://xxx&quot;</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>然后拿个 button 标签用一下就好了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;callNative()&quot;&gt;Call Native!&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="JavaScriptCore-方法"><a href="#JavaScriptCore-方法" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>iOS 7 有了 JavaScriptCore 专门用来做 Native 与 JS 的交互。我们可以在 webview 完成加载之后获取 JSContext，然后利用 JSContext 将 JS 中的对象引用过来用 Native 代码对其作出解释或响应：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再 UIWebView 的完成加载的代理方法中</span></span><br><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="comment">// 获取 JS 上下文</span></span><br><span class="line">    jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line">    <span class="comment">// 做引用，将 JS 内的元素引用过来解释，比如方法可以解释成 Block，对象也可以指向 OC 的 Native 对象哦</span></span><br><span class="line">    jsContext[<span class="string">@&quot;iosDelegate&quot;</span>] = <span class="keyword">self</span>;</span><br><span class="line">    jsContext[<span class="string">@&quot;yourFuncName&quot;</span>] = ^(<span class="type">id</span> parameter)&#123;</span><br><span class="line">        <span class="comment">// 注意这里的线程默认是 web 处理的线程，如果涉及主线程操作需要手动转到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 JS 这边代码更简单了，干脆声明一个不解释的函数（约定好名字的），用于给 Native 做引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parameter = xxx;</span><br><span class="line"><span class="title function_">yourFuncName</span>(parameter);</span><br></pre></td></tr></table></figure>
<h3 id="iOS-Native-调用-JS"><a href="#iOS-Native-调用-JS" class="headerlink" title="iOS Native 调用 JS"></a>iOS Native 调用 JS</h3><p>iOS Native 调用 JS 的实现方法也被 JavaScriptCore 划分开来：</p>
<ul>
<li>webview 直接注入 JS 并执行</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="webview-直接注入-JS-并执行"><a href="#webview-直接注入-JS-并执行" class="headerlink" title="webview 直接注入 JS 并执行"></a>webview 直接注入 JS 并执行</h4><p>在 iOS 平台，webview 有注入并执行 JS 的 API。</p>
<h5 id="UIWebView-1"><a href="#UIWebView-1" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 有直接注入 JS 的方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;showAlert(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;alert msg&quot;</span>];</span><br><span class="line">[_webView stringByEvaluatingJavaScriptFromString:jsStr];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 这个方法会返回运行 JS 的结果（<code>nullable NSString *</code>），它是一个同步方法，会阻塞当前线程！尽管此方法不被弃用，但最佳做法是使用 <code>WKWebView</code> 类的 <code>evaluateJavaScript：completionHandler：method</code>。</p>
<p>官方文档：<br>The stringByEvaluatingJavaScriptFromString: method waits synchronously for JavaScript evaluation to complete. If you load web content whose JavaScript code you have not vetted, invoking this method could hang your app. Best practice is to adopt the WKWebView class and use its evaluateJavaScript:completionHandler: method instead.</p>
</blockquote>
<h5 id="WKWebView-1"><a href="#WKWebView-1" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>不同于 UIWebView，WKWebView 注入并执行 JS 的方法不会阻塞当前线程。因为考虑到 webview 加载的 web content 内 JS 代码不一定经过验证，如果阻塞线程可能会挂起 App。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;setLocation(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;北京市东城区南锣鼓巷纳福胡同xx号&quot;</span>];</span><br><span class="line">[_webview evaluateJavaScript:jsStr completionHandler:^(<span class="type">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@----%@&quot;</span>, result, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 方法不会阻塞线程，而且它的回调代码块总是在主线程中运行。</p>
<p>官方文档：<br>Evaluates a JavaScript string.<br>The method sends the result of the script evaluation (or an error) to the completion handler. The completion handler always runs on the main thread.</p>
</blockquote>
<h4 id="JavaScriptCore-方法-1"><a href="#JavaScriptCore-方法-1" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>上面简单提到过 JavaScriptCore 库提供的 JSValue 类，这里再提供一下官方文档对 JSValue 的介绍翻译：</p>
<blockquote>
<p>JSValue 实例是对 JavaScript 值的引用。 您可以使用 JSValue 类来转换 JavaScript 和 Objective-C 或 Swift 之间的基本值（如数字和字符串），以便在本机代码和 JavaScript 代码之间传递数据。</p>
</blockquote>
<p>不过你也看到了我贴在上面的 OC 和 JS 数据类型转换表，那里面根本没有限定为官方文档所说的基本值。如果你不熟悉 JS 的话，我这里解释一下为什么 JSValue 也可以指向 JS 中的对象和函数，因为 JS 语言不区分基本值和对象以及函数，在 JS 中“万物皆为对象”。</p>
<p>好了下面直接 show code：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先获取 JS 上下文</span></span><br><span class="line"><span class="keyword">self</span>.jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line"><span class="comment">// 如果涉及 UI 操作，切回主线程调用 JS 代码中的 YourFuncName，通过数组@[parameter] 入参</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    JSValue *jsValue = <span class="keyword">self</span>.jsContext[<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">    [jsValue callWithArguments:@[parameter]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码调用了 JS 代码中 YourFuncName 函数，并且给函数加了 @[parameter] 作为入参。为了方便阅读理解，这里再贴一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">YourFuncName</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="comment">// do what u want to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WKWebView-与-JS-交互的特有方法"><a href="#WKWebView-与-JS-交互的特有方法" class="headerlink" title="WKWebView 与 JS 交互的特有方法"></a>WKWebView 与 JS 交互的特有方法</h2><img src="/ios_native_js/wkwebview.jpg" class="">
<p>关于 WKWebView 与 UIWebView 的区别就不在本文加以详细说明了，更多信息还请自行查阅。这里要讲的是 WKWebView 在与 JS 的交互时特有的方法：</p>
<ul>
<li>WKUIDelegate 方法</li>
<li>MessageHandler 方法</li>
</ul>
<h3 id="WKUIDelegate-方法"><a href="#WKUIDelegate-方法" class="headerlink" title="WKUIDelegate 方法"></a>WKUIDelegate 方法</h3><p>对于 WKWebView 上文提到过，除了 WKNavigationDelegate，它还有一个 WKUIDelegate，这个 WKUIDelegate 是做什么用的呢？ </p>
<p>WKUIDelegate 协议包含一些函数用来监听 web JS 想要显示 alert 或 confirm 时触发。我们如果在 WKWebView 中加载一个 web 并且想要 web JS 的 alert 或 confirm 正常弹出，就需要实现对应的代理方法。</p>
<blockquote>
<p>Note: 如果没有实现对应的代理方法，则 webview 将会按照默认操作去做出行为。</p>
<ul>
<li>Alert: If you do not implement this method, the web view will behave as if the user selected the OK button.</li>
<li>Confirm: If you do not implement this method, the web view will behave as if the user selected the Cancel button.</li>
</ul>
</blockquote>
<p>我们这里就拿 alert 举例，相信各位读者可以自己举一反三。下面是在 WKUIDelegate 监听 web 要显示 alert 的代理方法中用 Native UIAlertController 替代 JS 中的 alert 显示的栗子 ：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="type">void</span> (^)(<span class="type">void</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// 用 Native 的 UIAlertController 弹窗显示 JS 将要提示的信息</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@&quot;提醒&quot;</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    [alert addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;知道了&quot;</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="comment">// 函数内必须调用 completionHandler</span></span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MessageHandler-方法"><a href="#MessageHandler-方法" class="headerlink" title="MessageHandler 方法"></a>MessageHandler 方法</h3><p>MessageHandler 是继 Native 截获 JS 假请求后另一种 JS 调用 Native 的方法，该方法利用了 WKWebView 的新特性实现。对比截获假 Request 的方法来说，MessageHandler 传参数更加简单方便。</p>
<h4 id="MessageHandler-指什么？"><a href="#MessageHandler-指什么？" class="headerlink" title="MessageHandler 指什么？"></a>MessageHandler 指什么？</h4><p>WKUserContentController 类有一个方法:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addScriptMessageHandler:(<span class="type">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><br>该方法用来添加一个脚本处理器，可以在处理器内对 JS 脚本调用的方法做出处理，从而达到 JS 调用 Native 的目的。</p>
<p>那么 WKUserContentController 类和 WKWebView 有毛关系呢？</p>
<p>在 WKWebView 的初始化函数中有一个入参 configuration，它的类型是 WKWebViewConfiguration。WKWebViewConfiguration 中包含一个属性 userContentController，这个 userContentController 就是 WKUserContentController 类型的实例，我们可以用这个 userContentController 来添加不同名称的脚本处理器。</p>
<img src="/ios_native_js/wkusercontentcontroller.jpg" class="">
<h5 id="MessageHandler-的坑"><a href="#MessageHandler-的坑" class="headerlink" title="MessageHandler 的坑"></a>MessageHandler 的坑</h5><p>那么回到 <code>- (void)addScriptMessageHandler:name:</code> 方法上面，该方法添加一个脚本消息处理器（第一个入参 scriptMessageHandler），并且给这个处理器起一个名字（第二个入参 name）。不过这个函数在使用的时候有个坑：scriptMessageHandler 入参会被强引用，那么如果你把当前 WKWebView 所在的 UIViewController 作为第一个入参，这个 viewController 被他自己所持有的 <code>webview.configuration. userContentController</code> 所持有，就会造成循环引用。</p>
<img src="/ios_native_js/retaincycle.jpg" class="">
<p>我们可以通过 <code>- (void)removeScriptMessageHandlerForName:</code> 方法删掉 userContentController 对 viewController 的强引用。所以一般情况下我们的代码会在 <code>viewWillAppear</code> 和 <code>viewWillDisappear</code> 成对儿的添加和删除 MessageHandler：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController removeScriptMessageHandlerForName:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKScriptMessageHandler-协议"><a href="#WKScriptMessageHandler-协议" class="headerlink" title="WKScriptMessageHandler 协议"></a>WKScriptMessageHandler 协议</h5><p>WKScriptMessageHandler 是脚本信息处理器协议，如果想让一个对象具有脚本信息处理能力（比如上文中 webview 的所属 viewController 也就是上面代码的 self）就必须使其遵循该协议。</p>
<p>WKScriptMessageHandler 协议内部非常简单，只有一个方法，我们必须要实现该方法（@required）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKScriptMessageHandler 协议方法，在接收到脚本信息时触发</span></span><br><span class="line">- (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    <span class="comment">// message 有两个属性：name 和 body</span></span><br><span class="line">    <span class="comment">// message.name 可以用于区别要做的处理</span></span><br><span class="line">    <span class="keyword">if</span> ([message.name isEqualToString:<span class="string">@&quot;YourFuncName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// message.body 相当于 JS 传递过来的参数</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;JS call native success %@&quot;</span>, message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充 JS 的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;name&gt; 换 YourFuncName，&lt;messageBody&gt; 换你要的入参即可</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.&lt;name&gt;.<span class="title function_">postMessage</span>(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure>
<p>搞定收工！</p>
<h2 id="JS-通过-Native-调用-iOS-设备摄像头的-Demo"><a href="#JS-通过-Native-调用-iOS-设备摄像头的-Demo" class="headerlink" title="JS 通过 Native 调用 iOS 设备摄像头的 Demo"></a>JS 通过 Native 调用 iOS 设备摄像头的 Demo</h2><p>徒手撸了一个 Demo，实现了 JS 与 Native 代码的交互，达到用 JS 在 webview 内调用 iOS 设备摄像头的功能。Demo 内含权限申请，用户拒绝授权等细节（技术上就是 JS 和 Native 相互传值调用），还请各位大佬指教。</p>
<p>向各位基佬低头，献上我的膝盖~<a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">（Demo 地址）</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这篇文章简单的介绍了一下 Hybrid Mobile App（其中还包括 Hybrid 的发展简史）。</li>
<li>介绍了 JavaScriptCore 的组成，并且把 JSVirtualMachine 与 JSContext 和 JSValue 之间的关系用图片的形式表述出来（JSVirtualMachine 包含 JSContext 包含 JSValue，都是 1 对 n 的关系，且由于同一个 JSVirtualMachine 下的代码会相互阻塞，所以如果想异步执行交互需要在不同的线程声明 JSVirtualMachine 并发执行）。</li>
<li>从调用方向的角度把 JS 与 iOS Native 相互调用的方式方法分别用代码示例讲解了一遍。</li>
<li>介绍了 WKWebView 与 JS 交互特有的方法：WKUIDelegate 和 MessageHandler。</li>
<li>提供了一个 JS 通过 Native 调用 iOS 设备摄像头的 Demo。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
</section>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
