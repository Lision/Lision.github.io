<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2017/12 | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/archives/2017/12/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	


	<section class="page-header archive">
    <h1>- <span>2017.12</span> -</h1>
  </section>




<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/webview_javascript_bridge/">
      深入剖析 WebViewJavascriptBridge
    </a>
  </h2>
  
  <time>
    12月 23, 2017
  </time>
  <section class="content">
	  <img src="/webview_javascript_bridge/merry_ch.jpg" class="">
<p>Emmmmm…这篇文章发布出来可能正逢圣诞节🎄，Merry Christmas!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而 JS 和 iOS Native 就好比两块没有交集的大陆，如果想要使它们相互通信就必须要建立一座“桥梁”。</p>
<p><strong>思考一下，如果项目组让你去造这座“桥”，如何才能做到既优雅又实用？</strong></p>
<p>本文将结合 WebViewJavascriptBridge 源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 是盛名已久的 JSBridge 库，早在 2011 年就被作者 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin">Marcus Westin</a> 发布到 GitHub，直到现在作者还在积极维护中，目前该项目已收获近 1w star 咯，其源码非常值得我们学习。</p>
<p>WebViewJavascriptBridge 的代码逻辑清晰，风格良好，加上自身代码量比较小使得其源码阅读非常轻松（可能需要一些 JS 基础）。更加难能可贵的是它仅使用了少量代码就实现了对于 Mac OS X 的 WebView 以及 iOS 平台的 UIWebView 和 WKWebView 三种组件的完美支持。</p>
<p>我对 WebViewJavascriptBridge 的评价是<strong>小而美</strong>，这类小而美的源码非常利于我们对其实现思想的学习（本文分析 WebViewJavascriptBridge 源码版本为 v6.0.3）。</p>
<p>关于 iOS 与 JS 的原生交互知识，之前我有写过一篇文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>，文章除了介绍 JavaScriptCore 库以及 UIWebView 和 WKWebView 与 JS 原生交互的方法之外还捎带提到了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hybrid">Hybrid</a> 的发展简史，文末还提供了一个 <a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">JS 通过 Native 调用 iOS 设备摄像头的 Demo</a>。</p>
<p>所以这篇文章不会再把重点放在 iOS 与 JS 的原生交互了，本文旨在介绍 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 的设计思路和实现原理，对 iOS 与 JS 原生交互知识感兴趣的同学推荐去阅读上面提到的文章，应该会有点儿帮助（笑）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>WebViewJavascriptBridge 简介</li>
<li>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</li>
<li>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</li>
<li>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</li>
<li>WebViewJavascriptBridge 的“桥梁美学”</li>
<li>文章总结</li>
</ul>
<h2 id="WebViewJavascriptBridge-简介"><a href="#WebViewJavascriptBridge-简介" class="headerlink" title="WebViewJavascriptBridge 简介"></a>WebViewJavascriptBridge 简介</h2><img src="/webview_javascript_bridge/bridge.png" class="">
<p>WebViewJavascriptBridge 是用于在 WKWebView，UIWebView 和 WebView 中的 Obj-C 和 JavaScript 之间发送消息的 iOS / OSX 桥接器。</p>
<p>有许多不错的项目都有使用 WebViewJavascriptBridge，这里简单列一部分（笑）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.messenger.com/">Facebook Messenger</a></li>
<li><a target="_blank" rel="noopener" href="https://www.facebook.com/paper">Facebook Paper</a></li>
<li><a target="_blank" rel="noopener" href="http://www.stayelsewhere.com/">ELSEWHERE</a></li>
<li>… &amp; many more!</li>
</ul>
<p>关于 WebViewJavascriptBridge 的具体使用方法详见其 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">GitHub 页面</a>。</p>
<p>在读完 WebViewJavascriptBridge 的源码之后我将其划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">源文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">接口层</td>
<td style="text-align:center">WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge</td>
</tr>
<tr>
<td style="text-align:center">实现层</td>
<td style="text-align:center">WebViewJavascriptBridgeBase</td>
</tr>
<tr>
<td style="text-align:center">JS 层</td>
<td style="text-align:center">WebViewJavascriptBridge_JS</td>
</tr>
</tbody>
</table>
<p>其中 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 作为接口层主要负责提供方便的接口，隐藏实现细节，其实现细节都是通过实现层 WebViewJavascriptBridgeBase 去做的，而 WebViewJavascriptBridge_JS 作为 JS 层其实存储了一段 JS 代码，在需要的时候注入到当前 WebView 组件中，最终实现 Native 与 JS 的交互。</p>
<h2 id="WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究"><a href="#WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究" class="headerlink" title="WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究"></a>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</h2><img src="/webview_javascript_bridge/golden_bridge.jpeg" class="">
<p>WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 作为接口层分别对应于 UIWebView 和 WKWebView 组件，我们来简单看一下这两个文件暴露出的信息：</p>
<p>WebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridge</span> : <span class="title">WVJB_WEBVIEW_DELEGATE_INTERFACE</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler; <span class="comment">// 注册 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 删除 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback; <span class="comment">// 调用 handler (JS)</span></span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate; <span class="comment">// 设置 webViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 的安全时长来加速消息传递，不推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>WKWebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emmmmm...这里应该不需要我注释了吧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKWebViewJavascriptBridge</span> : <span class="title">NSObject</span>&lt;<span class="title">WKNavigationDelegate</span>, <span class="title">WebViewJavascriptBridgeBaseDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="built_in">WKWebView</span>*)webView;</span><br><span class="line">+ (<span class="type">void</span>)enableLogging;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler;</span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName;</span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback;</span><br><span class="line">- (<span class="type">void</span>)reset;</span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate;</span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>disableJavscriptAlertBoxSafetyTimeout</code> 方法是通过禁用 JS 端 AlertBox 的安全时长来加速网桥消息传递的。如果想使用那么需要和前端约定好，如果禁用之后前端 JS 代码仍有调用 AlertBox 相关代码（alert, confirm, 或 prompt）则程序将被挂起，所以这个方法是不安全的，如无特殊需求笔者不推荐使用。</p>
</blockquote>
<p>可以看得出来这两个文件暴露出的接口几乎一致，其中 WebViewJavascriptBridge 中使用了宏定义 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 来分别适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件需要实现的代理方法。</p>
<h3 id="WebViewJavascriptBridge-中的宏定义"><a href="#WebViewJavascriptBridge-中的宏定义" class="headerlink" title="WebViewJavascriptBridge 中的宏定义"></a>WebViewJavascriptBridge 中的宏定义</h3><p>其实 WebViewJavascriptBridge 中为了适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件使用了一系列的宏定义，其源码比较简单：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __MAC_OS_X_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_OSX</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE WebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate, WebPolicyDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __IPHONE_OS_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#import <span class="string">&lt;UIKit/UIWebView.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_IOS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE UIWebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;UIWebViewDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;UIWebViewDelegate, WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>分别根据所在平台不同定义了 <code>WVJB_WEBVIEW_TYPE</code>，<code>WVJB_WEBVIEW_DELEGATE_TYPE</code> 以及刚才提到的 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 宏定义，并且分别定义了 <code>WVJB_PLATFORM_OSX</code> 和 <code>WVJB_PLATFORM_IOS</code> 便于之后的实现源码区分当前平台时使用，下面的 <code>supportsWKWebView</code> 宏定义也是同样的道理：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (__MAC_OS_X_VERSION_MAX_ALLOWED &gt; __MAC_10_9 || __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_7_1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> supportsWKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在引入头文件的时候可以通过这个 <code>supportsWKWebView</code> 宏灵活引入所需的头文件：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WebViewJavascriptBridge.m</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(supportsWKWebView)</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WKWebViewJavascriptBridge.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="WebViewJavascriptBridge-的实现分析"><a href="#WebViewJavascriptBridge-的实现分析" class="headerlink" title="WebViewJavascriptBridge 的实现分析"></a>WebViewJavascriptBridge 的实现分析</h3><p>我们接着看一下 WebViewJavascriptBridge 的实现部分，首先从内部变量信息看起：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(objc_arc_weak)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __weak</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __unsafe_unretained</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    WVJB_WEAK WVJB_WEBVIEW_TYPE* _webView; <span class="comment">// bridge 对应的 WebView 组件</span></span><br><span class="line">    WVJB_WEAK <span class="type">id</span> _webViewDelegate; <span class="comment">// 给 WebView 组件设置的代理（需要的话）</span></span><br><span class="line">    <span class="type">long</span> _uniqueId; <span class="comment">// 唯一标识，Emmmmm...但是我发现没卵用，只有 _base 中的 _uniqueId 才有用</span></span><br><span class="line">    WebViewJavascriptBridgeBase *_base; <span class="comment">// 上文说过，底层实现其实都是 WebViewJavascriptBridgeBase 在做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文提到 WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 的 .h 文件暴露接口信息非常相似，那么我们要不要看看 WKWebViewJavascriptBridge 的内部变量信息呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释参见 WebViewJavascriptBridge 就好</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WKWebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">WKWebView</span>* _webView;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span>&lt;<span class="built_in">WKNavigationDelegate</span>&gt; _webViewDelegate;</span><br><span class="line">    <span class="type">long</span> _uniqueId;</span><br><span class="line">    WebViewJavascriptBridgeBase *_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这俩货简直是一个妈生的。其实这是作者故意为之，因为作者想对外提供一套接口，即 WebViewJavascriptBridge，我们只需要使用 WebViewJavascriptBridge 就可以自动根据绑定的 WebView 组件的不同生成与之对应的 JSBridge 实例。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView &#123;</span><br><span class="line"><span class="comment">// 如果支持 WKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line">    <span class="comment">// 需要先判断当前入参 webView 是否从属于 WKWebView</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[<span class="built_in">WKWebView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WKWebViewJavascriptBridge 实例</span></span><br><span class="line">        <span class="keyword">return</span> (WebViewJavascriptBridge*) [<span class="built_in">WKWebViewJavascriptBridge</span> bridgeForWebView:webView];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 判断当前入参 webView 是否从属于 WebView（Mac OS X）或者 UIWebView（iOS）</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WebViewJavascriptBridge 实例</span></span><br><span class="line">        WebViewJavascriptBridge* bridge = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        [bridge _platformSpecificSetup:webView];</span><br><span class="line">        <span class="keyword">return</span> bridge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抛出 BadWebViewType 异常并返回 nil</span></span><br><span class="line">    [<span class="built_in">NSException</span> raise:<span class="string">@&quot;BadWebViewType&quot;</span> format:<span class="string">@&quot;Unknown web view type.&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的代码，实现并不复杂。如果支持 WKWebView 的话（<code>#if defined supportsWKWebView</code>）则去判断当前绑定的 WebView 组件是否从属于 WKWebView，这样可以返回 WKWebViewJavascriptBridge 实例，否则返回 WebViewJavascriptBridge 实例，最后如果入参 <code>webView</code> 的类型不满足判断条件则抛出 <code>BadWebViewType</code> 异常。</p>
<p>还有一个关于 <code>_webViewDelegate</code> 的小细节，本来不打算讲的，但是还是提一下吧（囧）。其实在 WebViewJavascriptBridge 以及 WKWebViewJavascriptBridge 的初始化实现过程中，会把当前 WebView 组件的代理绑定为自己：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WKWebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _setupInstance:(<span class="built_in">WKWebView</span>*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 替换组件的代理将其代理绑定为 bridge 自己是因为 WebViewJavascriptBridge 的实现原理上是利用我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，所以需要监听 WebView 组件的代理方法获取加载之前的 Request.URL 并做处理。这也是为什么 WebViewJavascriptBridge 提供了一个接口 <code>setWebViewDelegate:</code> 存储了一个逻辑上的 <code>_webViewDelegate</code>，这个 <code>_webViewDelegate</code> 也需要遵循 WebView 组件的代理协议，这样在 WebViewJavascriptBridge 内部不同的代理方法中做完 bridge 要做的事情只有就会再去调用 <code>_webViewDelegate</code> 对应的代理方法，其实可以理解为 WebViewJavascriptBridge 对当前 WebView 组件的代理做了 hook。</p>
</blockquote>
<p>对于 WebViewJavascriptBridge 中暴露的初始化以外的所有接口，其内部实现都是通过 WebViewJavascriptBridgeBase 来实现的。这样做的好处就是<strong>即使 WebViewJavascriptBridge 因为绑定了 WKWebView 返回了 WKWebViewJavascriptBridge 实例，只要接口一致，对 JSBridge 发送相同的消息，就会有相同的实现（都是由 WebViewJavascriptBridgeBase 类实现的）</strong>。</p>
<h2 id="WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析"><a href="#WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析" class="headerlink" title="WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析"></a>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</h2><img src="/webview_javascript_bridge/pier.jpg" class="">
<p>作为 WebViewJavascriptBridge 的实现层，WebViewJavascriptBridgeBase 的命名也可以体现出其是作为整座“桥梁”桥墩一般的存在，我们还是按照老规矩先看一下 WebViewJavascriptBridgeBase.h 暴露的信息，好对其有一个整体的印象：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBResponseCallback)(<span class="type">id</span> responseData); <span class="comment">// 回调 block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBHandler)(<span class="type">id</span> data, WVJBResponseCallback responseCallback); <span class="comment">// 注册的 Handler block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> WVJBMessage; <span class="comment">// 消息类型 - 字典</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebViewJavascriptBridgeBaseDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span>*) _evaluateJavascript:(<span class="built_in">NSString</span>*)javascriptCommand;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridgeBase</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate; <span class="comment">// 代理，指向接口层类，用以给对应接口绑定的 WebView 组件发送执行 JS 消息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>* startupMessageQueue; <span class="comment">// 启动消息队列，可以理解为存放 WVJBMessage</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* responseCallbacks; <span class="comment">// 回调 blocks 字典，存放 WVJBResponseCallback 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* messageHandlers; <span class="comment">// 已注册的 handlers 字典，存放 WVJBHandler 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) WVJBHandler messageHandler; <span class="comment">// 没卵用</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line">- (<span class="type">void</span>)reset; <span class="comment">// 对应 WKJSBridge 的 reset 接口</span></span><br><span class="line">- (<span class="type">void</span>)sendData:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 发送消息，入参依次是参数，回调 block，对应 JS 端注册的 HandlerName</span></span><br><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString; <span class="comment">// 刷新消息队列，核心代码</span></span><br><span class="line">- (<span class="type">void</span>)injectJavascriptFile; <span class="comment">// 注入 JS</span></span><br><span class="line">- (<span class="type">BOOL</span>)isWebViewJavascriptBridgeURL:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 判定是否为 WebViewJavascriptBridgeURL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isQueueMessageURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为队列消息 URL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isBridgeLoadedURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为 bridge 载入 URL</span></span><br><span class="line">- (<span class="type">void</span>)logUnkownMessage:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 打印收到未知消息信息</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptCheckCommand; <span class="comment">// JS bridge 检测命令</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand; <span class="comment">// JS bridge 获取查询命令</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 安全时长以获取发送消息速度提升，不建议使用，理由见上文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>嘛~ 从 .h 文件中我们可以看到整个 WebViewJavascriptBridgeBase 所暴露出来的信息，属性层面上需要对以下 4 个属性加深印象，之后分析实现的过程中会带入这些属性：</p>
<ul>
<li><code>id &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate</code> 代理，可以通过代理让当前 bridge 绑定的 WebView 组件执行 JS 代码</li>
<li><code>NSMutableArray* startupMessageQueue;</code> 启动消息队列，存放 Obj-C 发送给 JS 的消息（可以理解为存放 <code>WVJBMessage</code> 类型）</li>
<li><code>NSMutableDictionary* responseCallbacks;</code> 回调 blocks 字典，存放 <code>WVJBResponseCallback</code> 类型的 block</li>
<li><code>NSMutableDictionary* messageHandlers;</code> Obj-C 端已注册的 handlers 字典，存放 <code>WVJBHandler</code> 类型的 block</li>
</ul>
<p>Emmmmm…接口层面看一下注释就好了，后面分析实现的时候会捎带讲解一些接口，剩下一些跟实现无关的接口内容感兴趣的同学推荐自己扒源码哈。</p>
<p>我们在对 WebViewJavascriptBridgeBase 整体有了一个初始印象之后就可以自己写一个页面，简单的嵌入一些 JS 跑一遍流程，在中间下断点扒源码，这样我们对于 Native 与 JS 的交互流程就可以一清二楚了。</p>
<p><strong>下面模拟一遍 JS 通过 WebViewJavascriptBridge 调用 Native 功能的流程分析 WebViewJavascriptBridgeBase 的相关实现</strong>（考虑现在的时间点决定以 WKWebView 为例讲解，即针对 WKWebViewJavascriptBridge 源码讲解）：</p>
<h3 id="1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码"><a href="#1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码" class="headerlink" title="1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码"></a>1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码</h3><p>上文说到 WebViewJavascriptBridge 的实现其实本质上是利用了我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，那么我们就从监听假 Request 开始讲起吧。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKNavigationDelegate 协议方法，用于监听 Request 并决定是否允许导航</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="comment">// webView 校验</span></span><br><span class="line">    <span class="keyword">if</span> (webView != _webView) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_webViewDelegate) strongDelegate = _webViewDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">if</span> ([_base isWebViewJavascriptBridgeURL:url]) &#123; <span class="comment">// 判定 WebViewJavascriptBridgeURL</span></span><br><span class="line">        <span class="keyword">if</span> ([_base isBridgeLoadedURL:url]) &#123; <span class="comment">// 判定 BridgeLoadedURL</span></span><br><span class="line">            <span class="comment">// 注入 JS 代码</span></span><br><span class="line">            [_base injectJavascriptFile];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([_base isQueueMessageURL:url]) &#123; <span class="comment">// 判定 QueueMessageURL</span></span><br><span class="line">            <span class="comment">// 刷新消息队列</span></span><br><span class="line">            [<span class="keyword">self</span> <span class="built_in">WKFlushMessageQueue</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录未知 bridge msg 日志</span></span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 _webViewDelegate 对应的代理方法</span></span><br><span class="line">    <span class="keyword">if</span> (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:<span class="keyword">@selector</span>(webView:decidePolicyForNavigationAction:decisionHandler:)]) &#123;</span><br><span class="line">        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 之前说过 WebViewJavascriptBridge 会 hook 绑定的 WebView 的代理方法，这一点 WKWebViewJavascriptBridge 也一样，在加入自己的代码之后会判断是否有 <code>_webViewDelegate</code> 响应这个代理方法，如果有则调用。</p>
</blockquote>
<p>我们还是把注意力放到注释中核心代码的位置，里面会先判断当前 url 是否为 bridge url：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kOldProtocolScheme @<span class="string">&quot;wvjbscheme&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kNewProtocolScheme @<span class="string">&quot;https&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kQueueHasMessage   @<span class="string">&quot;__wvjb_queue_message__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kBridgeLoaded      @<span class="string">&quot;__bridge_loaded__&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 的使用方法中第 4 步明确指出要复制粘贴 <code>setupWebViewJavascriptBridge</code> 方法到前段 JS 中，我们先来看一下这段 JS 方法源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123; <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>); &#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123; <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback); &#125;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">	<span class="comment">// 创建一个 iframe</span></span><br><span class="line">	<span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	<span class="comment">// 设置 iframe 为不显示</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 的 src 置为 &#x27;https://__bridge_loaded__&#x27;</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&#x27;https://__bridge_loaded__&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 加入到 document.documentElement</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个不显示的 iframe 并将其 src 置为 <code>https://__bridge_loaded__</code>，与上文中 <code>kBridgeLoaded</code> 宏定义一致，即用于 <code>isBridgeLoadedURL:</code> 方法中判定当前 url 是否为 BridgeLoadedURL。</p>
<blockquote>
<p>Note: 假 Request 的发起有两种方式，-1:<code>location.href</code> -2:<code>iframe</code>。通过 <code>location.href</code> 有个问题，就是如果 JS 多次调用原生的方法也就是 <code>location.href</code> 的值多次变化，Native 端只能接受到最后一次请求，前面的请求会被忽略掉，所以这里 WebViewJavascriptBridge 选择使用 iframe，后面不再解释。</p>
</blockquote>
<p>因为加入了 src 为 <code>https://__bridge_loaded__</code> 的 iframe 元素，我们上面截获 url 的代理方法就会拿到一个 <code>https://__bridge_loaded__</code> 的 url，由于 https 满足判定 WebViewJavascriptBridgeURL，将会进入核心代码区域接着会被判定为 BridgeLoadedURL 执行注入 JS 代码的方法，即 <code>[_base injectJavascriptFile];</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)injectJavascriptFile &#123;</span><br><span class="line">    <span class="comment">// 获取到 WebViewJavascriptBridge_JS 的代码</span></span><br><span class="line">    <span class="built_in">NSString</span> *js = WebViewJavascriptBridge_js();</span><br><span class="line">    <span class="comment">// 将获取到的 js 通过代理方法注入到当前绑定的 WebView 组件</span></span><br><span class="line">    [<span class="keyword">self</span> _evaluateJavascript:js];</span><br><span class="line">    <span class="comment">// 如果当前已有消息队列则遍历并分发消息，之后清空消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.startupMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>* queue = <span class="keyword">self</span>.startupMessageQueue;</span><br><span class="line">        <span class="keyword">self</span>.startupMessageQueue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> queuedMessage <span class="keyword">in</span> queue) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _dispatchMessage:queuedMessage];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，第一步交互已完成。关于 WebViewJavascriptBridge_JS 内部的 JS 代码我们放到后面的章节解读，现在可以简单理解为 WebViewJavascriptBridge 在 JS 端的具体实现代码。</p>
<h3 id="2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？"><a href="#2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？" class="headerlink" title="2.JS 端调用 callHandler 方法之后 Native 端究竟是如何响应的？"></a>2.JS 端调用 <code>callHandler</code> 方法之后 Native 端究竟是如何响应的？</h3><p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 中指出 JS 端的操作方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize your app here */</span></span><br><span class="line"></span><br><span class="line">	bridge.<span class="title function_">registerHandler</span>(<span class="string">&#x27;JS Echo&#x27;</span>, <span class="keyword">function</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class="line">		<span class="title function_">responseCallback</span>(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	bridge.<span class="title function_">callHandler</span>(<span class="string">&#x27;ObjC Echo&#x27;</span>, &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;, <span class="keyword">function</span> <span class="title function_">responseCallback</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS received response:&quot;</span>, responseData)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们知道 JS 端调用 <code>setupWebViewJavascriptBridge</code> 方法会走我们刚才分析过的第一步，即监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码。那么当 JS 端调用 <code>bridge.callHandler</code> 时，Native 端究竟是如何做出响应的呢？这里我们需要先稍微解读一下之前注入的 WebViewJavascriptBridge_JS 中的 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		responseCallback = data;</span><br><span class="line">		data = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line"><span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">		responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">		message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">	&#125;</span><br><span class="line">	sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 JS 端的代码中有 <code>callHandler</code> 函数的实现，其内部将入参 <code>handlerName</code> 以及 <code>data</code> 以字典形式作为参数调用 <code>_doSend</code> 方法，我们看一下 <code>_doSend</code> 方法的实现：</p>
<ul>
<li><code>_doSend</code> 方法内部会先判断入参中是否有回调</li>
<li>如果有回调则根据规则生成 <code>callbackId</code> 并且将回调 block 保存到 <code>responseCallbacks</code> 字典（囧~ JS 不叫字典的，我是为了 iOS 读者看着方便），之后给消息也加入一个键值对保存刚才生成的 <code>callbackId</code></li>
<li>之后给 <code>sendMessageQueue</code> 队列加入 <code>message</code></li>
<li>将 <code>messagingIframe.src</code> 设置为 <code>https://__wvjb_queue_message__</code></li>
</ul>
<p>好，点到为止，对于 WebViewJavascriptBridge_JS 内的 JS 端其他源码我们放着后面看。注意这里加入了一个 src 为 <code>https://__wvjb_queue_message__</code> 的 <code>messagingIframe</code>，它也是一个不可见的 iframe。这样 Native 端会收到一个 url 为 <code>https://__wvjb_queue_message__</code> 的 request，回到第 1 步中获取到假的 request 之后会进行各项判定，这次会满足 <code>[_base isQueueMessageURL:url]</code> 的判定调用 Native 的 <code>WKFlushMessageQueue</code> 方法。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)<span class="built_in">WKFlushMessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 WebViewJavascriptBridge._fetchQueue(); 方法</span></span><br><span class="line">    [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(<span class="built_in">NSString</span>* result, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新消息列表</span></span><br><span class="line">        [_base flushMessageQueue:result];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;WebViewJavascriptBridge._fetchQueue();&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 Native 端会在刷新队列中调用 JS 端的 <code>WebViewJavascriptBridge._fetchQueue();</code> 方法，我们来看一下 JS 端此方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 将 sendMessageQueue 转为 JSON 格式</span></span><br><span class="line">	<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">	<span class="comment">// 重置 sendMessageQueue</span></span><br><span class="line">	sendMessageQueue = [];</span><br><span class="line">	<span class="comment">// 返回 JSON 格式的 </span></span><br><span class="line">	<span class="keyword">return</span> messageQueueString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会把当前 JS 端 <code>sendMessageQueue</code> 消息队列以 JSON 的形式返回，而 Native 端会调用 <code>[_base flushMessageQueue:result];</code> 将拿到的 JSON 形式消息队列作为参数调用 <code>flushMessageQueue:</code> 方法，这个方法是整个框架 Native 端的精华所在，就是稍微有点长（笑）。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString &#123;</span><br><span class="line">    <span class="comment">// 校验 messageQueueString</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString == <span class="literal">nil</span> || messageQueueString.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 messageQueueString 通过 NSJSONSerialization 解为 messages 并遍历</span></span><br><span class="line">    <span class="type">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    <span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">        <span class="comment">// 类型校验</span></span><br><span class="line">        <span class="keyword">if</span> (![message isKindOfClass:[WVJBMessage <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;</span>, [message <span class="keyword">class</span>], message);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> _log:<span class="string">@&quot;RCVD&quot;</span> json:message];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试取 responseId，如取到则表明是回调，从 _responseCallbacks 取匹配的回调 block 执行</span></span><br><span class="line">        <span class="built_in">NSString</span>* responseId = message[<span class="string">@&quot;responseId&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (responseId) &#123; <span class="comment">// 取到 responseId</span></span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[<span class="string">@&quot;responseData&quot;</span>]);</span><br><span class="line">            [<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 responseId，则表明是正常的 JS callHandler 调用 iOS</span></span><br><span class="line">            WVJBResponseCallback responseCallback = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 尝试取 callbackId，示例 cb_1_1512035076293</span></span><br><span class="line">            <span class="comment">// 对应 JS 代码 var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime();</span></span><br><span class="line">            <span class="built_in">NSString</span>* callbackId = message[<span class="string">@&quot;callbackId&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (callbackId) &#123; <span class="comment">// 取到 callbackId，表示 js 端希望在调用 iOS native 代码后有回调</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> responseData) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (responseData == <span class="literal">nil</span>) &#123;</span><br><span class="line">                        responseData = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将 callbackId 作为 msg 的 responseId 并设置 responseData，执行 _queueMessage</span></span><br><span class="line">                    WVJBMessage* msg = @&#123; <span class="string">@&quot;responseId&quot;</span>:callbackId, <span class="string">@&quot;responseData&quot;</span>:responseData &#125;;</span><br><span class="line">                    <span class="comment">// _queueMessage 函数主要是把 msg 转为 JSON 格式，内含 responseId = callbackId</span></span><br><span class="line">                    <span class="comment">// JS 端调用 WebViewJavascriptBridge._handleMessageFromObjC(&#x27;msg_JSON&#x27;); 其中 &#x27;msg_JSON&#x27; 就是 JSON 格式的 msg</span></span><br><span class="line">                    [<span class="keyword">self</span> _queueMessage:msg];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 callbackId</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> ignoreResponseData) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试以 handlerName 获取 iOS 端之前注册过的 handler</span></span><br><span class="line">            WVJBHandler handler = <span class="keyword">self</span>.messageHandlers[message[<span class="string">@&quot;handlerName&quot;</span>]];</span><br><span class="line">            <span class="keyword">if</span> (!handler) &#123; <span class="comment">// 没注册过，则跳过此 msg</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;</span>, message);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用对应的 handler，以 message[@&quot;data&quot;] 为入参，以 responseCallback 为回调</span></span><br><span class="line">            handler(message[<span class="string">@&quot;data&quot;</span>], responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ <code>flushMessageQueue:</code> 方法作为整个 Native 端的核心，有点长是可以理解的。我们简单理一下它的实现思路：</p>
<ul>
<li>入参校验</li>
<li>将 JSON 形式的入参转换为 Native 对象，即消息队列，这里面消息类型是之前定义过的 WVJBMessage，即字典</li>
<li>如果消息中含有 “responseId” 则表明是之前 Native 调用的 JS 方法回调过来的消息（因为 JS 端和 Native 端实现逻辑是对等的，所以这个地方不明白的可以参考下面的分析）</li>
<li>如果消息中不含 “responseId” 则表明是 JS 端通过 <code>callHandler</code> 函数正常调用 Native 端过来的消息</li>
<li>尝试获取消息中的 “callbackId”，如果 JS 本次消息需要 Native 响应之后回调才会有这个键值，具体参见上文中 JS 端 <code>_doSend</code> 部分源码分析。如取到 “callbackId” 则需生成一个回调 block，回调 block 内部将 “callbackId” 作为 msg 的 “responseId” 执行 <code>_queueMessage</code> 将消息发送给 JS 端（JS 端处理消息逻辑与 Native 端一致，所以上面使用 “responseId” 判断当前消息是否为回调方法传递过来的消息是很容易理解的）</li>
<li>尝试以消息中的 “handlerName” 从 <code>messageHandlers</code>（上文提到过，是保存 Native 端注册过的 handler 的字典）取到对应的 handler block，如果取到则执行代码块，否则打印错误日志</li>
</ul>
<blockquote>
<p>Note: 这个消息处理的方法虽然长，但是逻辑清晰，而且有效的解决了 JS 与 Native 相互调用的过程中参数传递的问题（包括回调），此外 JS 端的消息处理逻辑与 Native 端保持一致，实现了逻辑对称，非常值得我们学习。</p>
</blockquote>
<h2 id="WebViewJavascriptBridge-JS-Native-调用-JS-实现解读"><a href="#WebViewJavascriptBridge-JS-Native-调用-JS-实现解读" class="headerlink" title="WebViewJavascriptBridge_JS - Native 调用 JS 实现解读"></a>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</h2><img src="/webview_javascript_bridge/javascript.jpg" class="">
<p>Emmmmm…这一章节主要讲 JS 端注入的代码，即 WebViewJavascriptBridge_JS 中的 JS 源码。由于我没做过前段，能力不足，水平有限，可能有谬误希望各位读者发现的话及时指正，感激不尽。预警，由于 JS 端和上文分析过的 Native 端逻辑对称且上文已经分析过部分 JS 端的函数，所以下面的 JS 源码没有另做拆分，为避免被大段 JS 代码糊脸不感兴趣的同学可以直接看代码后面的总结。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// window.WebViewJavascriptBridge 校验，避免重复</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒加载 window.onerror，用于打印 error 日志</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">onerror</span>) &#123;</span><br><span class="line">		<span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg, url, line</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: ERROR:&quot;</span> + msg + <span class="string">&quot;@&quot;</span> + url + <span class="string">&quot;:&quot;</span> + line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// window.WebViewJavascriptBridge 声明</span></span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span> = &#123;</span><br><span class="line">		<span class="attr">registerHandler</span>: registerHandler,</span><br><span class="line">		<span class="attr">callHandler</span>: callHandler,</span><br><span class="line">		<span class="attr">disableJavscriptAlertBoxSafetyTimeout</span>: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line">		<span class="attr">_fetchQueue</span>: _fetchQueue,</span><br><span class="line">		<span class="attr">_handleMessageFromObjC</span>: _handleMessageFromObjC</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量声明</span></span><br><span class="line">	<span class="keyword">var</span> messagingIframe; <span class="comment">// 消息 iframe</span></span><br><span class="line">	<span class="keyword">var</span> sendMessageQueue = []; <span class="comment">// 发送消息队列</span></span><br><span class="line">	<span class="keyword">var</span> messageHandlers = &#123;&#125;; <span class="comment">// JS 端注册的消息处理 handlers 字典（囧，JS 其实叫对象）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> responseCallbacks = &#123;&#125;; <span class="comment">// JS 端存放回调的字典</span></span><br><span class="line">	<span class="keyword">var</span> uniqueId = <span class="number">1</span>; <span class="comment">// 唯一标示，用于回调时生成 callbackId</span></span><br><span class="line">	<span class="keyword">var</span> dispatchMessagesWithTimeoutSafety = <span class="literal">true</span>; <span class="comment">// 默认启用安全时长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过禁用 AlertBoxSafetyTimeout 来提速网桥消息传递</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">disableJavscriptAlertBoxSafetyTimeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">		dispatchMessagesWithTimeoutSafety = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 iOS 逻辑，注册 handler 其实是往 messageHandlers 字典中插入对应 name 的 block</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">registerHandler</span>(<span class="params">handlerName, handler</span>) &#123;</span><br><span class="line">		messageHandlers[handlerName] = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如果参数只有两个且第二个参数类型为 function，则表示没有参数传递，即 data 为空</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			responseCallback = data;</span><br><span class="line">			data = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 handlerName 和 data 作为 msg 对象参数调用 _doSend 函数</span></span><br><span class="line">		<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// _doSend 向 Native 端发送消息</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line">		<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">			<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">			responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">			message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line">		sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">		messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">	    <span class="comment">// 内部将发送消息队列 sendMessageQueue 转为 JSON 格式并返回</span></span><br><span class="line">		<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">		sendMessageQueue = [];</span><br><span class="line">		<span class="keyword">return</span> messageQueueString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iOS 端 _dispatchMessage 函数会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_handleMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">	    <span class="comment">// 调度从 Native 端获取到的消息</span></span><br><span class="line">        <span class="title function_">_dispatchMessageFromObjC</span>(messageJSON);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心代码，调度从 Native 端获取到的消息，逻辑与 Native 端一致</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_dispatchMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">		<span class="comment">// 判断有没有禁用 AlertBoxSafetyTimeout，最终会调用 _doDispatchMessageFromObjC 函数</span></span><br><span class="line">		<span class="keyword">if</span> (dispatchMessagesWithTimeoutSafety) &#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(_doDispatchMessageFromObjC);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			 <span class="title function_">_doDispatchMessageFromObjC</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 解析 msgJSON 得到 msg</span></span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">_doDispatchMessageFromObjC</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">			<span class="keyword">var</span> messageHandler;</span><br><span class="line">			<span class="keyword">var</span> responseCallback;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果有 responseId，则说明是回调，取对应的 responseCallback 执行，之后释放</span></span><br><span class="line">			<span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">				responseCallback = responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">				<span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="title function_">responseCallback</span>(message.<span class="property">responseData</span>);</span><br><span class="line">				<span class="keyword">delete</span> responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 responseId，则表示正常的 iOS call handler 调用 js</span></span><br><span class="line">				<span class="comment">// 如 msg 包含 callbackId，说明 iOS 端需要回调，初始化对应的 responseCallback</span></span><br><span class="line">				<span class="keyword">if</span> (message.<span class="property">callbackId</span>) &#123;</span><br><span class="line">					<span class="keyword">var</span> callbackResponseId = message.<span class="property">callbackId</span>;</span><br><span class="line">					responseCallback = <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">						<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:message.<span class="property">handlerName</span>, <span class="attr">responseId</span>:callbackResponseId, <span class="attr">responseData</span>:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 从 messageHandlers 拿到对应的 handler 执行</span></span><br><span class="line">				<span class="keyword">var</span> handler = messageHandlers[message.<span class="property">handlerName</span>];</span><br><span class="line">				<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">				    <span class="comment">// 如未取到对应的 handler 则打印错误日志</span></span><br><span class="line">					<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;</span>, message);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="title function_">handler</span>(message.<span class="property">data</span>, responseCallback);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// messagingIframe 的声明，类型 iframe，样式不可见，src 设置</span></span><br><span class="line">	messagingIframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	messagingIframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	<span class="comment">// messagingIframe 加入 document.documentElement 中</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(messagingIframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disableJavscriptAlertBoxSafetyTimeout handler，Native 可以通过禁用 AlertBox 的安全时长来加速桥接消息</span></span><br><span class="line">	<span class="title function_">registerHandler</span>(<span class="string">&quot;_disableJavascriptAlertBoxSafetyTimeout&quot;</span>, disableJavscriptAlertBoxSafetyTimeout);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">setTimeout</span>(_callWVJBCallbacks, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_callWVJBCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbacks = <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">			callbacks[i](<span class="title class_">WebViewJavascriptBridge</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS 端和 Native 端逻辑一致，上面的代码已经加入了详细的中文注释，上文在对于“WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析”章节的分析过程中为了走通整个调用的逻辑已经对部分 JS 端代码进行了分析，这里我们简单的梳理一下 JS 端核心代码 <code>_doDispatchMessageFromObjC</code> 函数的逻辑：</p>
<ul>
<li>将 messageJSON 使用 JSON 解析出来</li>
<li>尝试取解析到的消息中的 responseId，如果有取到则说明是 Native 端响应 JS 端之后通过回调向 JS 端发出的消息，用 responseId 取 responseCallbacks 中对应的回调响应 block，找到后执行该 block 之后删除</li>
<li>如果没取到 responseId 则表示这条消息是 Native 端通过 <code>callHandler:data:responseCallback:</code> 正常调用 JS 注册的 handler 发送过来的消息（这里的正常是针对回调而言）</li>
<li>如果当前的消息有 callbackId 则表明 Native 端需要 JS 端响应本次消息之后回调反馈，生成一个 responseCallback 作为回调 block (JS 端是 function) ，其内部使用 <code>_doSend</code> 方法传递一个带有 responseId 的消息给 Native 端，表明此条消息是之前的回调消息</li>
<li>最后按照解析到的消息中 handlerName 从 messageHandlers，即 JS 端注册过的 handlers 中找到与名称对应的处理函数执行，如果没找到则打印附带相关信息的错误日志</li>
</ul>
<p>嘛~ 对比一下 Native 端的核心代码 <code>flushMessageQueue:</code> 看一下，很容易发现两端的处理实现是逻辑对称的。</p>
<h2 id="WebViewJavascriptBridge-的“桥梁美学”"><a href="#WebViewJavascriptBridge-的“桥梁美学”" class="headerlink" title="WebViewJavascriptBridge 的“桥梁美学”"></a>WebViewJavascriptBridge 的“桥梁美学”</h2><img src="/webview_javascript_bridge/bridge_beautiful.jpg" class="">
<p>在总结 WebViewJavascriptBridge 的“桥梁美学”之前请再回顾一下 WebViewJavascriptBridge 的工作流：</p>
<ul>
<li>JS 端加入 src 为 <code>https://__bridge_loaded__</code> 的 iframe</li>
<li>Native 端检测到 Request，检测如果是 <code>__bridge_loaded__</code> 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码</li>
<li>注入代码成功之后会加入一个 messagingIframe，其 src 为 <code>https://__wvjb_queue_message__</code></li>
<li>之后不论是 Native 端还是 JS 端都可以通过 <code>registerHandler</code> 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 <code>callHandler</code> 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）</li>
</ul>
<p>嘛~ 所以我们很容易列举出 WebViewJavascriptBridge 所具有的“美学”：</p>
<ul>
<li>隐性适配</li>
<li>接口对等</li>
<li>逻辑对称</li>
</ul>
<p>我们结合本文展开来说一下上面的“美学”的具体实现。</p>
<h3 id="隐性适配"><a href="#隐性适配" class="headerlink" title="隐性适配"></a>隐性适配</h3><p>WebViewJavascriptBridge 主要是作为 Mac OS X 和 iOS 端（Native 端）与 JS 端相互通信，互相调用的桥梁。对于 Mac OS X 和 iOS 两种平台包含的三种 WebView 功能组件而言，WebViewJavascriptBridge 做了隐性适配，即仅用一套代码即可绑定不同平台的 WebView 组件实现同样功能的 JS 通信功能，这一点非常方便。</p>
<h3 id="接口对等"><a href="#接口对等" class="headerlink" title="接口对等"></a>接口对等</h3><p>WebViewJavascriptBridge 对于 JS 端和 Native 端设计了对等的接口，不论是 JS 端还是 Native 端，注册本端的响应处理都是用 <code>registerHandler</code> 接口，调用另一端（给另一端发消息）都是用 <code>callHandler</code> 接口。</p>
<p>这样做是非常合理的，因为不论是 JS 端还是 Native 端，作为通信的双方就通信本身而言是处于对等的地位的。这就好比一座大桥连接两块陆地，两地用大桥相互运输货物并接收资源，两块陆地在大桥的运输使用过程中逻辑上也是地位对等的。</p>
<h3 id="逻辑对称"><a href="#逻辑对称" class="headerlink" title="逻辑对称"></a>逻辑对称</h3><p>WebViewJavascriptBridge 在 JS 端和 Native 端对发送过来的消息有着相同逻辑的处理实现，如果考虑到收发双方的身份则可以把逻辑相同看做逻辑对称。</p>
<p>这种实现方式依旧非常合理，被桥连接的两块大陆在装货上桥和下桥卸货这两处逻辑上就应该是对称的。</p>
<p>嘛~ 说到这里就不得不祭出一个词来形容 WebViewJavascriptBridge 了，这个词就是<strong>优雅</strong>（笑）。当大家结合 WebViewJavascriptBridge 源码阅读本文之后不难发现其整个架构和设计思想跟现实桥梁设计中很多设计思想不谋而合，比如桥一般会分为左右桥幅，而左右幅桥一般只有一条线路中心线，即一个前进方向，用于桥上单一方向的资源传输，左右桥幅在功能上对等。</p>
<h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><ul>
<li>文章系统分析了 WebViewJavascriptBridge 源码，希望各位读者能够在阅读本文之后对 WebViewJavascriptBridge 的架构有一个整体认识。</li>
<li>文章对 WebViewJavascriptBridge 在 JS 端和 Native 端的消息处理实现做了深入剖析，希望可以对各位读者这部分源码的理解提供一些微薄的帮助。</li>
<li>总结了 WebViewJavascriptBridge 作为一个 JSBridge 框架所具有的优势，即文中所指的“桥梁美学”，期望可以对大家以后自己封装一个 JSBridge 提供思路，抛砖引玉。</li>
</ul>
<p>Emmmmm…不过需要注意的是 WebViewJavascriptBridge 仅仅是作为 JSBridge 层用于提供 JS 和 Native 之间相互传递消息的基础支持的。如果想要封装自己项目中的 WebView 组件还需要另外实现 HTTP cookie 注入，自定义 User-Agent，白名单或者权限校验等功能，更进一步还需要对 WebView 组件进行初始化速度，页面渲染速度以及页面缓存策略的优化。我之后<strong>也许可能大概应该</strong>会写一篇文章分享一下自己封装 WebView 组件时踩到的一些坑以及经验，因为自己水平有限…所以也可能不会写（笑）。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yyimage/">
      YYImage 设计思路，实现细节剖析
    </a>
  </h2>
  
  <time>
    12月 10, 2017
  </time>
  <section class="content">
	  <img src="/yyimage/yyimage_h.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片的历史早于文字，是最原始的信息传递方式。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AD%E6%9B%B8">六书</a>中的象形文构造思想就是用文字的线条或笔画，把要表达物体的外形特征，具体地勾画出来。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%B1%E6%85%8E">许慎</a>《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%B4%E6%96%87%E8%A7%A3%E5%AD%97">说文解字</a>》云：“象形者，画成其物，随体诘诎，日、月是也。”</p>
</blockquote>
<p>现代社会的信息传递中，图片仍然是不可或缺的一环，不论是报纸、杂志、漫画等实体刊物还是生活中超市地铁广告活动，都会有专门的配图抓人眼球。</p>
<p>在移动端 App 中，图片通常占据着重要的视觉空间，作为 iOS 开发来讲，所有的 App 都有精心设计的 AppIcon 陈列在 SpringBoard 中，打开任意一款主流 App 都少不了琳琅满目的图片搭配。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage">YYImage</a> 是一款功能强大的 iOS 图像框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一），支持目前市场上所有主流的图片格式的显示与编/解码，并且提供高效的动态内存缓存管理，以保证高性能低内存的动画播放。</p>
<p>YYKit 的作者 <a target="_blank" rel="noopener" href="https://weibo.com/239801242">@ibireme</a> 对于 iOS 图片处理写有两篇非常不错的文章，推荐各位读者在阅读本文之前查阅。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/ios_image_tips/">iOS 处理图片的一些小 Tip</a></li>
</ul>
<p>本文引用代码均为 YYImage v1.0.4 版本源码，文章旨在剖析 YYImage 的架构思想以及设计思路并对笔者在阅读源码过程中发现的有趣实现细节探究分享，不会逐行翻译源码，建议对源码实现感兴趣的同学结合 YYImage v1.0.4 版本源码食用本文~</p>
<img src="/yyimage/xiaomai.gif" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYImage 简介</li>
<li>YYImage, YYFrameImage, YYSpriteSheetImage</li>
<li>YYAnimatedImageView</li>
<li>YYImageCoder</li>
<li>总结</li>
<li>扩展阅读</li>
</ul>
<h2 id="YYImage-简介"><a href="#YYImage-简介" class="headerlink" title="YYImage 简介"></a>YYImage 简介</h2><img src="/yyimage/yyimage.jpg" class="">
<p>YYImage 是一款功能强大的 iOS 图像框架，支持当前市场主流的静/动态图像编/解码与动态图像的动画播放显示，其具有以下特性：</p>
<ul>
<li>支持以下类型动画图像的播放/编码/解码: WebP, APNG, GIF。</li>
<li>支持以下类型静态图像的显示/编码/解码: WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。</li>
<li>支持以下类型图片的渐进式/逐行扫描/隔行扫描解码: PNG, GIF, JPEG, BMP。</li>
<li>支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。</li>
<li>高效的动态内存缓存管理，以保证高性能低内存的动画播放。</li>
<li>完全兼容 UIImage 和 UIImageView，使用方便。</li>
<li>保留可扩展的接口，以支持自定义动画。</li>
<li>每个类和方法都有完善的文档注释。</li>
</ul>
<h3 id="YYImage-架构分析"><a href="#YYImage-架构分析" class="headerlink" title="YYImage 架构分析"></a>YYImage 架构分析</h3><p>通过 YYImage 源码可以按照其与 UIKit 的对应关系划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">UIKit</th>
<th style="text-align:center">YYImage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图像层</td>
<td style="text-align:center">UIImage</td>
<td style="text-align:center">YYImage, YYFrameImage, YYSpriteSheetImage</td>
</tr>
<tr>
<td style="text-align:center">视图层</td>
<td style="text-align:center">UIImageView</td>
<td style="text-align:center">YYAnimatedImageView</td>
</tr>
<tr>
<td style="text-align:center">编/解码层</td>
<td style="text-align:center">ImageIO.framework</td>
<td style="text-align:center">YYImageCoder</td>
</tr>
</tbody>
</table>
<ul>
<li>图像层，把不同类型的图像信息封装成类并提供初始化和其他便捷接口。</li>
<li>视图层，负责图像层内容的显示（包含动态图像的动画播放）工作。</li>
<li>编/解码层，提供图像底层支持，使整个框架得以支持市场主流的图片格式。</li>
</ul>
<blockquote>
<p>Note: <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/imageio">ImageIO.framework</a> 是 iOS 底层实现的图片编/解码库，负责管理颜色和访问图像元数据。其内部的实现使用了第三方编/解码库（如 libpng 等）并对第三方库进行调整优化。除此之外，iOS 还专门针对 JPEG 的编/解码开发了 AppleJPEG.framework，实现了性能更高的硬编码和硬解码。</p>
</blockquote>
<img src="/yyimage/yyimage_struct.png" class="">
<h2 id="YYImage-YYFrameImage-YYSpriteSheetImage"><a href="#YYImage-YYFrameImage-YYSpriteSheetImage" class="headerlink" title="YYImage, YYFrameImage, YYSpriteSheetImage"></a>YYImage, YYFrameImage, YYSpriteSheetImage</h2><p>先来介绍 YYImage 库中图像层的三个类，它们分别是：</p>
<ul>
<li>YYImage</li>
<li>YYFrameImage</li>
<li>YYSpriteSheetImage</li>
</ul>
<h3 id="YYImage"><a href="#YYImage" class="headerlink" title="YYImage"></a>YYImage</h3><p>YYImage 是一个显示动态图片数据的高级别类，其继承自 UIImage 并对 UIImage 做了扩展以支持 WebP，APNG 和 GIF 格式的图片解码。它还支持 NSCoding 协议可以对多帧图像数据进行 archive 和 unarchive 操作。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageNamed:(<span class="built_in">NSString</span> *)name; <span class="comment">// 不同于 UIImage，此方法无缓存</span></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType animatedImageType; <span class="comment">// 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *animatedImageData; <span class="comment">// 动态图像的元数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> animatedImageMemorySize; <span class="comment">// 多帧图像内存占用量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> preloadAllAnimatedImageFrames; <span class="comment">// 预加载所有帧（到内存）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYImage 提供了类似 UIImage 的初始化方法，公开了一些属性便于我们检测和控制其内存使用。</p>
<p>值得一提的是 YYImage 的 <code>imageNamed:</code> 初始化方法并不支持缓存。因为其 <code>imageNamed:</code> 内部实现并不同于 UIImage 的 <code>imageNamed:</code> 方法，YYImage 中的实现流程如下：</p>
<ul>
<li>推测出给定图像资源路径</li>
<li>拿到路径中的图像数据（NSData）</li>
<li>调用 YYImage 的 <code>initWithData:scale:</code> 方法初始化</li>
</ul>
<p>YYImage 的私有变量部分也比较简单，相信大家可以根据上面暴露出的属性和接口猜得到哈。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImage</span> </span>&#123;</span><br><span class="line">    YYImageDecoder *_decoder; <span class="comment">// 解码器</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_preloadedFrames; <span class="comment">// 预加载的图像帧</span></span><br><span class="line">    dispatch_semaphore_t _preloadedLock; <span class="comment">// 预加载锁</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _bytesPerFrame; <span class="comment">// 内存占用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部有一把锁 <code>dispatch_semaphore_t</code>，我们知道 <code>dispatch_semaphore_t</code> 当信号量为 1 时可以当做锁来使用，在不阻塞时其作为锁的效率非常高。这里使用 <code>_preloadedLock</code> 的主要目的是保证 <code>_preloadedFrames</code> 的读写，由于 <code>_preloadedFrames</code> 的读写过程是在内存中完成的，操作耗时不会太多，所以不会长时间阻塞，这种情况使用 <code>dispatch_semaphore_t</code> 非常合适。</p>
<p>嘛~ <code>_preloadedFrames</code> 对应 <code>preloadAllAnimatedImageFrames</code> 属性，开启预加载所有帧到内存的话，<code>_preloadedFrames</code> 作为一个数组会保存所有帧的图像。<code>_bytesPerFrame</code> 则对应 <code>animatedImageMemorySize</code> 属性，在初始化 YYImage 时，如果帧总数超过 1 则会计算 <code>_bytesPerFrame</code> 的大小。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decoder.frameCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    _decoder = decoder;</span><br><span class="line">    _bytesPerFrame = <span class="built_in">CGImageGetBytesPerRow</span>(image.CGImage) * <span class="built_in">CGImageGetHeight</span>(image.CGImage);</span><br><span class="line">    _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 YYImage 中还有一些实现也比较有趣，比如 <code>animatedImageDurationAtIndex:</code> 的实现中如果取到 &lt;= 10 ms 的时长会替换为 100 ms，并在 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImage.m#L246">注释</a> 中解释了为什么（一定要点进去看啊，笑~）。</p>
<h3 id="YYFrameImage"><a href="#YYFrameImage" class="headerlink" title="YYFrameImage"></a>YYFrameImage</h3><p>YYFrameImage 是专门用来显示基于帧的动画图像类，其也是 UIImage 的子类。YYFrameImage 仅支持系统图片格式例如 png 和 jpeg。</p>
<blockquote>
<p>Note: 使用 YYFrameImage 显示动画图像同样要基于 YYAnimatedImageView 播放。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYFrameImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                           oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                             frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                               oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                                 frameDurations:(<span class="built_in">NSArray</span> *)frameDurations</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYFrameImage 可以把静态图片类型如 png 和 jpeg 格式的静态图像用帧切换的方式以动态图片的形式显示，并且提供了 4 个常用的初始化方法方便我们使用。</p>
<p>YYFrameImage 内部有一些基本的变量分别对应于其暴露的 4 个常用初始化接口：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYFrameImage</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _loopCount;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _oneFrameBytes;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imagePaths;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imageDatas;</span><br><span class="line">    <span class="built_in">NSArray</span> *_frameDurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YYFrameImage 的实现代码非常简单，初始化方法大致可以分为以下步骤：</p>
<ul>
<li>入参校验</li>
<li>根据入参取到首张图片</li>
<li>用首图初始化 <code>_oneFrameBytes</code> ，如入参初始化 <code>_imageDatas</code> ，<code>_frameDurations</code> 和 <code>_loopCount</code></li>
<li>用 <code>UIImage</code> 的 <code>initWithCGImage:scale:orientation:</code> 初始化并返回初始化结果</li>
</ul>
<h3 id="YYSpriteSheetImage"><a href="#YYSpriteSheetImage" class="headerlink" title="YYSpriteSheetImage"></a>YYSpriteSheetImage</h3><img src="/yyimage/ss_wukong.png" class="">
<p>YYSpriteSheetImage 是用来做 Spritesheet 动画显示的图像类，它也是 UIImage 的子类。</p>
<p>关于 Spritesheet 可能做过游戏开发或者以前鼓捣过简单网页游戏 Demo 的同学会很熟悉，其动画原理是把一个动画过程分解为多个动画帧，按照顺序将这些动画帧排布在一张大的画布中，播放动画时只需要按照每一帧图像的尺寸大小以及对应索引去画布中提取对应的帧替换显示以达到人眼判定动画的效果，点击 <a target="_blank" rel="noopener" href="https://gamedevelopment.tutsplus.com/tutorials/an-introduction-to-spritesheet-animation--gamedev-13099"><br>An Introduction to Spritesheet Animation</a> 或者 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/what-is-a-sprite-sheet">What is a sprite sheet?</a> 了解更多关于 Spritesheet 动画的信息。</p>
<blockquote>
<p>Note: 关于 SpriteSheet 素材的制作有一款工具 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/sprite-sheet-maker">SpriteSheetMaker</a> 推荐使用。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYSpriteSheetImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方法，这个第一次接触 Spritesheet 的同学可能会觉得比较繁琐</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithSpriteSheetImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                     contentRects:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)contentRects</span><br><span class="line">                                   frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                        loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *contentRects; <span class="comment">// 帧位置信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *frameDurations; <span class="comment">// 帧持续时长</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount; <span class="comment">// 循环数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引找到对应帧 CALayer 的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)contentsRectForCALayerAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其中初始化方法的入参为 SpriteSheet 画布（包含所有动画帧的大图）image，每一帧的位置 contentRects，每一帧对应的持续显示时间 frameDurations，循环次数 loopCount，初始化示例在 YYImage 源文件 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYSpriteSheetImage.h#L32">YYSpriteSheetImage.h</a> 注释中有写。</p>
<blockquote>
<p>Note: 下文中要讲的 YYAnimatedImageView 中定义了 YYAnimatedImage 协议，这个协议中有一个可选方法 <code>animatedImageContentsRectAtIndex:</code> 就是为 YYSpriteSheetImage 量身打造的。</p>
</blockquote>
<p>这里需要提一下 <code>contentsRectForCALayerAtIndex:</code> 接口会根据索引找到对应帧的 CALayer 位置，该接口返回一个由 0.0~1.0 之间的数值组成的图层定位 LayerRect，如果在查找位置过程中发现异常则返回 CGRectMake(0, 0, 1, 1)，其内部实现大体步骤：</p>
<ul>
<li>校验入参索引是否超过 SpriteSheet 分割帧总数，超过返回 CGRectMake(0, 0, 1, 1)</li>
<li>没超过则通过 YYAnimatedImage 协议的 <code>animatedImageContentsRectAtIndex:</code> 方法找到对应索引的真实位置 RealRect</li>
<li>通过真实位置 RealRect 与 SpriteSheet 画布的比算错 0.0~1.0 之间的值，得到指定索引帧的逻辑定位 LogicRect</li>
<li>通过 <code>CGRectIntersection</code> 方法计算逻辑定位 LogicRect 与 CGRectMake(0, 0, 1, 1) 的交集，确保逻辑定位没有超出画布的部分</li>
<li>将处理后的逻辑定位 LogicRect 作为图层定位 LayerRect 返回</li>
</ul>
<p>返回的 LayerRect 作为对应索引帧的画布内相对位置存在，结合画布就可以定位到对应帧图像的具体尺寸和位置。</p>
<h2 id="YYAnimatedImageView"><a href="#YYAnimatedImageView" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h2><img src="/yyimage/blood_wheel_eye.jpeg" class="">
<p>人眼中呈现的动画是由一幅幅内容连贯的图像以较短时间按顺序替换形成的，所以要显示动画只需要知道动画顺序中每一帧图像以及对应的显示时间等信息即可。YYImage 中对应于 UIImage 层级的内容（YYImage, YYFrameImage, YYSpriteSheetImage）在上文已经介绍过了，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImageView 是 YYImage 的重要组成，它是 UIImageView 的子类，负责 YYImage 图像层中不同的图像类的视图显示（包含动态图像的动画播放），其内部包含 YYAnimatedImage 协议以及 YYAnimatedImageView 自身两部分。</p>
<h3 id="YYAnimatedImage-协议"><a href="#YYAnimatedImage-协议" class="headerlink" title="YYAnimatedImage 协议"></a>YYAnimatedImage 协议</h3><p>上文提到不论是 YYImage, YYFrameImage, YYSpriteSheetImage 还是以后可能会扩展的图像类，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImage 协议就是在不影响原来图像类的情况下把不同图像类之间的共性找出来（求同存异？笑），以统一化的接口将人眼动画呈现所需的基本信息输出给 YYAnimatedImageView 使用的协议。</p>
<blockquote>
<p>Note: 作为图像类须遵循 YYAnimatedImage 协议以便可以使用 YYAnimatedImageView 播放动画。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YYAnimatedImage</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">// 动画帧总数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageFrameCount;</span><br><span class="line"><span class="comment">// 动画循环次数，0 表示无限循环</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageLoopCount;</span><br><span class="line"><span class="comment">// 每帧字节数（在内存中），可能用于优化内存缓冲区大小</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageBytesPerFrame;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像，这个方法可能在异步线程中调用</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)animatedImageFrameAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像对应的显示持续时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)animatedImageDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 针对 Spritesheet 动画的方法，用于显示某一帧图像在 Spritesheet 画布中的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)animatedImageContentsRectAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文提到过可选实现接口 <code>animatedImageContentsRectAtIndex:</code> 是专为 Spritesheet 动画设计的。</p>
</blockquote>
<p>像这样规定一个协议，使不相关的类遵循此协议拥有统一的功能接口方便另一个类调用的设计思想我们在自己日常项目的开发过程中很多场景都可以用到，例如可以封装一个 TableView，设计一个 TableViewCell 协议，让所有 TableViewCell 都实现这个协议以拥有统一的功能接口，然后我们封装的 TableView 类就可以统一的使用这些 TableViewCell 显示数据啦，省去了反复写相同功能 UITableView 的劳动力（实际应用场景很多，这里只是简单举例，抛砖引玉）。</p>
<h3 id="YYAnimatedImageView-1"><a href="#YYAnimatedImageView-1" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h3><p>上文提到过 YYAnimatedImageView 作为 YYImage 框架中的图片视图层，上接图像层，下启编/解码底层，是枢纽一般的存在（承上启下啊有木有？），我们需要重点研究其内部实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span> : <span class="title">UIImageView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 image 为多帧组成时，自动赋值为 YES，可以在显示和隐藏时自动播放和停止动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> autoPlayAnimatedImage;</span><br><span class="line"><span class="comment">// 当前显示的帧（从 0 起始），设置新值后会立即显示对应帧，如果新值无效则此方法无效</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> currentAnimatedImageIndex;</span><br><span class="line"><span class="comment">// 当前是否在播放动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line"><span class="comment">// 动画定时器所在的 runloop mode，默认为 NSRunLoopCommonModes，关乎动画定时器的触发</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *runloopMode;</span><br><span class="line"><span class="comment">// 内部缓存区的最大值（in bytes），默认为 0（动态），如果有值将会把缓存区限制为值大小，当收到内存警告或者 App 进入后台时，缓存区将会立即释放并且在适时的时候回复原状</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxBufferSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>额…出乎意料的简单呢~ 只有一些属性暴露出来以便我们在使用过程中实时查看动画的播放状态以及内存使用情况。笔者看源码总结出一条经验，即<strong>如果某个组件在库中占据重要地位，其 .h 文件中暴露的内容越是简单，其 .m 内部实现就越是复杂</strong>。</p>
<p>通过 <code>runloopMode</code> 属性大家用猜的也应该可以猜出 YYAnimatedImageView 内部实现动画的原理离不开 RunLoop，而且极有可能是用定时器 NSTimer 或者 CADisplayLink 实现的。下面我们来对 YYAnimatedImageView 的实现剖析，验证一下我们刚才的猜想。</p>
<h4 id="YYAnimatedImageView-的实现剖析"><a href="#YYAnimatedImageView-的实现剖析" class="headerlink" title="YYAnimatedImageView 的实现剖析"></a>YYAnimatedImageView 的实现剖析</h4><p>YYAnimatedImageView 内部实现源码很有趣，有很多值得分享的地方。不过为了不把文章写成 MarkDown 编辑器文（笑~）笔者不会逐行翻译源码。读者如果想要知道实现的细节建议结合文章去翻阅源码。相信有了文章梳理的思路源码看起来应该不会有太大的困难，文章还是重在传播实现思想和一些值得分享的技巧。</p>
<p>我们先简单看一下 YYAnimatedImageView 的内部结构，方便后面分析实现思路时大家脑中对 YYAnimatedImageView 的结构提前有一个大概的认识。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *_curAnimatedImage; <span class="comment">///&lt; 当前图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once_t</span> _onceToken; <span class="comment">///&lt; 用于确保初始化代码只执行一次</span></span><br><span class="line">    dispatch_semaphore_t _lock; <span class="comment">///&lt; 信号量锁（用于 _buffer）</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *_requestQueue; <span class="comment">///&lt; 图片请求队列，串行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_link; <span class="comment">///&lt; 帧转换</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">///&lt; 上一帧之后的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *_curFrame; <span class="comment">///&lt; 当前帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curIndex; <span class="comment">///&lt; 当前帧索引</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalFrameCount; <span class="comment">///&lt; 帧总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _loopEnd; <span class="comment">///&lt; 是否在循环末尾</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curLoop; <span class="comment">///&lt; 当前循环次数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalLoop; <span class="comment">///&lt; 总循环次数, 0 表示无穷</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_buffer; <span class="comment">///&lt; 帧缓冲区</span></span><br><span class="line">    <span class="type">BOOL</span> _bufferMiss; <span class="comment">///&lt; 是否丢帧，在上面 _link 定时执行的 step 函数中从帧缓冲区读取下一帧图片时如果没读到，则视为丢帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _maxBufferCount; <span class="comment">///&lt; 最大缓冲计数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _incrBufferCount; <span class="comment">///&lt; 当前允许的缓存区计数（将逐步增加）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> _curContentsRect; <span class="comment">///&lt; 针对 YYSpriteSheetImage</span></span><br><span class="line">    <span class="type">BOOL</span> _curImageHasContentsRect; <span class="comment">///&lt; 图像类是否实现了 animatedImageContentsRectAtIndex: 接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line">- (<span class="type">void</span>)calcMaxBufferCount; <span class="comment">// 动态调节缓冲区最大限制 _maxBufferCount</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYAnimatedImageView 内部结构比 .h 中暴露的属性要复杂的多，而 <code>CADisplayLink *_link</code> 属性也证实了我们之前关于 .h 中 <code>runloopMode</code> 属性的猜想。</p>
<p>YYAnimatedImageView 内部的初始化没什么特别之处，初始化函数中会设置图片，当判定图片有更改时会依照下面 4 步去处理：</p>
<ul>
<li>改变图片</li>
<li>重置动画</li>
<li>初始化动画参数</li>
<li>重绘</li>
</ul>
<blockquote>
<p>Note: 这样可以保证 YYAnimatedImageView 的图片更改时都会执行上面的步骤为新的图片初始化配套的新动画参数并且重绘，而重置动画实现中会使用到上面的 <code>dispatch_once_t _onceToken;</code> 以确保某些内部变量的创建以及对 App 内存警告和进入后台的通知观察代码只执行一次。</p>
</blockquote>
<p>YYAnimatedImageView 使图片动起来是依靠 <code>CADisplayLink *_link;</code> 变量切换帧图像，其内部的实现逻辑可以简单理解为：</p>
<ul>
<li>根据当前帧索引推出下一帧索引</li>
<li>使用下一帧索引去帧缓冲区尝试获取对应帧图像</li>
<li>如果找到对应帧图像则使用其重绘</li>
<li>如果没找到则根据条件向图片请求队列加入请求操作（向图片缓冲区录入之后的帧图像数据）</li>
</ul>
<p>嘛~ 这里面有一些值得一提的实现细节哈！</p>
<blockquote>
<ul>
<li>YYAnimatedImageView 实现中当 <code>_curIndex</code> 即当前帧索引修改时在修改代码前后加入了 <code>willChangeValueForKey:</code> 与 <code>didChangeValueForKey:</code> 方法以支持 KVO</li>
<li>对帧缓冲区 <code>_buffer</code> 的操作都使用 <code>_lock</code> 上锁</li>
<li>通过将图片请求队列 <code>_requestQueue</code> 的 <code>maxConcurrentOperationCount</code> 设置为 1 使图片请求队列成为串行队列（最大并发数为 1）</li>
<li>图片请求队列中加入的操作均为 <code>_YYAnimatedImageViewFetchOperation</code></li>
<li>为了避免使用 <code>CADisplayLink</code> 可能造成的循环引用设计了 <code>_YYImageWeakProxy</code></li>
</ul>
</blockquote>
<p>先看一下 <code>_YYAnimatedImageViewFetchOperation</code> 的源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYAnimatedImageViewFetchOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) YYAnimatedImageView *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> nextIndex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *curImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYAnimatedImageViewFetchOperation</span></span></span><br><span class="line">- (<span class="type">void</span>)main &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>_YYAnimatedImageViewFetchOperation</code> 继承自 NSOperation 类，是自定义操作类，作者将其操作内容实现写在了 <code>main</code> 中，代码太长而且我觉得贴出来不仅不会帮助读者理解反而会因为片面的源码实现影响读者对 YYAnimatedImageView 的整体实现思路理解（因为大量贴源码会使文章生涩很多，而且会把读者注意力转移到某一个实现），这里简单描述一下 <code>main</code> 函数内部实现逻辑：</p>
<ul>
<li>判断帧缓冲区大小</li>
<li>扫描下一帧以及当前允许缓冲范围内之后的帧图片</li>
<li>如果发现丢失的帧则尝试重新获取帧图像并加入到帧缓冲</li>
</ul>
<p>嘛~ 不贴源码归不贴源码，该注意的细节还是需要列出来的（笑）。</p>
<blockquote>
<ul>
<li>操作中对于 <code>view</code> 缓冲区的操作也都上了锁</li>
<li>操作由于是放入图片请求队列中进行的，内部有对 <code>isCancelled</code> 做判断，如果操作已经被取消（发生在更改图片、停止动画、手动更改当前帧、收到内存警告或 App 进入后台等）则需要及时跳出</li>
<li>对于新的线程优先级只在 <code>main</code> 方法范围内有效，所以推荐把操作的实现放在 <code>main</code> 中而非 <code>start</code>（如需覆盖 start 方法时，需要关注 <code>isExecuting</code> 和 <code>isFinished</code> 两个 key paths）</li>
</ul>
</blockquote>
<p>YYAnimatedImageView 内部设计了 <code>_YYImageWeakProxy</code> 来避免使用 NSTimer 或者 CADisplayLink 可能造成的循环引用问题，<code>_YYImageWeakProxy</code> 内部实现也比较简单，继承自 NSProxy，关于 NSProxy 可以查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsproxy">官方文档</a>以了解更多。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYImageWeakProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="type">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYImageWeakProxy</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> _target;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="type">void</span> *null = <span class="literal">NULL</span>;</span><br><span class="line">    [invocation setReturnValue:&amp;null];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(init)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面贴出的源码省略了比较基础的实现部分，<code>_YYImageWeakProxy</code> 内部弱引用一个对象 target，对于 <code>_YYImageWeakProxy</code> 的一些基本操作包含 <code>hash</code> 和 <code>isEqual</code> 这些统统都转到 target 上，并且使用 <code>forwardingTargetForSelector:</code> 消息重定向将不能响应的运行时消息也重定向给 target 来响应。</p>
<p>Emmmmm..那么问题来了，既然都消息重定向给 target 了还要消息转发干嘛？因为要避免循环引用问题所以对 target 使用弱引用，期间无法保证 target 一定存在，所以 <code>forwardingTargetForSelector:</code> 方法可能返回 nil，接着在 Runtime 消息转发中借用 init 消息返回空以“吞掉”异常。</p>
<blockquote>
<p>Note: 消息转发产生的开销要比动态方法解析和消息重定向大。</p>
</blockquote>
<h2 id="YYImageCoder"><a href="#YYImageCoder" class="headerlink" title="YYImageCoder"></a>YYImageCoder</h2><img src="/yyimage/image_coder.jpg" class="">
<p>YYImageCoder 作为 YYImage 的编/解码器，对应于 iOS 中的 ImageIO.framework 图片编/解码库，正是因为有了 YYImageCoder 的存在，YYImage 才得以支持如此多的图片格式，所以说 YYImageCoder 是 YYImage 的底层核心。</p>
<p>YYImageCoder 内部定义了许多 YYImage 中用到的核心数据结构：</p>
<ul>
<li>YYImageType，所有的支持的图片格式做了枚举定义</li>
<li>YYImageDisposeMethod，指定在画布上渲染下一个帧之前如何处理当前帧所使用的区域方法</li>
<li>YYImageBlendOperation，指定当前帧的透明像素如何与前一个画布的透明像素混合操作</li>
<li>YYImageFrame，一帧图像数据</li>
<li>YYImageEncoder，图像编码器</li>
<li>YYImageDecoder，图像解码器</li>
<li>UIImage+YYImageCoder，UIImage 的分类，里面提供了一些方便使用的方法</li>
</ul>
<p>其中 YYImageFrame 是对一帧图像数据的封装，便于在 YYImageCoder 编/解码过程中使用。</p>
<p>YYImageCoder 内部图像编码器 YYImageEncoder 和图像解码器 YYImageDecoder 其实是分开来的，我们下面分别对它们做分析。</p>
<h3 id="YYImageEncoder"><a href="#YYImageEncoder" class="headerlink" title="YYImageEncoder"></a>YYImageEncoder</h3><p>先来讲一下 YYImageEncoder，其在 YYImageCoder 中担任编码器的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageEncoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type; <span class="comment">///&lt; 图像类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> loopCount;       <span class="comment">///&lt; 循环次数，0 无限循环，仅适用于 GIF/APNG/WebP 格式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> lossless;              <span class="comment">///&lt; 无损标记，仅适用于 WebP.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> quality;            <span class="comment">///&lt; 压缩质量，0.0~1.0，仅适用于 JPG/JP2/WebP.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止适用 init、new 初始化编码器（我没忘记我说过这些编码技巧会在之后统一写一篇文章汇总）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定图片类型创建编码器</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithType:(YYImageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 添加图像</span></span><br><span class="line">- (<span class="type">void</span>)addImage:(<span class="built_in">UIImage</span> *)image duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加图像数据</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithData:(<span class="built_in">NSData</span> *)data duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加文件路径</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithFile:(<span class="built_in">NSString</span> *)path duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 开始图像编码并尝试返回编码后的数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encode;</span><br><span class="line"><span class="comment">// 编码并将得到的数据保存到给定路径文件中</span></span><br><span class="line">- (<span class="type">BOOL</span>)encodeToFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line"><span class="comment">// 便捷方法，对一个单帧图像编码</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImage:(<span class="built_in">UIImage</span> *)image type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"><span class="comment">// 便捷方法，从解码器中编码图像数据</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImageWithDecoder:(YYImageDecoder *)decoder type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageEncoder 内部的一些属性和接口都比较基本，关于其内部实现我们需要先看一下私有变量：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageEncoder</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_images; <span class="comment">// 已添加到编码器的图片（数组）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_durations; <span class="comment">// 对应的图片帧显示持续时长（数组）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="YYImageEncoder-的实现思路"><a href="#YYImageEncoder-的实现思路" class="headerlink" title="YYImageEncoder 的实现思路"></a>YYImageEncoder 的实现思路</h4><p>YYImageEncoder 的初始化部分没有多复杂，根据图片的类型按照编码最优的参数做初始化而已。关于 YYImageEncoder 对于图片的编码工作，其实作者根据要支持的图片类型和对应图片类型的编码方式做了底层封装，再根据当前图片的类型选择对应的底层编码方法执行。</p>
<p>关于不同图片类型的图片编码格式可以查阅本文文末的扩展阅读章节，结合扩展阅读的内容查阅 YYImage 这部分源码可以理解作者对于底层图片格式信息的结构封装以及编/解码操作具体实现。</p>
<p>关于 YYImageEncoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L216">YYImageCoder.h</a> 了解。</p>
<h3 id="YYImageDecoder"><a href="#YYImageDecoder" class="headerlink" title="YYImageDecoder"></a>YYImageDecoder</h3><p>YYImageDecoder 在 YYImageCoder 中担任解码器的角色，其与上述 YYImageEncoder 对应，一个负责图像编码一个负责图像解码，不过 YYImageDecoder 的实现比 YYImageEncoder 更为复杂。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageDecoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *data;    <span class="comment">///&lt; 图像数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type;          <span class="comment">///&lt; 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> scale;             <span class="comment">///&lt; 图像大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> frameCount;     <span class="comment">///&lt; 图像帧数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount;      <span class="comment">///&lt; 图像循环次数，0 无限循环</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> width;          <span class="comment">///&lt; 图像画布宽度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> height;         <span class="comment">///&lt; 图像画布高度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinalized) <span class="type">BOOL</span> finalized;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个图像解码器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithScale:(<span class="built_in">CGFloat</span>)scale <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 用新数据增量更新图像</span></span><br><span class="line">- (<span class="type">BOOL</span>)updateData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data final:(<span class="type">BOOL</span>)final;</span><br><span class="line"><span class="comment">// 方便用一个特殊的数据创建对应的解码器</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)decoderWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"><span class="comment">// 解码并返回给定索引对应的帧数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYImageFrame *)frameAtIndex:(<span class="built_in">NSUInteger</span>)index decodeForDisplay:(<span class="type">BOOL</span>)decodeForDisplay;</span><br><span class="line"><span class="comment">// 返回给定索引对应的帧持续显示时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定索引对应帧的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)framePropertiesAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回图片的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)imageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageDecoder 暴露了一些关于解码图像的属性并提供了初始化解码器方法、图像解码方法以及访问图像帧信息的方法。不过上文也说过 YYImageDecoder 的实现比较复杂，我们接着看一下其内部变量结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageDecoder</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 递归锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _sourceTypeDetected; <span class="comment">// 是否推测图像源类型</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> _source; <span class="comment">// 图像源</span></span><br><span class="line">    yy_png_info *_apngSource; <span class="comment">// 如果判定图像为 YYImageTypePNG 则会以 APNG 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> YYIMAGE_WEBP_ENABLED</span></span><br><span class="line">    WebPDemuxer *_webpSource; <span class="comment">// 如果判定图像为 YYImageTypeWebP 则会议 WebP 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImageOrientation</span> _orientation; <span class="comment">// 绘制方向</span></span><br><span class="line">    dispatch_semaphore_t _framesLock; <span class="comment">// 针对于图像帧的锁</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_frames; <span class="comment">///&lt; Array&lt;_YYImageDecoderFrame *&gt;, without image</span></span><br><span class="line">    <span class="type">BOOL</span> _needBlend; <span class="comment">// 是否需要混合</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _blendFrameIndex; <span class="comment">// 从帧索引混合到当前帧</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> _blendCanvas; <span class="comment">// 混合画布</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_YYImageDecoderFrame</code> 继承自 YYImageFrame 类作为 YYImageCoder 图像解码器 YYImageDecoder 使用的内部框架类存在，是对于一帧图像的数据封装提供了便于编/解码时需要访问的数据。</p>
<h4 id="YYImageDecoder-内锁的选择"><a href="#YYImageDecoder-内锁的选择" class="headerlink" title="YYImageDecoder 内锁的选择"></a>YYImageDecoder 内锁的选择</h4><p>可以看到作者在 YYImageDecoder 内部使用了两种锁：</p>
<ul>
<li><code>pthread_mutex_t _lock;</code></li>
<li><code>dispatch_semaphore_t _framesLock;</code></li>
</ul>
<p><code>pthread_mutex_t</code> 在解码器初始化过程中被以 <code>PTHREAD_MUTEX_RECURSIVE</code> 类型设置为了递归锁。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init (&amp;attr);</span><br><span class="line">pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init (&amp;_lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy (&amp;attr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 一般情况下一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p>
<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 <code>pthread_mutex</code> 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 <code>PTHREAD_MUTEX_RECURSIVE</code> 即可。</p>
</blockquote>
<p>作者使用 <code>dispatch_semaphore_t</code> 作为图像帧数组的锁是因为 <code>dispatch_semaphore_t</code> 更加轻量且对于图像帧数组的临界操作比较快，不会造成长时间的阻塞，这种情况下 <code>dispatch_semaphore_t</code> 具有性能优势（Emmmmmm..老生常谈了，熟悉的同学不要抱怨，照顾一下后面的同学）。</p>
<h4 id="YYImageDecoder-内的实现思路"><a href="#YYImageDecoder-内的实现思路" class="headerlink" title="YYImageDecoder 内的实现思路"></a>YYImageDecoder 内的实现思路</h4><p>YYImageDecoder 内在初始化时会初始化锁并更新图像源数据，在更新图像源时调用 <code>_updateSource</code> 方法根据当前图像类型以作者对该类型封装好的底层数据结构和对应图像类型解码规则做解码，解码之后设置对应属性。</p>
<p>关于作者对不同格式的图像数据的底层封装源码感兴趣的读者可以参考本文文末的扩展阅读章节内容自行查阅。</p>
<p>关于 YYImageDecoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L106">YYImageCoder.h</a> 了解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的分析了 YYImage 源码，希望各位读者在阅读本文之后可以对 YYImage 整体架构和设计思路有清晰的认识。</li>
<li>文章对 YYImage 的 Image 层级的三类图像（YYImage, YYFrameImage, YYSpriteSheetImage）分别解读，希望可以对各位读者关于这三类图像的组成原理和呈现动画的方式的理解有所帮助。</li>
<li>文章深入剖析了 YYAnimatedImageView 的内部实现，提炼出其设计思路以供读者探究。</li>
<li>笔者把自己在阅读源码中发现的值得分享的实现细节结合源码单独拎出来分析，希望各位读者可以在自己平时工作中遇到相似情况时能够多一些思路，封装项目组件时可以用到这些技巧。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明出处 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。能力不足，水平有限，如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我，另外我的 <a target="_blank" rel="noopener" href="https://github.com/Lision">GitHub 主页</a> 里有很多有趣的小玩意哦~</p>
<p>最后，希望我的文章可以为你带来价值~</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">libpng 官网关于 PNG 结构的官方说明</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.mozilla.org/APNG_Specification">APNG 的维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/api">WebP 开发者文档</a></li>
</ul>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yyimage/" rel="tag">yyimage</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
</section>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
