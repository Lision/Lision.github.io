<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Archives: 2017 | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/archives/2017/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	


	<section class="page-header archive">
    <h1>- <span>2017</span> -</h1>
  </section>




<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/webview_javascript_bridge/">
      深入剖析 WebViewJavascriptBridge
    </a>
  </h2>
  
  <time>
    12月 23, 2017
  </time>
  <section class="content">
	  <img src="/webview_javascript_bridge/merry_ch.jpg" class="">
<p>Emmmmm…这篇文章发布出来可能正逢圣诞节🎄，Merry Christmas!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而 JS 和 iOS Native 就好比两块没有交集的大陆，如果想要使它们相互通信就必须要建立一座“桥梁”。</p>
<p><strong>思考一下，如果项目组让你去造这座“桥”，如何才能做到既优雅又实用？</strong></p>
<p>本文将结合 WebViewJavascriptBridge 源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 是盛名已久的 JSBridge 库，早在 2011 年就被作者 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin">Marcus Westin</a> 发布到 GitHub，直到现在作者还在积极维护中，目前该项目已收获近 1w star 咯，其源码非常值得我们学习。</p>
<p>WebViewJavascriptBridge 的代码逻辑清晰，风格良好，加上自身代码量比较小使得其源码阅读非常轻松（可能需要一些 JS 基础）。更加难能可贵的是它仅使用了少量代码就实现了对于 Mac OS X 的 WebView 以及 iOS 平台的 UIWebView 和 WKWebView 三种组件的完美支持。</p>
<p>我对 WebViewJavascriptBridge 的评价是<strong>小而美</strong>，这类小而美的源码非常利于我们对其实现思想的学习（本文分析 WebViewJavascriptBridge 源码版本为 v6.0.3）。</p>
<p>关于 iOS 与 JS 的原生交互知识，之前我有写过一篇文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>，文章除了介绍 JavaScriptCore 库以及 UIWebView 和 WKWebView 与 JS 原生交互的方法之外还捎带提到了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hybrid">Hybrid</a> 的发展简史，文末还提供了一个 <a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">JS 通过 Native 调用 iOS 设备摄像头的 Demo</a>。</p>
<p>所以这篇文章不会再把重点放在 iOS 与 JS 的原生交互了，本文旨在介绍 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 的设计思路和实现原理，对 iOS 与 JS 原生交互知识感兴趣的同学推荐去阅读上面提到的文章，应该会有点儿帮助（笑）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>WebViewJavascriptBridge 简介</li>
<li>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</li>
<li>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</li>
<li>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</li>
<li>WebViewJavascriptBridge 的“桥梁美学”</li>
<li>文章总结</li>
</ul>
<h2 id="WebViewJavascriptBridge-简介"><a href="#WebViewJavascriptBridge-简介" class="headerlink" title="WebViewJavascriptBridge 简介"></a>WebViewJavascriptBridge 简介</h2><img src="/webview_javascript_bridge/bridge.png" class="">
<p>WebViewJavascriptBridge 是用于在 WKWebView，UIWebView 和 WebView 中的 Obj-C 和 JavaScript 之间发送消息的 iOS / OSX 桥接器。</p>
<p>有许多不错的项目都有使用 WebViewJavascriptBridge，这里简单列一部分（笑）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.messenger.com/">Facebook Messenger</a></li>
<li><a target="_blank" rel="noopener" href="https://www.facebook.com/paper">Facebook Paper</a></li>
<li><a target="_blank" rel="noopener" href="http://www.stayelsewhere.com/">ELSEWHERE</a></li>
<li>… &amp; many more!</li>
</ul>
<p>关于 WebViewJavascriptBridge 的具体使用方法详见其 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">GitHub 页面</a>。</p>
<p>在读完 WebViewJavascriptBridge 的源码之后我将其划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">源文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">接口层</td>
<td style="text-align:center">WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge</td>
</tr>
<tr>
<td style="text-align:center">实现层</td>
<td style="text-align:center">WebViewJavascriptBridgeBase</td>
</tr>
<tr>
<td style="text-align:center">JS 层</td>
<td style="text-align:center">WebViewJavascriptBridge_JS</td>
</tr>
</tbody>
</table>
<p>其中 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 作为接口层主要负责提供方便的接口，隐藏实现细节，其实现细节都是通过实现层 WebViewJavascriptBridgeBase 去做的，而 WebViewJavascriptBridge_JS 作为 JS 层其实存储了一段 JS 代码，在需要的时候注入到当前 WebView 组件中，最终实现 Native 与 JS 的交互。</p>
<h2 id="WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究"><a href="#WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究" class="headerlink" title="WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究"></a>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</h2><img src="/webview_javascript_bridge/golden_bridge.jpeg" class="">
<p>WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 作为接口层分别对应于 UIWebView 和 WKWebView 组件，我们来简单看一下这两个文件暴露出的信息：</p>
<p>WebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridge</span> : <span class="title">WVJB_WEBVIEW_DELEGATE_INTERFACE</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler; <span class="comment">// 注册 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 删除 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback; <span class="comment">// 调用 handler (JS)</span></span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate; <span class="comment">// 设置 webViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 的安全时长来加速消息传递，不推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>WKWebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emmmmm...这里应该不需要我注释了吧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKWebViewJavascriptBridge</span> : <span class="title">NSObject</span>&lt;<span class="title">WKNavigationDelegate</span>, <span class="title">WebViewJavascriptBridgeBaseDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="built_in">WKWebView</span>*)webView;</span><br><span class="line">+ (<span class="type">void</span>)enableLogging;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler;</span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName;</span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback;</span><br><span class="line">- (<span class="type">void</span>)reset;</span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate;</span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>disableJavscriptAlertBoxSafetyTimeout</code> 方法是通过禁用 JS 端 AlertBox 的安全时长来加速网桥消息传递的。如果想使用那么需要和前端约定好，如果禁用之后前端 JS 代码仍有调用 AlertBox 相关代码（alert, confirm, 或 prompt）则程序将被挂起，所以这个方法是不安全的，如无特殊需求笔者不推荐使用。</p>
</blockquote>
<p>可以看得出来这两个文件暴露出的接口几乎一致，其中 WebViewJavascriptBridge 中使用了宏定义 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 来分别适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件需要实现的代理方法。</p>
<h3 id="WebViewJavascriptBridge-中的宏定义"><a href="#WebViewJavascriptBridge-中的宏定义" class="headerlink" title="WebViewJavascriptBridge 中的宏定义"></a>WebViewJavascriptBridge 中的宏定义</h3><p>其实 WebViewJavascriptBridge 中为了适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件使用了一系列的宏定义，其源码比较简单：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __MAC_OS_X_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_OSX</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE WebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate, WebPolicyDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __IPHONE_OS_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#import <span class="string">&lt;UIKit/UIWebView.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_IOS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE UIWebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;UIWebViewDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;UIWebViewDelegate, WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>分别根据所在平台不同定义了 <code>WVJB_WEBVIEW_TYPE</code>，<code>WVJB_WEBVIEW_DELEGATE_TYPE</code> 以及刚才提到的 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 宏定义，并且分别定义了 <code>WVJB_PLATFORM_OSX</code> 和 <code>WVJB_PLATFORM_IOS</code> 便于之后的实现源码区分当前平台时使用，下面的 <code>supportsWKWebView</code> 宏定义也是同样的道理：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (__MAC_OS_X_VERSION_MAX_ALLOWED &gt; __MAC_10_9 || __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_7_1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> supportsWKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在引入头文件的时候可以通过这个 <code>supportsWKWebView</code> 宏灵活引入所需的头文件：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WebViewJavascriptBridge.m</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(supportsWKWebView)</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WKWebViewJavascriptBridge.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="WebViewJavascriptBridge-的实现分析"><a href="#WebViewJavascriptBridge-的实现分析" class="headerlink" title="WebViewJavascriptBridge 的实现分析"></a>WebViewJavascriptBridge 的实现分析</h3><p>我们接着看一下 WebViewJavascriptBridge 的实现部分，首先从内部变量信息看起：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(objc_arc_weak)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __weak</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __unsafe_unretained</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    WVJB_WEAK WVJB_WEBVIEW_TYPE* _webView; <span class="comment">// bridge 对应的 WebView 组件</span></span><br><span class="line">    WVJB_WEAK <span class="type">id</span> _webViewDelegate; <span class="comment">// 给 WebView 组件设置的代理（需要的话）</span></span><br><span class="line">    <span class="type">long</span> _uniqueId; <span class="comment">// 唯一标识，Emmmmm...但是我发现没卵用，只有 _base 中的 _uniqueId 才有用</span></span><br><span class="line">    WebViewJavascriptBridgeBase *_base; <span class="comment">// 上文说过，底层实现其实都是 WebViewJavascriptBridgeBase 在做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文提到 WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 的 .h 文件暴露接口信息非常相似，那么我们要不要看看 WKWebViewJavascriptBridge 的内部变量信息呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释参见 WebViewJavascriptBridge 就好</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WKWebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">WKWebView</span>* _webView;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span>&lt;<span class="built_in">WKNavigationDelegate</span>&gt; _webViewDelegate;</span><br><span class="line">    <span class="type">long</span> _uniqueId;</span><br><span class="line">    WebViewJavascriptBridgeBase *_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这俩货简直是一个妈生的。其实这是作者故意为之，因为作者想对外提供一套接口，即 WebViewJavascriptBridge，我们只需要使用 WebViewJavascriptBridge 就可以自动根据绑定的 WebView 组件的不同生成与之对应的 JSBridge 实例。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView &#123;</span><br><span class="line"><span class="comment">// 如果支持 WKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line">    <span class="comment">// 需要先判断当前入参 webView 是否从属于 WKWebView</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[<span class="built_in">WKWebView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WKWebViewJavascriptBridge 实例</span></span><br><span class="line">        <span class="keyword">return</span> (WebViewJavascriptBridge*) [<span class="built_in">WKWebViewJavascriptBridge</span> bridgeForWebView:webView];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 判断当前入参 webView 是否从属于 WebView（Mac OS X）或者 UIWebView（iOS）</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WebViewJavascriptBridge 实例</span></span><br><span class="line">        WebViewJavascriptBridge* bridge = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        [bridge _platformSpecificSetup:webView];</span><br><span class="line">        <span class="keyword">return</span> bridge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抛出 BadWebViewType 异常并返回 nil</span></span><br><span class="line">    [<span class="built_in">NSException</span> raise:<span class="string">@&quot;BadWebViewType&quot;</span> format:<span class="string">@&quot;Unknown web view type.&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的代码，实现并不复杂。如果支持 WKWebView 的话（<code>#if defined supportsWKWebView</code>）则去判断当前绑定的 WebView 组件是否从属于 WKWebView，这样可以返回 WKWebViewJavascriptBridge 实例，否则返回 WebViewJavascriptBridge 实例，最后如果入参 <code>webView</code> 的类型不满足判断条件则抛出 <code>BadWebViewType</code> 异常。</p>
<p>还有一个关于 <code>_webViewDelegate</code> 的小细节，本来不打算讲的，但是还是提一下吧（囧）。其实在 WebViewJavascriptBridge 以及 WKWebViewJavascriptBridge 的初始化实现过程中，会把当前 WebView 组件的代理绑定为自己：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WKWebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _setupInstance:(<span class="built_in">WKWebView</span>*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 替换组件的代理将其代理绑定为 bridge 自己是因为 WebViewJavascriptBridge 的实现原理上是利用我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，所以需要监听 WebView 组件的代理方法获取加载之前的 Request.URL 并做处理。这也是为什么 WebViewJavascriptBridge 提供了一个接口 <code>setWebViewDelegate:</code> 存储了一个逻辑上的 <code>_webViewDelegate</code>，这个 <code>_webViewDelegate</code> 也需要遵循 WebView 组件的代理协议，这样在 WebViewJavascriptBridge 内部不同的代理方法中做完 bridge 要做的事情只有就会再去调用 <code>_webViewDelegate</code> 对应的代理方法，其实可以理解为 WebViewJavascriptBridge 对当前 WebView 组件的代理做了 hook。</p>
</blockquote>
<p>对于 WebViewJavascriptBridge 中暴露的初始化以外的所有接口，其内部实现都是通过 WebViewJavascriptBridgeBase 来实现的。这样做的好处就是<strong>即使 WebViewJavascriptBridge 因为绑定了 WKWebView 返回了 WKWebViewJavascriptBridge 实例，只要接口一致，对 JSBridge 发送相同的消息，就会有相同的实现（都是由 WebViewJavascriptBridgeBase 类实现的）</strong>。</p>
<h2 id="WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析"><a href="#WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析" class="headerlink" title="WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析"></a>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</h2><img src="/webview_javascript_bridge/pier.jpg" class="">
<p>作为 WebViewJavascriptBridge 的实现层，WebViewJavascriptBridgeBase 的命名也可以体现出其是作为整座“桥梁”桥墩一般的存在，我们还是按照老规矩先看一下 WebViewJavascriptBridgeBase.h 暴露的信息，好对其有一个整体的印象：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBResponseCallback)(<span class="type">id</span> responseData); <span class="comment">// 回调 block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBHandler)(<span class="type">id</span> data, WVJBResponseCallback responseCallback); <span class="comment">// 注册的 Handler block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> WVJBMessage; <span class="comment">// 消息类型 - 字典</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebViewJavascriptBridgeBaseDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span>*) _evaluateJavascript:(<span class="built_in">NSString</span>*)javascriptCommand;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridgeBase</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate; <span class="comment">// 代理，指向接口层类，用以给对应接口绑定的 WebView 组件发送执行 JS 消息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>* startupMessageQueue; <span class="comment">// 启动消息队列，可以理解为存放 WVJBMessage</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* responseCallbacks; <span class="comment">// 回调 blocks 字典，存放 WVJBResponseCallback 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* messageHandlers; <span class="comment">// 已注册的 handlers 字典，存放 WVJBHandler 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) WVJBHandler messageHandler; <span class="comment">// 没卵用</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line">- (<span class="type">void</span>)reset; <span class="comment">// 对应 WKJSBridge 的 reset 接口</span></span><br><span class="line">- (<span class="type">void</span>)sendData:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 发送消息，入参依次是参数，回调 block，对应 JS 端注册的 HandlerName</span></span><br><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString; <span class="comment">// 刷新消息队列，核心代码</span></span><br><span class="line">- (<span class="type">void</span>)injectJavascriptFile; <span class="comment">// 注入 JS</span></span><br><span class="line">- (<span class="type">BOOL</span>)isWebViewJavascriptBridgeURL:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 判定是否为 WebViewJavascriptBridgeURL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isQueueMessageURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为队列消息 URL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isBridgeLoadedURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为 bridge 载入 URL</span></span><br><span class="line">- (<span class="type">void</span>)logUnkownMessage:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 打印收到未知消息信息</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptCheckCommand; <span class="comment">// JS bridge 检测命令</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand; <span class="comment">// JS bridge 获取查询命令</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 安全时长以获取发送消息速度提升，不建议使用，理由见上文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>嘛~ 从 .h 文件中我们可以看到整个 WebViewJavascriptBridgeBase 所暴露出来的信息，属性层面上需要对以下 4 个属性加深印象，之后分析实现的过程中会带入这些属性：</p>
<ul>
<li><code>id &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate</code> 代理，可以通过代理让当前 bridge 绑定的 WebView 组件执行 JS 代码</li>
<li><code>NSMutableArray* startupMessageQueue;</code> 启动消息队列，存放 Obj-C 发送给 JS 的消息（可以理解为存放 <code>WVJBMessage</code> 类型）</li>
<li><code>NSMutableDictionary* responseCallbacks;</code> 回调 blocks 字典，存放 <code>WVJBResponseCallback</code> 类型的 block</li>
<li><code>NSMutableDictionary* messageHandlers;</code> Obj-C 端已注册的 handlers 字典，存放 <code>WVJBHandler</code> 类型的 block</li>
</ul>
<p>Emmmmm…接口层面看一下注释就好了，后面分析实现的时候会捎带讲解一些接口，剩下一些跟实现无关的接口内容感兴趣的同学推荐自己扒源码哈。</p>
<p>我们在对 WebViewJavascriptBridgeBase 整体有了一个初始印象之后就可以自己写一个页面，简单的嵌入一些 JS 跑一遍流程，在中间下断点扒源码，这样我们对于 Native 与 JS 的交互流程就可以一清二楚了。</p>
<p><strong>下面模拟一遍 JS 通过 WebViewJavascriptBridge 调用 Native 功能的流程分析 WebViewJavascriptBridgeBase 的相关实现</strong>（考虑现在的时间点决定以 WKWebView 为例讲解，即针对 WKWebViewJavascriptBridge 源码讲解）：</p>
<h3 id="1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码"><a href="#1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码" class="headerlink" title="1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码"></a>1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码</h3><p>上文说到 WebViewJavascriptBridge 的实现其实本质上是利用了我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，那么我们就从监听假 Request 开始讲起吧。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKNavigationDelegate 协议方法，用于监听 Request 并决定是否允许导航</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="comment">// webView 校验</span></span><br><span class="line">    <span class="keyword">if</span> (webView != _webView) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_webViewDelegate) strongDelegate = _webViewDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">if</span> ([_base isWebViewJavascriptBridgeURL:url]) &#123; <span class="comment">// 判定 WebViewJavascriptBridgeURL</span></span><br><span class="line">        <span class="keyword">if</span> ([_base isBridgeLoadedURL:url]) &#123; <span class="comment">// 判定 BridgeLoadedURL</span></span><br><span class="line">            <span class="comment">// 注入 JS 代码</span></span><br><span class="line">            [_base injectJavascriptFile];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([_base isQueueMessageURL:url]) &#123; <span class="comment">// 判定 QueueMessageURL</span></span><br><span class="line">            <span class="comment">// 刷新消息队列</span></span><br><span class="line">            [<span class="keyword">self</span> <span class="built_in">WKFlushMessageQueue</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录未知 bridge msg 日志</span></span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 _webViewDelegate 对应的代理方法</span></span><br><span class="line">    <span class="keyword">if</span> (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:<span class="keyword">@selector</span>(webView:decidePolicyForNavigationAction:decisionHandler:)]) &#123;</span><br><span class="line">        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 之前说过 WebViewJavascriptBridge 会 hook 绑定的 WebView 的代理方法，这一点 WKWebViewJavascriptBridge 也一样，在加入自己的代码之后会判断是否有 <code>_webViewDelegate</code> 响应这个代理方法，如果有则调用。</p>
</blockquote>
<p>我们还是把注意力放到注释中核心代码的位置，里面会先判断当前 url 是否为 bridge url：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kOldProtocolScheme @<span class="string">&quot;wvjbscheme&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kNewProtocolScheme @<span class="string">&quot;https&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kQueueHasMessage   @<span class="string">&quot;__wvjb_queue_message__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kBridgeLoaded      @<span class="string">&quot;__bridge_loaded__&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 的使用方法中第 4 步明确指出要复制粘贴 <code>setupWebViewJavascriptBridge</code> 方法到前段 JS 中，我们先来看一下这段 JS 方法源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123; <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>); &#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123; <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback); &#125;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">	<span class="comment">// 创建一个 iframe</span></span><br><span class="line">	<span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	<span class="comment">// 设置 iframe 为不显示</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 的 src 置为 &#x27;https://__bridge_loaded__&#x27;</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&#x27;https://__bridge_loaded__&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 加入到 document.documentElement</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个不显示的 iframe 并将其 src 置为 <code>https://__bridge_loaded__</code>，与上文中 <code>kBridgeLoaded</code> 宏定义一致，即用于 <code>isBridgeLoadedURL:</code> 方法中判定当前 url 是否为 BridgeLoadedURL。</p>
<blockquote>
<p>Note: 假 Request 的发起有两种方式，-1:<code>location.href</code> -2:<code>iframe</code>。通过 <code>location.href</code> 有个问题，就是如果 JS 多次调用原生的方法也就是 <code>location.href</code> 的值多次变化，Native 端只能接受到最后一次请求，前面的请求会被忽略掉，所以这里 WebViewJavascriptBridge 选择使用 iframe，后面不再解释。</p>
</blockquote>
<p>因为加入了 src 为 <code>https://__bridge_loaded__</code> 的 iframe 元素，我们上面截获 url 的代理方法就会拿到一个 <code>https://__bridge_loaded__</code> 的 url，由于 https 满足判定 WebViewJavascriptBridgeURL，将会进入核心代码区域接着会被判定为 BridgeLoadedURL 执行注入 JS 代码的方法，即 <code>[_base injectJavascriptFile];</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)injectJavascriptFile &#123;</span><br><span class="line">    <span class="comment">// 获取到 WebViewJavascriptBridge_JS 的代码</span></span><br><span class="line">    <span class="built_in">NSString</span> *js = WebViewJavascriptBridge_js();</span><br><span class="line">    <span class="comment">// 将获取到的 js 通过代理方法注入到当前绑定的 WebView 组件</span></span><br><span class="line">    [<span class="keyword">self</span> _evaluateJavascript:js];</span><br><span class="line">    <span class="comment">// 如果当前已有消息队列则遍历并分发消息，之后清空消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.startupMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>* queue = <span class="keyword">self</span>.startupMessageQueue;</span><br><span class="line">        <span class="keyword">self</span>.startupMessageQueue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> queuedMessage <span class="keyword">in</span> queue) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _dispatchMessage:queuedMessage];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，第一步交互已完成。关于 WebViewJavascriptBridge_JS 内部的 JS 代码我们放到后面的章节解读，现在可以简单理解为 WebViewJavascriptBridge 在 JS 端的具体实现代码。</p>
<h3 id="2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？"><a href="#2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？" class="headerlink" title="2.JS 端调用 callHandler 方法之后 Native 端究竟是如何响应的？"></a>2.JS 端调用 <code>callHandler</code> 方法之后 Native 端究竟是如何响应的？</h3><p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 中指出 JS 端的操作方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize your app here */</span></span><br><span class="line"></span><br><span class="line">	bridge.<span class="title function_">registerHandler</span>(<span class="string">&#x27;JS Echo&#x27;</span>, <span class="keyword">function</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class="line">		<span class="title function_">responseCallback</span>(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	bridge.<span class="title function_">callHandler</span>(<span class="string">&#x27;ObjC Echo&#x27;</span>, &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;, <span class="keyword">function</span> <span class="title function_">responseCallback</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS received response:&quot;</span>, responseData)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们知道 JS 端调用 <code>setupWebViewJavascriptBridge</code> 方法会走我们刚才分析过的第一步，即监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码。那么当 JS 端调用 <code>bridge.callHandler</code> 时，Native 端究竟是如何做出响应的呢？这里我们需要先稍微解读一下之前注入的 WebViewJavascriptBridge_JS 中的 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		responseCallback = data;</span><br><span class="line">		data = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line"><span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">		responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">		message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">	&#125;</span><br><span class="line">	sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 JS 端的代码中有 <code>callHandler</code> 函数的实现，其内部将入参 <code>handlerName</code> 以及 <code>data</code> 以字典形式作为参数调用 <code>_doSend</code> 方法，我们看一下 <code>_doSend</code> 方法的实现：</p>
<ul>
<li><code>_doSend</code> 方法内部会先判断入参中是否有回调</li>
<li>如果有回调则根据规则生成 <code>callbackId</code> 并且将回调 block 保存到 <code>responseCallbacks</code> 字典（囧~ JS 不叫字典的，我是为了 iOS 读者看着方便），之后给消息也加入一个键值对保存刚才生成的 <code>callbackId</code></li>
<li>之后给 <code>sendMessageQueue</code> 队列加入 <code>message</code></li>
<li>将 <code>messagingIframe.src</code> 设置为 <code>https://__wvjb_queue_message__</code></li>
</ul>
<p>好，点到为止，对于 WebViewJavascriptBridge_JS 内的 JS 端其他源码我们放着后面看。注意这里加入了一个 src 为 <code>https://__wvjb_queue_message__</code> 的 <code>messagingIframe</code>，它也是一个不可见的 iframe。这样 Native 端会收到一个 url 为 <code>https://__wvjb_queue_message__</code> 的 request，回到第 1 步中获取到假的 request 之后会进行各项判定，这次会满足 <code>[_base isQueueMessageURL:url]</code> 的判定调用 Native 的 <code>WKFlushMessageQueue</code> 方法。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)<span class="built_in">WKFlushMessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 WebViewJavascriptBridge._fetchQueue(); 方法</span></span><br><span class="line">    [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(<span class="built_in">NSString</span>* result, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新消息列表</span></span><br><span class="line">        [_base flushMessageQueue:result];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;WebViewJavascriptBridge._fetchQueue();&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 Native 端会在刷新队列中调用 JS 端的 <code>WebViewJavascriptBridge._fetchQueue();</code> 方法，我们来看一下 JS 端此方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 将 sendMessageQueue 转为 JSON 格式</span></span><br><span class="line">	<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">	<span class="comment">// 重置 sendMessageQueue</span></span><br><span class="line">	sendMessageQueue = [];</span><br><span class="line">	<span class="comment">// 返回 JSON 格式的 </span></span><br><span class="line">	<span class="keyword">return</span> messageQueueString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会把当前 JS 端 <code>sendMessageQueue</code> 消息队列以 JSON 的形式返回，而 Native 端会调用 <code>[_base flushMessageQueue:result];</code> 将拿到的 JSON 形式消息队列作为参数调用 <code>flushMessageQueue:</code> 方法，这个方法是整个框架 Native 端的精华所在，就是稍微有点长（笑）。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString &#123;</span><br><span class="line">    <span class="comment">// 校验 messageQueueString</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString == <span class="literal">nil</span> || messageQueueString.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 messageQueueString 通过 NSJSONSerialization 解为 messages 并遍历</span></span><br><span class="line">    <span class="type">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    <span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">        <span class="comment">// 类型校验</span></span><br><span class="line">        <span class="keyword">if</span> (![message isKindOfClass:[WVJBMessage <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;</span>, [message <span class="keyword">class</span>], message);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> _log:<span class="string">@&quot;RCVD&quot;</span> json:message];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试取 responseId，如取到则表明是回调，从 _responseCallbacks 取匹配的回调 block 执行</span></span><br><span class="line">        <span class="built_in">NSString</span>* responseId = message[<span class="string">@&quot;responseId&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (responseId) &#123; <span class="comment">// 取到 responseId</span></span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[<span class="string">@&quot;responseData&quot;</span>]);</span><br><span class="line">            [<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 responseId，则表明是正常的 JS callHandler 调用 iOS</span></span><br><span class="line">            WVJBResponseCallback responseCallback = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 尝试取 callbackId，示例 cb_1_1512035076293</span></span><br><span class="line">            <span class="comment">// 对应 JS 代码 var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime();</span></span><br><span class="line">            <span class="built_in">NSString</span>* callbackId = message[<span class="string">@&quot;callbackId&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (callbackId) &#123; <span class="comment">// 取到 callbackId，表示 js 端希望在调用 iOS native 代码后有回调</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> responseData) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (responseData == <span class="literal">nil</span>) &#123;</span><br><span class="line">                        responseData = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将 callbackId 作为 msg 的 responseId 并设置 responseData，执行 _queueMessage</span></span><br><span class="line">                    WVJBMessage* msg = @&#123; <span class="string">@&quot;responseId&quot;</span>:callbackId, <span class="string">@&quot;responseData&quot;</span>:responseData &#125;;</span><br><span class="line">                    <span class="comment">// _queueMessage 函数主要是把 msg 转为 JSON 格式，内含 responseId = callbackId</span></span><br><span class="line">                    <span class="comment">// JS 端调用 WebViewJavascriptBridge._handleMessageFromObjC(&#x27;msg_JSON&#x27;); 其中 &#x27;msg_JSON&#x27; 就是 JSON 格式的 msg</span></span><br><span class="line">                    [<span class="keyword">self</span> _queueMessage:msg];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 callbackId</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> ignoreResponseData) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试以 handlerName 获取 iOS 端之前注册过的 handler</span></span><br><span class="line">            WVJBHandler handler = <span class="keyword">self</span>.messageHandlers[message[<span class="string">@&quot;handlerName&quot;</span>]];</span><br><span class="line">            <span class="keyword">if</span> (!handler) &#123; <span class="comment">// 没注册过，则跳过此 msg</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;</span>, message);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用对应的 handler，以 message[@&quot;data&quot;] 为入参，以 responseCallback 为回调</span></span><br><span class="line">            handler(message[<span class="string">@&quot;data&quot;</span>], responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ <code>flushMessageQueue:</code> 方法作为整个 Native 端的核心，有点长是可以理解的。我们简单理一下它的实现思路：</p>
<ul>
<li>入参校验</li>
<li>将 JSON 形式的入参转换为 Native 对象，即消息队列，这里面消息类型是之前定义过的 WVJBMessage，即字典</li>
<li>如果消息中含有 “responseId” 则表明是之前 Native 调用的 JS 方法回调过来的消息（因为 JS 端和 Native 端实现逻辑是对等的，所以这个地方不明白的可以参考下面的分析）</li>
<li>如果消息中不含 “responseId” 则表明是 JS 端通过 <code>callHandler</code> 函数正常调用 Native 端过来的消息</li>
<li>尝试获取消息中的 “callbackId”，如果 JS 本次消息需要 Native 响应之后回调才会有这个键值，具体参见上文中 JS 端 <code>_doSend</code> 部分源码分析。如取到 “callbackId” 则需生成一个回调 block，回调 block 内部将 “callbackId” 作为 msg 的 “responseId” 执行 <code>_queueMessage</code> 将消息发送给 JS 端（JS 端处理消息逻辑与 Native 端一致，所以上面使用 “responseId” 判断当前消息是否为回调方法传递过来的消息是很容易理解的）</li>
<li>尝试以消息中的 “handlerName” 从 <code>messageHandlers</code>（上文提到过，是保存 Native 端注册过的 handler 的字典）取到对应的 handler block，如果取到则执行代码块，否则打印错误日志</li>
</ul>
<blockquote>
<p>Note: 这个消息处理的方法虽然长，但是逻辑清晰，而且有效的解决了 JS 与 Native 相互调用的过程中参数传递的问题（包括回调），此外 JS 端的消息处理逻辑与 Native 端保持一致，实现了逻辑对称，非常值得我们学习。</p>
</blockquote>
<h2 id="WebViewJavascriptBridge-JS-Native-调用-JS-实现解读"><a href="#WebViewJavascriptBridge-JS-Native-调用-JS-实现解读" class="headerlink" title="WebViewJavascriptBridge_JS - Native 调用 JS 实现解读"></a>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</h2><img src="/webview_javascript_bridge/javascript.jpg" class="">
<p>Emmmmm…这一章节主要讲 JS 端注入的代码，即 WebViewJavascriptBridge_JS 中的 JS 源码。由于我没做过前段，能力不足，水平有限，可能有谬误希望各位读者发现的话及时指正，感激不尽。预警，由于 JS 端和上文分析过的 Native 端逻辑对称且上文已经分析过部分 JS 端的函数，所以下面的 JS 源码没有另做拆分，为避免被大段 JS 代码糊脸不感兴趣的同学可以直接看代码后面的总结。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// window.WebViewJavascriptBridge 校验，避免重复</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒加载 window.onerror，用于打印 error 日志</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">onerror</span>) &#123;</span><br><span class="line">		<span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg, url, line</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: ERROR:&quot;</span> + msg + <span class="string">&quot;@&quot;</span> + url + <span class="string">&quot;:&quot;</span> + line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// window.WebViewJavascriptBridge 声明</span></span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span> = &#123;</span><br><span class="line">		<span class="attr">registerHandler</span>: registerHandler,</span><br><span class="line">		<span class="attr">callHandler</span>: callHandler,</span><br><span class="line">		<span class="attr">disableJavscriptAlertBoxSafetyTimeout</span>: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line">		<span class="attr">_fetchQueue</span>: _fetchQueue,</span><br><span class="line">		<span class="attr">_handleMessageFromObjC</span>: _handleMessageFromObjC</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量声明</span></span><br><span class="line">	<span class="keyword">var</span> messagingIframe; <span class="comment">// 消息 iframe</span></span><br><span class="line">	<span class="keyword">var</span> sendMessageQueue = []; <span class="comment">// 发送消息队列</span></span><br><span class="line">	<span class="keyword">var</span> messageHandlers = &#123;&#125;; <span class="comment">// JS 端注册的消息处理 handlers 字典（囧，JS 其实叫对象）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> responseCallbacks = &#123;&#125;; <span class="comment">// JS 端存放回调的字典</span></span><br><span class="line">	<span class="keyword">var</span> uniqueId = <span class="number">1</span>; <span class="comment">// 唯一标示，用于回调时生成 callbackId</span></span><br><span class="line">	<span class="keyword">var</span> dispatchMessagesWithTimeoutSafety = <span class="literal">true</span>; <span class="comment">// 默认启用安全时长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过禁用 AlertBoxSafetyTimeout 来提速网桥消息传递</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">disableJavscriptAlertBoxSafetyTimeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">		dispatchMessagesWithTimeoutSafety = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 iOS 逻辑，注册 handler 其实是往 messageHandlers 字典中插入对应 name 的 block</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">registerHandler</span>(<span class="params">handlerName, handler</span>) &#123;</span><br><span class="line">		messageHandlers[handlerName] = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如果参数只有两个且第二个参数类型为 function，则表示没有参数传递，即 data 为空</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			responseCallback = data;</span><br><span class="line">			data = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 handlerName 和 data 作为 msg 对象参数调用 _doSend 函数</span></span><br><span class="line">		<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// _doSend 向 Native 端发送消息</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line">		<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">			<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">			responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">			message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line">		sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">		messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">	    <span class="comment">// 内部将发送消息队列 sendMessageQueue 转为 JSON 格式并返回</span></span><br><span class="line">		<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">		sendMessageQueue = [];</span><br><span class="line">		<span class="keyword">return</span> messageQueueString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iOS 端 _dispatchMessage 函数会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_handleMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">	    <span class="comment">// 调度从 Native 端获取到的消息</span></span><br><span class="line">        <span class="title function_">_dispatchMessageFromObjC</span>(messageJSON);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心代码，调度从 Native 端获取到的消息，逻辑与 Native 端一致</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_dispatchMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">		<span class="comment">// 判断有没有禁用 AlertBoxSafetyTimeout，最终会调用 _doDispatchMessageFromObjC 函数</span></span><br><span class="line">		<span class="keyword">if</span> (dispatchMessagesWithTimeoutSafety) &#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(_doDispatchMessageFromObjC);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			 <span class="title function_">_doDispatchMessageFromObjC</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 解析 msgJSON 得到 msg</span></span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">_doDispatchMessageFromObjC</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">			<span class="keyword">var</span> messageHandler;</span><br><span class="line">			<span class="keyword">var</span> responseCallback;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果有 responseId，则说明是回调，取对应的 responseCallback 执行，之后释放</span></span><br><span class="line">			<span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">				responseCallback = responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">				<span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="title function_">responseCallback</span>(message.<span class="property">responseData</span>);</span><br><span class="line">				<span class="keyword">delete</span> responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 responseId，则表示正常的 iOS call handler 调用 js</span></span><br><span class="line">				<span class="comment">// 如 msg 包含 callbackId，说明 iOS 端需要回调，初始化对应的 responseCallback</span></span><br><span class="line">				<span class="keyword">if</span> (message.<span class="property">callbackId</span>) &#123;</span><br><span class="line">					<span class="keyword">var</span> callbackResponseId = message.<span class="property">callbackId</span>;</span><br><span class="line">					responseCallback = <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">						<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:message.<span class="property">handlerName</span>, <span class="attr">responseId</span>:callbackResponseId, <span class="attr">responseData</span>:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 从 messageHandlers 拿到对应的 handler 执行</span></span><br><span class="line">				<span class="keyword">var</span> handler = messageHandlers[message.<span class="property">handlerName</span>];</span><br><span class="line">				<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">				    <span class="comment">// 如未取到对应的 handler 则打印错误日志</span></span><br><span class="line">					<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;</span>, message);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="title function_">handler</span>(message.<span class="property">data</span>, responseCallback);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// messagingIframe 的声明，类型 iframe，样式不可见，src 设置</span></span><br><span class="line">	messagingIframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	messagingIframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	<span class="comment">// messagingIframe 加入 document.documentElement 中</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(messagingIframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disableJavscriptAlertBoxSafetyTimeout handler，Native 可以通过禁用 AlertBox 的安全时长来加速桥接消息</span></span><br><span class="line">	<span class="title function_">registerHandler</span>(<span class="string">&quot;_disableJavascriptAlertBoxSafetyTimeout&quot;</span>, disableJavscriptAlertBoxSafetyTimeout);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">setTimeout</span>(_callWVJBCallbacks, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_callWVJBCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbacks = <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">			callbacks[i](<span class="title class_">WebViewJavascriptBridge</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS 端和 Native 端逻辑一致，上面的代码已经加入了详细的中文注释，上文在对于“WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析”章节的分析过程中为了走通整个调用的逻辑已经对部分 JS 端代码进行了分析，这里我们简单的梳理一下 JS 端核心代码 <code>_doDispatchMessageFromObjC</code> 函数的逻辑：</p>
<ul>
<li>将 messageJSON 使用 JSON 解析出来</li>
<li>尝试取解析到的消息中的 responseId，如果有取到则说明是 Native 端响应 JS 端之后通过回调向 JS 端发出的消息，用 responseId 取 responseCallbacks 中对应的回调响应 block，找到后执行该 block 之后删除</li>
<li>如果没取到 responseId 则表示这条消息是 Native 端通过 <code>callHandler:data:responseCallback:</code> 正常调用 JS 注册的 handler 发送过来的消息（这里的正常是针对回调而言）</li>
<li>如果当前的消息有 callbackId 则表明 Native 端需要 JS 端响应本次消息之后回调反馈，生成一个 responseCallback 作为回调 block (JS 端是 function) ，其内部使用 <code>_doSend</code> 方法传递一个带有 responseId 的消息给 Native 端，表明此条消息是之前的回调消息</li>
<li>最后按照解析到的消息中 handlerName 从 messageHandlers，即 JS 端注册过的 handlers 中找到与名称对应的处理函数执行，如果没找到则打印附带相关信息的错误日志</li>
</ul>
<p>嘛~ 对比一下 Native 端的核心代码 <code>flushMessageQueue:</code> 看一下，很容易发现两端的处理实现是逻辑对称的。</p>
<h2 id="WebViewJavascriptBridge-的“桥梁美学”"><a href="#WebViewJavascriptBridge-的“桥梁美学”" class="headerlink" title="WebViewJavascriptBridge 的“桥梁美学”"></a>WebViewJavascriptBridge 的“桥梁美学”</h2><img src="/webview_javascript_bridge/bridge_beautiful.jpg" class="">
<p>在总结 WebViewJavascriptBridge 的“桥梁美学”之前请再回顾一下 WebViewJavascriptBridge 的工作流：</p>
<ul>
<li>JS 端加入 src 为 <code>https://__bridge_loaded__</code> 的 iframe</li>
<li>Native 端检测到 Request，检测如果是 <code>__bridge_loaded__</code> 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码</li>
<li>注入代码成功之后会加入一个 messagingIframe，其 src 为 <code>https://__wvjb_queue_message__</code></li>
<li>之后不论是 Native 端还是 JS 端都可以通过 <code>registerHandler</code> 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 <code>callHandler</code> 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）</li>
</ul>
<p>嘛~ 所以我们很容易列举出 WebViewJavascriptBridge 所具有的“美学”：</p>
<ul>
<li>隐性适配</li>
<li>接口对等</li>
<li>逻辑对称</li>
</ul>
<p>我们结合本文展开来说一下上面的“美学”的具体实现。</p>
<h3 id="隐性适配"><a href="#隐性适配" class="headerlink" title="隐性适配"></a>隐性适配</h3><p>WebViewJavascriptBridge 主要是作为 Mac OS X 和 iOS 端（Native 端）与 JS 端相互通信，互相调用的桥梁。对于 Mac OS X 和 iOS 两种平台包含的三种 WebView 功能组件而言，WebViewJavascriptBridge 做了隐性适配，即仅用一套代码即可绑定不同平台的 WebView 组件实现同样功能的 JS 通信功能，这一点非常方便。</p>
<h3 id="接口对等"><a href="#接口对等" class="headerlink" title="接口对等"></a>接口对等</h3><p>WebViewJavascriptBridge 对于 JS 端和 Native 端设计了对等的接口，不论是 JS 端还是 Native 端，注册本端的响应处理都是用 <code>registerHandler</code> 接口，调用另一端（给另一端发消息）都是用 <code>callHandler</code> 接口。</p>
<p>这样做是非常合理的，因为不论是 JS 端还是 Native 端，作为通信的双方就通信本身而言是处于对等的地位的。这就好比一座大桥连接两块陆地，两地用大桥相互运输货物并接收资源，两块陆地在大桥的运输使用过程中逻辑上也是地位对等的。</p>
<h3 id="逻辑对称"><a href="#逻辑对称" class="headerlink" title="逻辑对称"></a>逻辑对称</h3><p>WebViewJavascriptBridge 在 JS 端和 Native 端对发送过来的消息有着相同逻辑的处理实现，如果考虑到收发双方的身份则可以把逻辑相同看做逻辑对称。</p>
<p>这种实现方式依旧非常合理，被桥连接的两块大陆在装货上桥和下桥卸货这两处逻辑上就应该是对称的。</p>
<p>嘛~ 说到这里就不得不祭出一个词来形容 WebViewJavascriptBridge 了，这个词就是<strong>优雅</strong>（笑）。当大家结合 WebViewJavascriptBridge 源码阅读本文之后不难发现其整个架构和设计思想跟现实桥梁设计中很多设计思想不谋而合，比如桥一般会分为左右桥幅，而左右幅桥一般只有一条线路中心线，即一个前进方向，用于桥上单一方向的资源传输，左右桥幅在功能上对等。</p>
<h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><ul>
<li>文章系统分析了 WebViewJavascriptBridge 源码，希望各位读者能够在阅读本文之后对 WebViewJavascriptBridge 的架构有一个整体认识。</li>
<li>文章对 WebViewJavascriptBridge 在 JS 端和 Native 端的消息处理实现做了深入剖析，希望可以对各位读者这部分源码的理解提供一些微薄的帮助。</li>
<li>总结了 WebViewJavascriptBridge 作为一个 JSBridge 框架所具有的优势，即文中所指的“桥梁美学”，期望可以对大家以后自己封装一个 JSBridge 提供思路，抛砖引玉。</li>
</ul>
<p>Emmmmm…不过需要注意的是 WebViewJavascriptBridge 仅仅是作为 JSBridge 层用于提供 JS 和 Native 之间相互传递消息的基础支持的。如果想要封装自己项目中的 WebView 组件还需要另外实现 HTTP cookie 注入，自定义 User-Agent，白名单或者权限校验等功能，更进一步还需要对 WebView 组件进行初始化速度，页面渲染速度以及页面缓存策略的优化。我之后<strong>也许可能大概应该</strong>会写一篇文章分享一下自己封装 WebView 组件时踩到的一些坑以及经验，因为自己水平有限…所以也可能不会写（笑）。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yyimage/">
      YYImage 设计思路，实现细节剖析
    </a>
  </h2>
  
  <time>
    12月 10, 2017
  </time>
  <section class="content">
	  <img src="/yyimage/yyimage_h.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片的历史早于文字，是最原始的信息传递方式。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AD%E6%9B%B8">六书</a>中的象形文构造思想就是用文字的线条或笔画，把要表达物体的外形特征，具体地勾画出来。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%B1%E6%85%8E">许慎</a>《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%B4%E6%96%87%E8%A7%A3%E5%AD%97">说文解字</a>》云：“象形者，画成其物，随体诘诎，日、月是也。”</p>
</blockquote>
<p>现代社会的信息传递中，图片仍然是不可或缺的一环，不论是报纸、杂志、漫画等实体刊物还是生活中超市地铁广告活动，都会有专门的配图抓人眼球。</p>
<p>在移动端 App 中，图片通常占据着重要的视觉空间，作为 iOS 开发来讲，所有的 App 都有精心设计的 AppIcon 陈列在 SpringBoard 中，打开任意一款主流 App 都少不了琳琅满目的图片搭配。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage">YYImage</a> 是一款功能强大的 iOS 图像框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一），支持目前市场上所有主流的图片格式的显示与编/解码，并且提供高效的动态内存缓存管理，以保证高性能低内存的动画播放。</p>
<p>YYKit 的作者 <a target="_blank" rel="noopener" href="https://weibo.com/239801242">@ibireme</a> 对于 iOS 图片处理写有两篇非常不错的文章，推荐各位读者在阅读本文之前查阅。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/ios_image_tips/">iOS 处理图片的一些小 Tip</a></li>
</ul>
<p>本文引用代码均为 YYImage v1.0.4 版本源码，文章旨在剖析 YYImage 的架构思想以及设计思路并对笔者在阅读源码过程中发现的有趣实现细节探究分享，不会逐行翻译源码，建议对源码实现感兴趣的同学结合 YYImage v1.0.4 版本源码食用本文~</p>
<img src="/yyimage/xiaomai.gif" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYImage 简介</li>
<li>YYImage, YYFrameImage, YYSpriteSheetImage</li>
<li>YYAnimatedImageView</li>
<li>YYImageCoder</li>
<li>总结</li>
<li>扩展阅读</li>
</ul>
<h2 id="YYImage-简介"><a href="#YYImage-简介" class="headerlink" title="YYImage 简介"></a>YYImage 简介</h2><img src="/yyimage/yyimage.jpg" class="">
<p>YYImage 是一款功能强大的 iOS 图像框架，支持当前市场主流的静/动态图像编/解码与动态图像的动画播放显示，其具有以下特性：</p>
<ul>
<li>支持以下类型动画图像的播放/编码/解码: WebP, APNG, GIF。</li>
<li>支持以下类型静态图像的显示/编码/解码: WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。</li>
<li>支持以下类型图片的渐进式/逐行扫描/隔行扫描解码: PNG, GIF, JPEG, BMP。</li>
<li>支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。</li>
<li>高效的动态内存缓存管理，以保证高性能低内存的动画播放。</li>
<li>完全兼容 UIImage 和 UIImageView，使用方便。</li>
<li>保留可扩展的接口，以支持自定义动画。</li>
<li>每个类和方法都有完善的文档注释。</li>
</ul>
<h3 id="YYImage-架构分析"><a href="#YYImage-架构分析" class="headerlink" title="YYImage 架构分析"></a>YYImage 架构分析</h3><p>通过 YYImage 源码可以按照其与 UIKit 的对应关系划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">UIKit</th>
<th style="text-align:center">YYImage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图像层</td>
<td style="text-align:center">UIImage</td>
<td style="text-align:center">YYImage, YYFrameImage, YYSpriteSheetImage</td>
</tr>
<tr>
<td style="text-align:center">视图层</td>
<td style="text-align:center">UIImageView</td>
<td style="text-align:center">YYAnimatedImageView</td>
</tr>
<tr>
<td style="text-align:center">编/解码层</td>
<td style="text-align:center">ImageIO.framework</td>
<td style="text-align:center">YYImageCoder</td>
</tr>
</tbody>
</table>
<ul>
<li>图像层，把不同类型的图像信息封装成类并提供初始化和其他便捷接口。</li>
<li>视图层，负责图像层内容的显示（包含动态图像的动画播放）工作。</li>
<li>编/解码层，提供图像底层支持，使整个框架得以支持市场主流的图片格式。</li>
</ul>
<blockquote>
<p>Note: <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/imageio">ImageIO.framework</a> 是 iOS 底层实现的图片编/解码库，负责管理颜色和访问图像元数据。其内部的实现使用了第三方编/解码库（如 libpng 等）并对第三方库进行调整优化。除此之外，iOS 还专门针对 JPEG 的编/解码开发了 AppleJPEG.framework，实现了性能更高的硬编码和硬解码。</p>
</blockquote>
<img src="/yyimage/yyimage_struct.png" class="">
<h2 id="YYImage-YYFrameImage-YYSpriteSheetImage"><a href="#YYImage-YYFrameImage-YYSpriteSheetImage" class="headerlink" title="YYImage, YYFrameImage, YYSpriteSheetImage"></a>YYImage, YYFrameImage, YYSpriteSheetImage</h2><p>先来介绍 YYImage 库中图像层的三个类，它们分别是：</p>
<ul>
<li>YYImage</li>
<li>YYFrameImage</li>
<li>YYSpriteSheetImage</li>
</ul>
<h3 id="YYImage"><a href="#YYImage" class="headerlink" title="YYImage"></a>YYImage</h3><p>YYImage 是一个显示动态图片数据的高级别类，其继承自 UIImage 并对 UIImage 做了扩展以支持 WebP，APNG 和 GIF 格式的图片解码。它还支持 NSCoding 协议可以对多帧图像数据进行 archive 和 unarchive 操作。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageNamed:(<span class="built_in">NSString</span> *)name; <span class="comment">// 不同于 UIImage，此方法无缓存</span></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType animatedImageType; <span class="comment">// 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *animatedImageData; <span class="comment">// 动态图像的元数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> animatedImageMemorySize; <span class="comment">// 多帧图像内存占用量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> preloadAllAnimatedImageFrames; <span class="comment">// 预加载所有帧（到内存）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYImage 提供了类似 UIImage 的初始化方法，公开了一些属性便于我们检测和控制其内存使用。</p>
<p>值得一提的是 YYImage 的 <code>imageNamed:</code> 初始化方法并不支持缓存。因为其 <code>imageNamed:</code> 内部实现并不同于 UIImage 的 <code>imageNamed:</code> 方法，YYImage 中的实现流程如下：</p>
<ul>
<li>推测出给定图像资源路径</li>
<li>拿到路径中的图像数据（NSData）</li>
<li>调用 YYImage 的 <code>initWithData:scale:</code> 方法初始化</li>
</ul>
<p>YYImage 的私有变量部分也比较简单，相信大家可以根据上面暴露出的属性和接口猜得到哈。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImage</span> </span>&#123;</span><br><span class="line">    YYImageDecoder *_decoder; <span class="comment">// 解码器</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_preloadedFrames; <span class="comment">// 预加载的图像帧</span></span><br><span class="line">    dispatch_semaphore_t _preloadedLock; <span class="comment">// 预加载锁</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _bytesPerFrame; <span class="comment">// 内存占用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部有一把锁 <code>dispatch_semaphore_t</code>，我们知道 <code>dispatch_semaphore_t</code> 当信号量为 1 时可以当做锁来使用，在不阻塞时其作为锁的效率非常高。这里使用 <code>_preloadedLock</code> 的主要目的是保证 <code>_preloadedFrames</code> 的读写，由于 <code>_preloadedFrames</code> 的读写过程是在内存中完成的，操作耗时不会太多，所以不会长时间阻塞，这种情况使用 <code>dispatch_semaphore_t</code> 非常合适。</p>
<p>嘛~ <code>_preloadedFrames</code> 对应 <code>preloadAllAnimatedImageFrames</code> 属性，开启预加载所有帧到内存的话，<code>_preloadedFrames</code> 作为一个数组会保存所有帧的图像。<code>_bytesPerFrame</code> 则对应 <code>animatedImageMemorySize</code> 属性，在初始化 YYImage 时，如果帧总数超过 1 则会计算 <code>_bytesPerFrame</code> 的大小。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decoder.frameCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    _decoder = decoder;</span><br><span class="line">    _bytesPerFrame = <span class="built_in">CGImageGetBytesPerRow</span>(image.CGImage) * <span class="built_in">CGImageGetHeight</span>(image.CGImage);</span><br><span class="line">    _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 YYImage 中还有一些实现也比较有趣，比如 <code>animatedImageDurationAtIndex:</code> 的实现中如果取到 &lt;= 10 ms 的时长会替换为 100 ms，并在 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImage.m#L246">注释</a> 中解释了为什么（一定要点进去看啊，笑~）。</p>
<h3 id="YYFrameImage"><a href="#YYFrameImage" class="headerlink" title="YYFrameImage"></a>YYFrameImage</h3><p>YYFrameImage 是专门用来显示基于帧的动画图像类，其也是 UIImage 的子类。YYFrameImage 仅支持系统图片格式例如 png 和 jpeg。</p>
<blockquote>
<p>Note: 使用 YYFrameImage 显示动画图像同样要基于 YYAnimatedImageView 播放。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYFrameImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                           oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                             frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                               oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                                 frameDurations:(<span class="built_in">NSArray</span> *)frameDurations</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYFrameImage 可以把静态图片类型如 png 和 jpeg 格式的静态图像用帧切换的方式以动态图片的形式显示，并且提供了 4 个常用的初始化方法方便我们使用。</p>
<p>YYFrameImage 内部有一些基本的变量分别对应于其暴露的 4 个常用初始化接口：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYFrameImage</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _loopCount;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _oneFrameBytes;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imagePaths;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imageDatas;</span><br><span class="line">    <span class="built_in">NSArray</span> *_frameDurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YYFrameImage 的实现代码非常简单，初始化方法大致可以分为以下步骤：</p>
<ul>
<li>入参校验</li>
<li>根据入参取到首张图片</li>
<li>用首图初始化 <code>_oneFrameBytes</code> ，如入参初始化 <code>_imageDatas</code> ，<code>_frameDurations</code> 和 <code>_loopCount</code></li>
<li>用 <code>UIImage</code> 的 <code>initWithCGImage:scale:orientation:</code> 初始化并返回初始化结果</li>
</ul>
<h3 id="YYSpriteSheetImage"><a href="#YYSpriteSheetImage" class="headerlink" title="YYSpriteSheetImage"></a>YYSpriteSheetImage</h3><img src="/yyimage/ss_wukong.png" class="">
<p>YYSpriteSheetImage 是用来做 Spritesheet 动画显示的图像类，它也是 UIImage 的子类。</p>
<p>关于 Spritesheet 可能做过游戏开发或者以前鼓捣过简单网页游戏 Demo 的同学会很熟悉，其动画原理是把一个动画过程分解为多个动画帧，按照顺序将这些动画帧排布在一张大的画布中，播放动画时只需要按照每一帧图像的尺寸大小以及对应索引去画布中提取对应的帧替换显示以达到人眼判定动画的效果，点击 <a target="_blank" rel="noopener" href="https://gamedevelopment.tutsplus.com/tutorials/an-introduction-to-spritesheet-animation--gamedev-13099"><br>An Introduction to Spritesheet Animation</a> 或者 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/what-is-a-sprite-sheet">What is a sprite sheet?</a> 了解更多关于 Spritesheet 动画的信息。</p>
<blockquote>
<p>Note: 关于 SpriteSheet 素材的制作有一款工具 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/sprite-sheet-maker">SpriteSheetMaker</a> 推荐使用。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYSpriteSheetImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方法，这个第一次接触 Spritesheet 的同学可能会觉得比较繁琐</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithSpriteSheetImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                     contentRects:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)contentRects</span><br><span class="line">                                   frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                        loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *contentRects; <span class="comment">// 帧位置信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *frameDurations; <span class="comment">// 帧持续时长</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount; <span class="comment">// 循环数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引找到对应帧 CALayer 的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)contentsRectForCALayerAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其中初始化方法的入参为 SpriteSheet 画布（包含所有动画帧的大图）image，每一帧的位置 contentRects，每一帧对应的持续显示时间 frameDurations，循环次数 loopCount，初始化示例在 YYImage 源文件 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYSpriteSheetImage.h#L32">YYSpriteSheetImage.h</a> 注释中有写。</p>
<blockquote>
<p>Note: 下文中要讲的 YYAnimatedImageView 中定义了 YYAnimatedImage 协议，这个协议中有一个可选方法 <code>animatedImageContentsRectAtIndex:</code> 就是为 YYSpriteSheetImage 量身打造的。</p>
</blockquote>
<p>这里需要提一下 <code>contentsRectForCALayerAtIndex:</code> 接口会根据索引找到对应帧的 CALayer 位置，该接口返回一个由 0.0~1.0 之间的数值组成的图层定位 LayerRect，如果在查找位置过程中发现异常则返回 CGRectMake(0, 0, 1, 1)，其内部实现大体步骤：</p>
<ul>
<li>校验入参索引是否超过 SpriteSheet 分割帧总数，超过返回 CGRectMake(0, 0, 1, 1)</li>
<li>没超过则通过 YYAnimatedImage 协议的 <code>animatedImageContentsRectAtIndex:</code> 方法找到对应索引的真实位置 RealRect</li>
<li>通过真实位置 RealRect 与 SpriteSheet 画布的比算错 0.0~1.0 之间的值，得到指定索引帧的逻辑定位 LogicRect</li>
<li>通过 <code>CGRectIntersection</code> 方法计算逻辑定位 LogicRect 与 CGRectMake(0, 0, 1, 1) 的交集，确保逻辑定位没有超出画布的部分</li>
<li>将处理后的逻辑定位 LogicRect 作为图层定位 LayerRect 返回</li>
</ul>
<p>返回的 LayerRect 作为对应索引帧的画布内相对位置存在，结合画布就可以定位到对应帧图像的具体尺寸和位置。</p>
<h2 id="YYAnimatedImageView"><a href="#YYAnimatedImageView" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h2><img src="/yyimage/blood_wheel_eye.jpeg" class="">
<p>人眼中呈现的动画是由一幅幅内容连贯的图像以较短时间按顺序替换形成的，所以要显示动画只需要知道动画顺序中每一帧图像以及对应的显示时间等信息即可。YYImage 中对应于 UIImage 层级的内容（YYImage, YYFrameImage, YYSpriteSheetImage）在上文已经介绍过了，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImageView 是 YYImage 的重要组成，它是 UIImageView 的子类，负责 YYImage 图像层中不同的图像类的视图显示（包含动态图像的动画播放），其内部包含 YYAnimatedImage 协议以及 YYAnimatedImageView 自身两部分。</p>
<h3 id="YYAnimatedImage-协议"><a href="#YYAnimatedImage-协议" class="headerlink" title="YYAnimatedImage 协议"></a>YYAnimatedImage 协议</h3><p>上文提到不论是 YYImage, YYFrameImage, YYSpriteSheetImage 还是以后可能会扩展的图像类，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImage 协议就是在不影响原来图像类的情况下把不同图像类之间的共性找出来（求同存异？笑），以统一化的接口将人眼动画呈现所需的基本信息输出给 YYAnimatedImageView 使用的协议。</p>
<blockquote>
<p>Note: 作为图像类须遵循 YYAnimatedImage 协议以便可以使用 YYAnimatedImageView 播放动画。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YYAnimatedImage</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">// 动画帧总数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageFrameCount;</span><br><span class="line"><span class="comment">// 动画循环次数，0 表示无限循环</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageLoopCount;</span><br><span class="line"><span class="comment">// 每帧字节数（在内存中），可能用于优化内存缓冲区大小</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageBytesPerFrame;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像，这个方法可能在异步线程中调用</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)animatedImageFrameAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像对应的显示持续时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)animatedImageDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 针对 Spritesheet 动画的方法，用于显示某一帧图像在 Spritesheet 画布中的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)animatedImageContentsRectAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文提到过可选实现接口 <code>animatedImageContentsRectAtIndex:</code> 是专为 Spritesheet 动画设计的。</p>
</blockquote>
<p>像这样规定一个协议，使不相关的类遵循此协议拥有统一的功能接口方便另一个类调用的设计思想我们在自己日常项目的开发过程中很多场景都可以用到，例如可以封装一个 TableView，设计一个 TableViewCell 协议，让所有 TableViewCell 都实现这个协议以拥有统一的功能接口，然后我们封装的 TableView 类就可以统一的使用这些 TableViewCell 显示数据啦，省去了反复写相同功能 UITableView 的劳动力（实际应用场景很多，这里只是简单举例，抛砖引玉）。</p>
<h3 id="YYAnimatedImageView-1"><a href="#YYAnimatedImageView-1" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h3><p>上文提到过 YYAnimatedImageView 作为 YYImage 框架中的图片视图层，上接图像层，下启编/解码底层，是枢纽一般的存在（承上启下啊有木有？），我们需要重点研究其内部实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span> : <span class="title">UIImageView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 image 为多帧组成时，自动赋值为 YES，可以在显示和隐藏时自动播放和停止动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> autoPlayAnimatedImage;</span><br><span class="line"><span class="comment">// 当前显示的帧（从 0 起始），设置新值后会立即显示对应帧，如果新值无效则此方法无效</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> currentAnimatedImageIndex;</span><br><span class="line"><span class="comment">// 当前是否在播放动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line"><span class="comment">// 动画定时器所在的 runloop mode，默认为 NSRunLoopCommonModes，关乎动画定时器的触发</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *runloopMode;</span><br><span class="line"><span class="comment">// 内部缓存区的最大值（in bytes），默认为 0（动态），如果有值将会把缓存区限制为值大小，当收到内存警告或者 App 进入后台时，缓存区将会立即释放并且在适时的时候回复原状</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxBufferSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>额…出乎意料的简单呢~ 只有一些属性暴露出来以便我们在使用过程中实时查看动画的播放状态以及内存使用情况。笔者看源码总结出一条经验，即<strong>如果某个组件在库中占据重要地位，其 .h 文件中暴露的内容越是简单，其 .m 内部实现就越是复杂</strong>。</p>
<p>通过 <code>runloopMode</code> 属性大家用猜的也应该可以猜出 YYAnimatedImageView 内部实现动画的原理离不开 RunLoop，而且极有可能是用定时器 NSTimer 或者 CADisplayLink 实现的。下面我们来对 YYAnimatedImageView 的实现剖析，验证一下我们刚才的猜想。</p>
<h4 id="YYAnimatedImageView-的实现剖析"><a href="#YYAnimatedImageView-的实现剖析" class="headerlink" title="YYAnimatedImageView 的实现剖析"></a>YYAnimatedImageView 的实现剖析</h4><p>YYAnimatedImageView 内部实现源码很有趣，有很多值得分享的地方。不过为了不把文章写成 MarkDown 编辑器文（笑~）笔者不会逐行翻译源码。读者如果想要知道实现的细节建议结合文章去翻阅源码。相信有了文章梳理的思路源码看起来应该不会有太大的困难，文章还是重在传播实现思想和一些值得分享的技巧。</p>
<p>我们先简单看一下 YYAnimatedImageView 的内部结构，方便后面分析实现思路时大家脑中对 YYAnimatedImageView 的结构提前有一个大概的认识。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *_curAnimatedImage; <span class="comment">///&lt; 当前图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once_t</span> _onceToken; <span class="comment">///&lt; 用于确保初始化代码只执行一次</span></span><br><span class="line">    dispatch_semaphore_t _lock; <span class="comment">///&lt; 信号量锁（用于 _buffer）</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *_requestQueue; <span class="comment">///&lt; 图片请求队列，串行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_link; <span class="comment">///&lt; 帧转换</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">///&lt; 上一帧之后的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *_curFrame; <span class="comment">///&lt; 当前帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curIndex; <span class="comment">///&lt; 当前帧索引</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalFrameCount; <span class="comment">///&lt; 帧总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _loopEnd; <span class="comment">///&lt; 是否在循环末尾</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curLoop; <span class="comment">///&lt; 当前循环次数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalLoop; <span class="comment">///&lt; 总循环次数, 0 表示无穷</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_buffer; <span class="comment">///&lt; 帧缓冲区</span></span><br><span class="line">    <span class="type">BOOL</span> _bufferMiss; <span class="comment">///&lt; 是否丢帧，在上面 _link 定时执行的 step 函数中从帧缓冲区读取下一帧图片时如果没读到，则视为丢帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _maxBufferCount; <span class="comment">///&lt; 最大缓冲计数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _incrBufferCount; <span class="comment">///&lt; 当前允许的缓存区计数（将逐步增加）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> _curContentsRect; <span class="comment">///&lt; 针对 YYSpriteSheetImage</span></span><br><span class="line">    <span class="type">BOOL</span> _curImageHasContentsRect; <span class="comment">///&lt; 图像类是否实现了 animatedImageContentsRectAtIndex: 接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line">- (<span class="type">void</span>)calcMaxBufferCount; <span class="comment">// 动态调节缓冲区最大限制 _maxBufferCount</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYAnimatedImageView 内部结构比 .h 中暴露的属性要复杂的多，而 <code>CADisplayLink *_link</code> 属性也证实了我们之前关于 .h 中 <code>runloopMode</code> 属性的猜想。</p>
<p>YYAnimatedImageView 内部的初始化没什么特别之处，初始化函数中会设置图片，当判定图片有更改时会依照下面 4 步去处理：</p>
<ul>
<li>改变图片</li>
<li>重置动画</li>
<li>初始化动画参数</li>
<li>重绘</li>
</ul>
<blockquote>
<p>Note: 这样可以保证 YYAnimatedImageView 的图片更改时都会执行上面的步骤为新的图片初始化配套的新动画参数并且重绘，而重置动画实现中会使用到上面的 <code>dispatch_once_t _onceToken;</code> 以确保某些内部变量的创建以及对 App 内存警告和进入后台的通知观察代码只执行一次。</p>
</blockquote>
<p>YYAnimatedImageView 使图片动起来是依靠 <code>CADisplayLink *_link;</code> 变量切换帧图像，其内部的实现逻辑可以简单理解为：</p>
<ul>
<li>根据当前帧索引推出下一帧索引</li>
<li>使用下一帧索引去帧缓冲区尝试获取对应帧图像</li>
<li>如果找到对应帧图像则使用其重绘</li>
<li>如果没找到则根据条件向图片请求队列加入请求操作（向图片缓冲区录入之后的帧图像数据）</li>
</ul>
<p>嘛~ 这里面有一些值得一提的实现细节哈！</p>
<blockquote>
<ul>
<li>YYAnimatedImageView 实现中当 <code>_curIndex</code> 即当前帧索引修改时在修改代码前后加入了 <code>willChangeValueForKey:</code> 与 <code>didChangeValueForKey:</code> 方法以支持 KVO</li>
<li>对帧缓冲区 <code>_buffer</code> 的操作都使用 <code>_lock</code> 上锁</li>
<li>通过将图片请求队列 <code>_requestQueue</code> 的 <code>maxConcurrentOperationCount</code> 设置为 1 使图片请求队列成为串行队列（最大并发数为 1）</li>
<li>图片请求队列中加入的操作均为 <code>_YYAnimatedImageViewFetchOperation</code></li>
<li>为了避免使用 <code>CADisplayLink</code> 可能造成的循环引用设计了 <code>_YYImageWeakProxy</code></li>
</ul>
</blockquote>
<p>先看一下 <code>_YYAnimatedImageViewFetchOperation</code> 的源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYAnimatedImageViewFetchOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) YYAnimatedImageView *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> nextIndex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *curImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYAnimatedImageViewFetchOperation</span></span></span><br><span class="line">- (<span class="type">void</span>)main &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>_YYAnimatedImageViewFetchOperation</code> 继承自 NSOperation 类，是自定义操作类，作者将其操作内容实现写在了 <code>main</code> 中，代码太长而且我觉得贴出来不仅不会帮助读者理解反而会因为片面的源码实现影响读者对 YYAnimatedImageView 的整体实现思路理解（因为大量贴源码会使文章生涩很多，而且会把读者注意力转移到某一个实现），这里简单描述一下 <code>main</code> 函数内部实现逻辑：</p>
<ul>
<li>判断帧缓冲区大小</li>
<li>扫描下一帧以及当前允许缓冲范围内之后的帧图片</li>
<li>如果发现丢失的帧则尝试重新获取帧图像并加入到帧缓冲</li>
</ul>
<p>嘛~ 不贴源码归不贴源码，该注意的细节还是需要列出来的（笑）。</p>
<blockquote>
<ul>
<li>操作中对于 <code>view</code> 缓冲区的操作也都上了锁</li>
<li>操作由于是放入图片请求队列中进行的，内部有对 <code>isCancelled</code> 做判断，如果操作已经被取消（发生在更改图片、停止动画、手动更改当前帧、收到内存警告或 App 进入后台等）则需要及时跳出</li>
<li>对于新的线程优先级只在 <code>main</code> 方法范围内有效，所以推荐把操作的实现放在 <code>main</code> 中而非 <code>start</code>（如需覆盖 start 方法时，需要关注 <code>isExecuting</code> 和 <code>isFinished</code> 两个 key paths）</li>
</ul>
</blockquote>
<p>YYAnimatedImageView 内部设计了 <code>_YYImageWeakProxy</code> 来避免使用 NSTimer 或者 CADisplayLink 可能造成的循环引用问题，<code>_YYImageWeakProxy</code> 内部实现也比较简单，继承自 NSProxy，关于 NSProxy 可以查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsproxy">官方文档</a>以了解更多。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYImageWeakProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="type">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYImageWeakProxy</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> _target;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="type">void</span> *null = <span class="literal">NULL</span>;</span><br><span class="line">    [invocation setReturnValue:&amp;null];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(init)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面贴出的源码省略了比较基础的实现部分，<code>_YYImageWeakProxy</code> 内部弱引用一个对象 target，对于 <code>_YYImageWeakProxy</code> 的一些基本操作包含 <code>hash</code> 和 <code>isEqual</code> 这些统统都转到 target 上，并且使用 <code>forwardingTargetForSelector:</code> 消息重定向将不能响应的运行时消息也重定向给 target 来响应。</p>
<p>Emmmmm..那么问题来了，既然都消息重定向给 target 了还要消息转发干嘛？因为要避免循环引用问题所以对 target 使用弱引用，期间无法保证 target 一定存在，所以 <code>forwardingTargetForSelector:</code> 方法可能返回 nil，接着在 Runtime 消息转发中借用 init 消息返回空以“吞掉”异常。</p>
<blockquote>
<p>Note: 消息转发产生的开销要比动态方法解析和消息重定向大。</p>
</blockquote>
<h2 id="YYImageCoder"><a href="#YYImageCoder" class="headerlink" title="YYImageCoder"></a>YYImageCoder</h2><img src="/yyimage/image_coder.jpg" class="">
<p>YYImageCoder 作为 YYImage 的编/解码器，对应于 iOS 中的 ImageIO.framework 图片编/解码库，正是因为有了 YYImageCoder 的存在，YYImage 才得以支持如此多的图片格式，所以说 YYImageCoder 是 YYImage 的底层核心。</p>
<p>YYImageCoder 内部定义了许多 YYImage 中用到的核心数据结构：</p>
<ul>
<li>YYImageType，所有的支持的图片格式做了枚举定义</li>
<li>YYImageDisposeMethod，指定在画布上渲染下一个帧之前如何处理当前帧所使用的区域方法</li>
<li>YYImageBlendOperation，指定当前帧的透明像素如何与前一个画布的透明像素混合操作</li>
<li>YYImageFrame，一帧图像数据</li>
<li>YYImageEncoder，图像编码器</li>
<li>YYImageDecoder，图像解码器</li>
<li>UIImage+YYImageCoder，UIImage 的分类，里面提供了一些方便使用的方法</li>
</ul>
<p>其中 YYImageFrame 是对一帧图像数据的封装，便于在 YYImageCoder 编/解码过程中使用。</p>
<p>YYImageCoder 内部图像编码器 YYImageEncoder 和图像解码器 YYImageDecoder 其实是分开来的，我们下面分别对它们做分析。</p>
<h3 id="YYImageEncoder"><a href="#YYImageEncoder" class="headerlink" title="YYImageEncoder"></a>YYImageEncoder</h3><p>先来讲一下 YYImageEncoder，其在 YYImageCoder 中担任编码器的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageEncoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type; <span class="comment">///&lt; 图像类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> loopCount;       <span class="comment">///&lt; 循环次数，0 无限循环，仅适用于 GIF/APNG/WebP 格式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> lossless;              <span class="comment">///&lt; 无损标记，仅适用于 WebP.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> quality;            <span class="comment">///&lt; 压缩质量，0.0~1.0，仅适用于 JPG/JP2/WebP.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止适用 init、new 初始化编码器（我没忘记我说过这些编码技巧会在之后统一写一篇文章汇总）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定图片类型创建编码器</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithType:(YYImageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 添加图像</span></span><br><span class="line">- (<span class="type">void</span>)addImage:(<span class="built_in">UIImage</span> *)image duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加图像数据</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithData:(<span class="built_in">NSData</span> *)data duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加文件路径</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithFile:(<span class="built_in">NSString</span> *)path duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 开始图像编码并尝试返回编码后的数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encode;</span><br><span class="line"><span class="comment">// 编码并将得到的数据保存到给定路径文件中</span></span><br><span class="line">- (<span class="type">BOOL</span>)encodeToFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line"><span class="comment">// 便捷方法，对一个单帧图像编码</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImage:(<span class="built_in">UIImage</span> *)image type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"><span class="comment">// 便捷方法，从解码器中编码图像数据</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImageWithDecoder:(YYImageDecoder *)decoder type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageEncoder 内部的一些属性和接口都比较基本，关于其内部实现我们需要先看一下私有变量：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageEncoder</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_images; <span class="comment">// 已添加到编码器的图片（数组）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_durations; <span class="comment">// 对应的图片帧显示持续时长（数组）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="YYImageEncoder-的实现思路"><a href="#YYImageEncoder-的实现思路" class="headerlink" title="YYImageEncoder 的实现思路"></a>YYImageEncoder 的实现思路</h4><p>YYImageEncoder 的初始化部分没有多复杂，根据图片的类型按照编码最优的参数做初始化而已。关于 YYImageEncoder 对于图片的编码工作，其实作者根据要支持的图片类型和对应图片类型的编码方式做了底层封装，再根据当前图片的类型选择对应的底层编码方法执行。</p>
<p>关于不同图片类型的图片编码格式可以查阅本文文末的扩展阅读章节，结合扩展阅读的内容查阅 YYImage 这部分源码可以理解作者对于底层图片格式信息的结构封装以及编/解码操作具体实现。</p>
<p>关于 YYImageEncoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L216">YYImageCoder.h</a> 了解。</p>
<h3 id="YYImageDecoder"><a href="#YYImageDecoder" class="headerlink" title="YYImageDecoder"></a>YYImageDecoder</h3><p>YYImageDecoder 在 YYImageCoder 中担任解码器的角色，其与上述 YYImageEncoder 对应，一个负责图像编码一个负责图像解码，不过 YYImageDecoder 的实现比 YYImageEncoder 更为复杂。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageDecoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *data;    <span class="comment">///&lt; 图像数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type;          <span class="comment">///&lt; 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> scale;             <span class="comment">///&lt; 图像大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> frameCount;     <span class="comment">///&lt; 图像帧数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount;      <span class="comment">///&lt; 图像循环次数，0 无限循环</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> width;          <span class="comment">///&lt; 图像画布宽度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> height;         <span class="comment">///&lt; 图像画布高度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinalized) <span class="type">BOOL</span> finalized;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个图像解码器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithScale:(<span class="built_in">CGFloat</span>)scale <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 用新数据增量更新图像</span></span><br><span class="line">- (<span class="type">BOOL</span>)updateData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data final:(<span class="type">BOOL</span>)final;</span><br><span class="line"><span class="comment">// 方便用一个特殊的数据创建对应的解码器</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)decoderWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"><span class="comment">// 解码并返回给定索引对应的帧数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYImageFrame *)frameAtIndex:(<span class="built_in">NSUInteger</span>)index decodeForDisplay:(<span class="type">BOOL</span>)decodeForDisplay;</span><br><span class="line"><span class="comment">// 返回给定索引对应的帧持续显示时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定索引对应帧的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)framePropertiesAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回图片的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)imageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageDecoder 暴露了一些关于解码图像的属性并提供了初始化解码器方法、图像解码方法以及访问图像帧信息的方法。不过上文也说过 YYImageDecoder 的实现比较复杂，我们接着看一下其内部变量结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageDecoder</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 递归锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _sourceTypeDetected; <span class="comment">// 是否推测图像源类型</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> _source; <span class="comment">// 图像源</span></span><br><span class="line">    yy_png_info *_apngSource; <span class="comment">// 如果判定图像为 YYImageTypePNG 则会以 APNG 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> YYIMAGE_WEBP_ENABLED</span></span><br><span class="line">    WebPDemuxer *_webpSource; <span class="comment">// 如果判定图像为 YYImageTypeWebP 则会议 WebP 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImageOrientation</span> _orientation; <span class="comment">// 绘制方向</span></span><br><span class="line">    dispatch_semaphore_t _framesLock; <span class="comment">// 针对于图像帧的锁</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_frames; <span class="comment">///&lt; Array&lt;_YYImageDecoderFrame *&gt;, without image</span></span><br><span class="line">    <span class="type">BOOL</span> _needBlend; <span class="comment">// 是否需要混合</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _blendFrameIndex; <span class="comment">// 从帧索引混合到当前帧</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> _blendCanvas; <span class="comment">// 混合画布</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_YYImageDecoderFrame</code> 继承自 YYImageFrame 类作为 YYImageCoder 图像解码器 YYImageDecoder 使用的内部框架类存在，是对于一帧图像的数据封装提供了便于编/解码时需要访问的数据。</p>
<h4 id="YYImageDecoder-内锁的选择"><a href="#YYImageDecoder-内锁的选择" class="headerlink" title="YYImageDecoder 内锁的选择"></a>YYImageDecoder 内锁的选择</h4><p>可以看到作者在 YYImageDecoder 内部使用了两种锁：</p>
<ul>
<li><code>pthread_mutex_t _lock;</code></li>
<li><code>dispatch_semaphore_t _framesLock;</code></li>
</ul>
<p><code>pthread_mutex_t</code> 在解码器初始化过程中被以 <code>PTHREAD_MUTEX_RECURSIVE</code> 类型设置为了递归锁。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init (&amp;attr);</span><br><span class="line">pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init (&amp;_lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy (&amp;attr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 一般情况下一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p>
<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 <code>pthread_mutex</code> 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 <code>PTHREAD_MUTEX_RECURSIVE</code> 即可。</p>
</blockquote>
<p>作者使用 <code>dispatch_semaphore_t</code> 作为图像帧数组的锁是因为 <code>dispatch_semaphore_t</code> 更加轻量且对于图像帧数组的临界操作比较快，不会造成长时间的阻塞，这种情况下 <code>dispatch_semaphore_t</code> 具有性能优势（Emmmmmm..老生常谈了，熟悉的同学不要抱怨，照顾一下后面的同学）。</p>
<h4 id="YYImageDecoder-内的实现思路"><a href="#YYImageDecoder-内的实现思路" class="headerlink" title="YYImageDecoder 内的实现思路"></a>YYImageDecoder 内的实现思路</h4><p>YYImageDecoder 内在初始化时会初始化锁并更新图像源数据，在更新图像源时调用 <code>_updateSource</code> 方法根据当前图像类型以作者对该类型封装好的底层数据结构和对应图像类型解码规则做解码，解码之后设置对应属性。</p>
<p>关于作者对不同格式的图像数据的底层封装源码感兴趣的读者可以参考本文文末的扩展阅读章节内容自行查阅。</p>
<p>关于 YYImageDecoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L106">YYImageCoder.h</a> 了解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的分析了 YYImage 源码，希望各位读者在阅读本文之后可以对 YYImage 整体架构和设计思路有清晰的认识。</li>
<li>文章对 YYImage 的 Image 层级的三类图像（YYImage, YYFrameImage, YYSpriteSheetImage）分别解读，希望可以对各位读者关于这三类图像的组成原理和呈现动画的方式的理解有所帮助。</li>
<li>文章深入剖析了 YYAnimatedImageView 的内部实现，提炼出其设计思路以供读者探究。</li>
<li>笔者把自己在阅读源码中发现的值得分享的实现细节结合源码单独拎出来分析，希望各位读者可以在自己平时工作中遇到相似情况时能够多一些思路，封装项目组件时可以用到这些技巧。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明出处 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。能力不足，水平有限，如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我，另外我的 <a target="_blank" rel="noopener" href="https://github.com/Lision">GitHub 主页</a> 里有很多有趣的小玩意哦~</p>
<p>最后，希望我的文章可以为你带来价值~</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">libpng 官网关于 PNG 结构的官方说明</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.mozilla.org/APNG_Specification">APNG 的维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/api">WebP 开发者文档</a></li>
</ul>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yyimage/" rel="tag">yyimage</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yymodel0x02/">
      揭秘 YYModel 的魔法 0x02
    </a>
  </h2>
  
  <time>
    11月 19, 2017
  </time>
  <section class="content">
	  <img src="/yymodel0x02/design_model_0x02.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上文<a href="https://lision.me/yymodel_x01/">《揭秘 YYModel 的魔法（上）》</a> 中主要剖析了 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a> 的源码结构，并且分享了 YYClassInfo 与 NSObject+YYModel 内部有趣的实现细节。</p>
<p>紧接上篇，本文将解读 YYModel 关于 JSON 模型转换的源码，旨在揭秘 JSON 模型自动转换魔法。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>JSON 与 Model 相互转换</li>
<li>总结</li>
</ul>
<h2 id="JSON-与-Model-相互转换"><a href="#JSON-与-Model-相互转换" class="headerlink" title="JSON 与 Model 相互转换"></a>JSON 与 Model 相互转换</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它易于人们阅读和编写，同时也易于机器解析和生成。它是基于 <a target="_blank" rel="noopener" href="http://www.crockford.com/javascript/">JavaScript Programming Language</a>, <a target="_blank" rel="noopener" href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Standard ECMA-262 3rd Edition - December 1999</a> 的一个子集。JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使 JSON 成为理想的数据交换语言，点击 <a target="_blank" rel="noopener" href="https://www.json.org/json-zh.html">这里</a> 了解更多关于 JSON 的信息。</p>
<p>Model 是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象编程</a>（Object Oriented Programming，简称 OOP）程序设计思想中的对象，OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。一般我们会根据业务需求来创建对象，在一些设计模式中（如 MVC 等）对象一般作为模型（Model），即对象建模。</p>
<p>JSON 与 Model 相互转换按转换方向分为两种：</p>
<ul>
<li>JSON to Model</li>
<li>Model to JSON</li>
</ul>
<img src="/yymodel0x02/switch.jpg" class="">
<h3 id="JSON-to-Model"><a href="#JSON-to-Model" class="headerlink" title="JSON to Model"></a>JSON to Model</h3><p>我们从 YYModel 的接口开始解读。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithJSON:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="comment">// 将 json 转为字典 dic</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = [<span class="keyword">self</span> _yy_dictionaryWithJSON:json];</span><br><span class="line">    <span class="comment">// 再通过 dic 得到 model 并返回</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelWithDictionary:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面接口把 JSON 转 Model 很简单的分为了两个子任务：</p>
<ul>
<li>JSON to NSDictionary</li>
<li>NSDictionary to Model</li>
</ul>
<img src="/yymodel0x02/j2d2m.jpg" class="">
<h4 id="JSON-to-NSDictionary"><a href="#JSON-to-NSDictionary" class="headerlink" title="JSON to NSDictionary"></a>JSON to NSDictionary</h4><p>我们先看一下 <code>_yy_dictionaryWithJSON</code> 是怎么将 json 转为 NSDictionary 的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)_yy_dictionaryWithJSON:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="comment">// 入参判空</span></span><br><span class="line">    <span class="keyword">if</span> (!json || json == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *jsonData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据 json 的类型对应操作</span></span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSDictionary 类则直接赋值</span></span><br><span class="line">        dic = json;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSString 类则用 UTF-8 编码转 NSData</span></span><br><span class="line">        jsonData = [(<span class="built_in">NSString</span> *)json dataUsingEncoding : <span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSData 则直接赋值给 jsonData</span></span><br><span class="line">        jsonData = json;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// jsonData 不为 nil，则表示上面的 2、3 情况中的一种</span></span><br><span class="line">    <span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">        <span class="comment">// 利用 NSJSONSerialization 方法将 jsonData 转为 dic</span></span><br><span class="line">        dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line">        <span class="comment">// 判断转换结果 </span></span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) dic = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是根据入参的类型判断如何将其转为 NSDictionary 类型并返回。</p>
<p>其中 <code>kCFNull</code> 是 CoreFoundation 中 CFNull 的单例对象。如同 Foundation 框架中的 NSNull 一样，CFNull 是用来表示集合对象中的空值（不允许为 NULL）。CFNull 对象既不允许被创建也不允许被销毁，而是通过定义一个 CFNull 常量，即 <code>kCFNull</code>，在需要空值时使用。</p>
<blockquote>
<p>官方文档：<br>The CFNull opaque type defines a unique object used to represent null values in collection objects (which don’t allow NULL values). CFNull objects are neither created nor destroyed. Instead, a single CFNull constant object—<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/kcfnull">kCFNull</a>—is defined and is used wherever a null value is needed.</p>
</blockquote>
<p>NSJSONSerialization 是用于将 JSON 和等效的 Foundation 对象之间相互转换的对象。它在 iOS 7 以及 macOS 10.9（包含 iOS 7 和 macOS 10.9）之后是线程安全的。</p>
<p>代码中将 NSString 转为 NSData 用到了 NSUTF8StringEncoding，其中编码类型必须属于 JSON 规范中列出的 5 种支持的编码类型：</p>
<ul>
<li>UTF-8</li>
<li>UTF-16LE</li>
<li>UTF-16BE</li>
<li>UTF-32LE</li>
<li>UTF-32BE</li>
</ul>
<p>而用于解析的最高效的编码是 UTF-8 编码，所以作者这里使用 NSUTF8StringEncoding。</p>
<blockquote>
<p>官方注释：<br>The data must be in one of the 5 supported encodings listed in the JSON specification: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. The data may or may not have a BOM. The most efficient encoding to use for parsing is UTF-8, so if you have a choice in encoding the data passed to this method, use UTF-8.</p>
</blockquote>
<h4 id="NSDictionary-to-Model"><a href="#NSDictionary-to-Model" class="headerlink" title="NSDictionary to Model"></a>NSDictionary to Model</h4><p>现在我们要从 <code>yy_modelWithJSON</code> 接口中探究 <code>yy_modelWithDictionary</code> 是如何将 NSDictionary 转为 Model 的。</p>
<p>敲黑板！做好准备，这一小节介绍的代码是 YYModel 的精华哦~。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    <span class="comment">// 入参校验</span></span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用当前类生成一个 _YYModelMeta 模型元类</span></span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</span><br><span class="line">    <span class="comment">// 这里 _hasCustomClassFromDictionary 用于标识是否需要自定义返回类</span></span><br><span class="line">    <span class="comment">// 属于模型转换附加功能，可以不用投入太多关注</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 yy_modelSetWithDictionary 为新建的类实例 one 赋值，赋值成功则返回 one</span></span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="comment">// 所以这个函数中我们应该把注意力集中在 yy_modelSetWithDictionary</span></span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中根据 <code>_hasCustomClassFromDictionary</code> 标识判断是否需要自定义返回模型的类型。这段代码属于 YYModel 的附加功能，为了不使大家分心，这里仅做简单介绍。</p>
<p>如果我们要在 JSON 转 Model 的过程中根据情况创建不同类型的实例，则可以在 Model 中实现接口：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br></pre></td></tr></table></figure>
<p>来满足需求。当模型元初始化时会检测当前模型类是否可以响应上面的接口，如果可以响应则会把 <code>_hasCustomClassFromDictionary</code> 标识为 YES，所以上面才会出现这些代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">    cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 我觉得这些附加的东西在阅读源码时很大程度上会分散我们的注意力，这次先详细的讲解一下，以后遇到类似的代码我们会略过，内部的实现大都与上述案例原理相同，感兴趣的同学可以自己研究哈。</p>
<p>我们应该把注意力集中在 <code>yy_modelSetWithDictionary</code> 上，这个函数（其实也是 NSObject+YYModel 暴露的接口）是根据字典初始化模型的实现方法。它的代码比较长，如果不想看可以跳过，在后面有解释。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="comment">// 入参校验</span></span><br><span class="line">    <span class="keyword">if</span> (!dic || dic == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据自身类生成 _YYModelMeta 模型元类</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="comment">// 如果模型元类键值映射数量为 0 则 return NO，表示构建失败</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，该标识对应 modelCustomWillTransformFromDictionary 接口</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        <span class="comment">// 该接口类似 modelCustomTransformFromDictionary 接口，不过是在模型转换之前调用的</span></span><br><span class="line">        dic = [((<span class="type">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化模型设置上下文 ModelSetContext</span></span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.modelMeta = (__bridge <span class="type">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="type">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="type">void</span> *)(dic);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断模型元键值映射数量与 JSON 所得字典的数量关系</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line">        <span class="comment">// 一般情况下他们的数量相等</span></span><br><span class="line">        <span class="comment">// 特殊情况比如有的属性元会映射字典中的多个 key</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为字典中的每个键值对调用 ModelSetWithDictionaryFunction</span></span><br><span class="line">        <span class="comment">// 这句话是核心代码，一般情况下就是靠 ModelSetWithDictionaryFunction 通过字典设置模型</span></span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        <span class="comment">// 判断模型中是否存在映射 keyPath 的属性元</span></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="comment">// 为每个映射 keyPath 的属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断模型中是否存在映射多个 key 的属性元</span></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="comment">// 为每个映射多个 key 的属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模型元键值映射数量少，则认为不存在映射多个 key 的属性元</span></span><br><span class="line">        <span class="comment">// 直接为每个 modelMeta 属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，该标识对应接口 modelCustomTransformFromDictionary</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        <span class="comment">// 该接口用于当默认 JSON 转 Model 不适合模型对象时做额外的逻辑处理</span></span><br><span class="line">        <span class="comment">// 我们也可以用这个接口来验证模型转换的结果</span></span><br><span class="line">        <span class="keyword">return</span> [((<span class="type">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码已经注明必要中文注释，关于两处自定义扩展接口我们不再多说，由于代码比较长我们先来梳理一下 <code>yy_modelSetWithDictionary</code> 主要做了哪些事？</p>
<ul>
<li>入参校验</li>
<li>初始化模型元以及映射表校验</li>
<li>初始化模型设置上下文 <code>ModelSetContext</code></li>
<li>为字典中的每个键值对调用 <code>ModelSetWithDictionaryFunction</code></li>
<li>检验转换结果</li>
</ul>
<p>模型设置上下文 <code>ModelSetContext</code> 其实就是一个包含模型元，模型实例以及待转换字典的结构体。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">void</span> *modelMeta;  <span class="comment">///&lt; 模型元</span></span><br><span class="line">    <span class="type">void</span> *model;      <span class="comment">///&lt; 模型实例，指向输出的模型</span></span><br><span class="line">    <span class="type">void</span> *dictionary; <span class="comment">///&lt; 待转换字典</span></span><br><span class="line">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure>
<p>大家肯定都注意到了 <code>ModelSetWithDictionaryFunction</code> 函数，不论走哪条逻辑分支，最后都是调用这个函数把字典的 key（keypath）对应的 value 取出并赋值给 Model 的，那么我们就来看看这个函数的实现。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典键值对建模</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="type">void</span> *_key, <span class="keyword">const</span> <span class="type">void</span> *_value, <span class="type">void</span> *_context) &#123;</span><br><span class="line">    <span class="comment">// 拿到入参上下文</span></span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    <span class="comment">// 取出上下文中模型元</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    <span class="comment">// 根据入参 _key 从模型元中取出映射表对应的属性元</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="type">id</span>)(_key)];</span><br><span class="line">    <span class="comment">// 拿到待赋值模型</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> model = (__bridge <span class="type">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="comment">// 遍历 propertyMeta，直到 propertyMeta-&gt;_next == nil</span></span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="comment">// 当前遍历的 propertyMeta 有 setter 方法，则调用 ModelSetValueForProperty 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123;</span><br><span class="line">            <span class="comment">// 核心方法，拎出来讲</span></span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="type">id</span>)_value, propertyMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModelSetWithDictionaryFunction</code> 函数的实现逻辑就是先通过模型设置上下文拿到带赋值模型，之后遍历当前的属性元（直到 propertyMeta-&gt;_next == nil），找到 <code>setter</code> 不为空的属性元通过 <code>ModelSetValueForProperty</code> 方法赋值。</p>
<p><code>ModelSetValueForProperty</code> 函数是为模型中的属性赋值的实现方法，也是整个 YYModel 的核心代码。别紧张，这个函数写得很友好的，也就 300 多行而已 😜（无关紧要的内容我会尽量忽略掉），不过忽略的太多会影响代码阅读的连续性，如果嫌长可以不看，文章后面会总结一下这个函数的实现逻辑。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> ModelSetValueForProperty(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> model,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> value,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="comment">// 如果属性是一个 CNumber，即输入 int、uint……</span></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;_isCNumber) &#123;</span><br><span class="line">        <span class="comment">// 转为 NSNumber 之后赋值</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *num = YYNSNumberCreateFromID(value);</span><br><span class="line">        <span class="comment">// 这里 ModelSetNumberToProperty 封装了给属性元赋值 NSNumber 的操作</span></span><br><span class="line">        ModelSetNumberToProperty(model, num, meta);</span><br><span class="line">        <span class="keyword">if</span> (num) [num <span class="keyword">class</span>]; <span class="comment">// hold the number</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="comment">// 如果属性属于 nsType，即 NSString、NSNumber……</span></span><br><span class="line">        <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) &#123; <span class="comment">// 为空，则赋值 nil（通过属性元 _setter 方法使用 objc_msgSend 将 nil 赋值）</span></span><br><span class="line">            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)<span class="literal">nil</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不为空</span></span><br><span class="line">            <span class="keyword">switch</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">                <span class="comment">// NSString 或 NSMutableString</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSString:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableString: &#123;</span><br><span class="line">                    <span class="comment">// 处理可能的 value 类型：NSString，NSNumber，NSData，NSURL，NSAttributedString</span></span><br><span class="line">                    <span class="comment">// 对应的分支就是把 value 转为 NSString 或者 NSMutableString，之后调用 setter 赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSValue，NSNumber 或 NSDecimalNumber</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSValue:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSNumber:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDecimalNumber: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSData 或 NSMutableData</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSData:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableData: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSDate</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDate: &#123;</span><br><span class="line">                    <span class="comment">// 考虑可能的 value 类型：NSDate 或 NSString</span></span><br><span class="line">                    <span class="comment">// 转换为 NSDate 之后赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSURL</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSURL: &#123;</span><br><span class="line">                    <span class="comment">// 考虑可能的 value 类型：NSURL 或 NSString</span></span><br><span class="line">                    <span class="comment">// 转换为 NSDate 之后赋值（这里对 NSString 的长度判断是否赋值 nil）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSArray 或 NSMutableArray</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSArray:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableArray: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的泛型判断</span></span><br><span class="line">                    <span class="keyword">if</span> (meta-&gt;_genericCls) &#123; <span class="comment">// 如果存在泛型</span></span><br><span class="line">                        <span class="built_in">NSArray</span> *valueArr = <span class="literal">nil</span>;</span><br><span class="line">                        <span class="comment">// value 所属 NSArray 则直接赋值，如果所属 NSSet 类则转为 NSArray</span></span><br><span class="line">                        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) valueArr = value;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) valueArr = ((<span class="built_in">NSSet</span> *)value).allObjects;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 遍历刚才通过 value 转换来的 valueArr</span></span><br><span class="line">                        <span class="keyword">if</span> (valueArr) &#123;</span><br><span class="line">                            <span class="built_in">NSMutableArray</span> *objectArr = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">id</span> one <span class="keyword">in</span> valueArr) &#123;</span><br><span class="line">                                <span class="comment">// 遇到 valueArr 中的元素属于泛型类，直接加入 objectArr</span></span><br><span class="line">                                <span class="keyword">if</span> ([one isKindOfClass:meta-&gt;_genericCls]) &#123;</span><br><span class="line">                                    [objectArr addObject:one];</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([one isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                                    <span class="comment">// 遇到 valueArr 中的元素是字典类，</span></span><br><span class="line">                                    Class cls = meta-&gt;_genericCls;</span><br><span class="line">                                    <span class="comment">// 忽略</span></span><br><span class="line">                                    <span class="keyword">if</span> (meta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">                                        cls = [cls modelCustomClassForDictionary:one];</span><br><span class="line">                                        <span class="keyword">if</span> (!cls) cls = meta-&gt;_genericCls; <span class="comment">// for xcode code coverage</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 还记得我们直接的起点 yy_modelSetWithDictionary，将字典转模型</span></span><br><span class="line">                                    <span class="comment">// 我觉得这应该算是一个间接递归调用</span></span><br><span class="line">                                    <span class="comment">// 如果设计出的模型是无限递归（从前有座山，山上有座庙的故事），那么肯定会慢</span></span><br><span class="line">                                    <span class="built_in">NSObject</span> *newOne = [cls new];</span><br><span class="line">                                    [newOne yy_modelSetWithDictionary:one];</span><br><span class="line">                                    <span class="comment">// 转化成功机也加入 objectArr</span></span><br><span class="line">                                    <span class="keyword">if</span> (newOne) [objectArr addObject:newOne];</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 最后将得到的 objectArr 赋值给属性</span></span><br><span class="line">                            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, objectArr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 没有泛型，嘛~ 判断一下 value 的可能所属类型 NSArray 或 NSSet</span></span><br><span class="line">                        <span class="comment">// 转换赋值（涉及 mutable）</span></span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSDictionary 或 NSMutableDictionary</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDictionary:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableDictionary: &#123;</span><br><span class="line">                    <span class="comment">// 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSSet 或 NSMutableSet</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSSet:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableSet: &#123;</span><br><span class="line">                    <span class="comment">// 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 属性元不属于 CNumber 和 nsType </span></span><br><span class="line">        <span class="type">BOOL</span> isNull = (value == (<span class="type">id</span>)kCFNull);</span><br><span class="line">        <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">            <span class="comment">// id</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 空，赋值 nil</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)<span class="literal">nil</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:meta-&gt;_cls] || !meta-&gt;_cls) &#123;</span><br><span class="line">                    <span class="comment">// 属性元与 value 从属于同一个类，则直接赋值</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    <span class="comment">// 嘛~ value 从属于 </span></span><br><span class="line">                    <span class="built_in">NSObject</span> *one = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="comment">// 如果属性元有 getter 方法，则通过 getter 获取到实例</span></span><br><span class="line">                    <span class="keyword">if</span> (meta-&gt;_<span class="keyword">getter</span>) &#123;</span><br><span class="line">                        one = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (one) &#123;</span><br><span class="line">                        <span class="comment">// 用 yy_modelSetWithDictionary 输出化属性实例对象</span></span><br><span class="line">                        [one yy_modelSetWithDictionary:value];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Class cls = meta-&gt;_cls;</span><br><span class="line">                        <span class="comment">// 略过</span></span><br><span class="line">                        <span class="keyword">if</span> (meta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">                            cls = [cls modelCustomClassForDictionary:value];</span><br><span class="line">                            <span class="keyword">if</span> (!cls) cls = meta-&gt;_genericCls; <span class="comment">// for xcode code coverage</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 用 yy_modelSetWithDictionary 输出化属性实例对象，赋值</span></span><br><span class="line">                        one = [cls new];</span><br><span class="line">                        [one yy_modelSetWithDictionary:value];</span><br><span class="line">                        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)one);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Class</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 空，赋值(Class)NULL，由于 Class 其实是 C 语言定义的结构体，所以使用 NULL</span></span><br><span class="line">                    <span class="comment">// 关于 nil，Nil，NULL，NSNull，kCFNull 的横向比较，我会单独拎出来在下面介绍</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, Class))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (Class)<span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断 value 可能的类型 NSString 或判断 class_isMetaClass(object_getClass(value))</span></span><br><span class="line">                    <span class="comment">// 如果满足条件则赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// SEL</span></span><br><span class="line">            <span class="keyword">case</span>  YYEncodingTypeSEL: &#123;</span><br><span class="line">                <span class="comment">// 判空，赋值(SEL)NULL</span></span><br><span class="line">                <span class="comment">// 否则转换类型 SEL sel = NSSelectorFromString(value); 然后赋值</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// block</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeBlock: &#123;</span><br><span class="line">                <span class="comment">// 判空，赋值(void (^)())NULL</span></span><br><span class="line">                <span class="comment">// 否则判断类型 [value isKindOfClass:YYNSBlockClass()] 之后赋值</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// struct、union、char[n]，关于 union 共同体感兴趣的同学可以自己 google，这里简单介绍一下</span></span><br><span class="line">            <span class="comment">// union 共同体，类似 struct 的存在，但是 union 每个成员会用同一个存储空间，只能存储最后一个成员的信息</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeStruct:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeUnion:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeCArray: &#123;</span><br><span class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) &#123; </span><br><span class="line">                    <span class="comment">// 涉及 Type Encodings</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="type">char</span> *valueType = ((<span class="built_in">NSValue</span> *)value).objCType;</span><br><span class="line">                    <span class="keyword">const</span> <span class="type">char</span> *metaType = meta-&gt;_info.typeEncoding.UTF8String;</span><br><span class="line">                    <span class="comment">// 比较 valueType 与 metaType 是否相同，相同（strcmp(a, b) 返回 0）则赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (valueType &amp;&amp; metaType &amp;&amp; strcmp(valueType, metaType) == <span class="number">0</span>) &#123;</span><br><span class="line">                        [model setValue:value forKey:meta-&gt;_name];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// void* 或 char*</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypePointer:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeCString: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 判空，赋值(void *)NULL</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">void</span> *))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">void</span> *)<span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    <span class="comment">// 涉及 Type Encodings</span></span><br><span class="line">                    <span class="built_in">NSValue</span> *nsValue = value;</span><br><span class="line">                    <span class="keyword">if</span> (nsValue.objCType &amp;&amp; strcmp(nsValue.objCType, <span class="string">&quot;^v&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">void</span> *))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, nsValue.pointerValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额 😓 我是真的已经忽略掉很多代码了，没办法还是有点长。其实代码逻辑还是很简单的，只是模型赋值涉及的编码类型等琐碎逻辑比较多导致代码量比较大，我们一起来总结一下核心代码的实现逻辑。</p>
<ul>
<li>根据属性元类型划分代码逻辑</li>
<li>如果属性元是 CNumber 类型，即 int、uint 之类，则使用 <code>ModelSetNumberToProperty</code> 赋值</li>
<li>如果属性元属于 NSType 类型，即 NSString、NSNumber 之类，则根据类型转换中可能涉及到的对应类型做逻辑判断并赋值（可以去上面代码中查看具体实现逻辑）</li>
<li>如果属性元不属于 CNumber 和 NSType，则猜测为 id，Class，SEL，Block，struct、union、char[n]，void<em> 或 char</em> 类型并且做出相应的转换和赋值</li>
</ul>
<p>嘛~ 其实上面的代码除了长以外逻辑还是很简单的，总结起来就是根据可能出现的类型去做出对应的逻辑操作，建议各位有时间还是去读下源码，尤其是自己项目中用到 YYModel 的同学。相信看完之后会对 YYModel 属性赋值一清二楚，这样在使用 YYModel 的日常中出现任何问题都可以心中有数，改起代码自然如有神助哈。</p>
<p>额…考虑到 NSDictionary to Model 的整个过程代码量不小，我花了一些时间将其逻辑总结归纳为一张图：</p>
<img src="/yymodel0x02/d2m.png" class="">
<p>希望可以尽自己的努力让文章的表述变得更直白。</p>
<h3 id="Model-to-JSON"><a href="#Model-to-JSON" class="headerlink" title="Model to JSON"></a>Model to JSON</h3><img src="/yymodel0x02/m2j.jpg" class="">
<p>相比于 JSON to Model 来说，Model to JSON 更简单一些。其中因为 NSJSONSerialization 在对 JSON 的转换时做了一些规定：</p>
<ul>
<li>顶级对象是 NSArray 或者 NSDictionary 类型</li>
<li>所有的对象都是 NSString, NSNumber, NSArray, NSDictionary, 或 NSNull 的实例</li>
<li>所有字典中的 key 都是一个 NSString 实例</li>
<li>Numbers 是除去无穷大和 NaN 的其他表示</li>
</ul>
<blockquote>
<p>Note: 上文出自 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsjsonserialization">NSJSONSerialization 官方文档</a>。</p>
</blockquote>
<p>知道了这一点后，我们就可以从 YYModel 的 Model to JSON 接口 <code>yy_modelToJSONObject</code> 处开始解读源码了。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="comment">// 递归转换模型到 JSON</span></span><br><span class="line">    <span class="type">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 一共 4 行代码，只需要关注一下第一行代码中的 <code>ModelToJSONObjectRecursive</code> 方法，<code>Objective-C</code> 的语言特性决定了从函数名称即可无需注释看懂代码，这个方法从名字上就可以 get 到它是通过递归方法使 Model 转换为 JSON 的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归转换模型到 JSON，如果转换异常则返回 nil</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">// 判空或者可以直接返回的对象，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="comment">// 如果 model 从属于 NSDictionary</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果可以直接转换为 JSON 数据，则返回</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="comment">// 遍历 model 的 key 和 value</span></span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 递归解析 value </span></span><br><span class="line">            <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="type">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 model 从属于 NSSet</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果能够直接转换 JSON 对象，则直接返回</span></span><br><span class="line">        <span class="comment">// 否则遍历，按需要递归解析</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果能够直接转换 JSON 对象，则直接返回</span></span><br><span class="line">        <span class="comment">// 否则遍历，按需要递归解析</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 NSURL, NSAttributedString, NSDate, NSData 做相应处理</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="type">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 [model class] 初始化一个模型元</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="comment">// 如果映射表为空，则不做解析直接返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 性能优化细节，使用 __unsafe_unretained 来避免在下面遍历 block 中直接使用 result 指针造成的不必要 retain 与 release 开销</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result;</span><br><span class="line">    <span class="comment">// 遍历模型元属性映射字典</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历当前属性元没有 getter 方法，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 如果属性元属于 CNumber，即其 type 是 int、float、double 之类的</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">            <span class="comment">// 从属性中利用 getter 方法得到对应的值</span></span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123; <span class="comment">// 属性元属于 nsType，即 NSString 之类</span></span><br><span class="line">            <span class="comment">// 利用 getter 方法拿到 value</span></span><br><span class="line">            <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">            <span class="comment">// 对拿到的 value 递归解析</span></span><br><span class="line">            value = ModelToJSONObjectRecursive(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据属性元的 type 做相应处理</span></span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="comment">// id，需要递归解析，如果解析失败则返回 nil</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// Class，转 NSString，返回 Class 名称</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// SEL，转 NSString，返回给定 SEL 的字符串表现形式</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 value 还是没能解析，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前属性元是 KeyPath 映射，即 a.b.c 之类</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// _mappedToKeyPath 是 a.b.c 根据 &#x27;.&#x27; 拆分成的字符串数组，遍历 _mappedToKeyPath</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="comment">// 遍历到结尾</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123;</span><br><span class="line">                    <span class="comment">// 如果结尾的 key 为 nil，则使用 value 赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 用 subDic 拿到当前 key 对应的值</span></span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="comment">// 如果 subDic 存在</span></span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="comment">// 如果 subDic 从属于 NSDictionary</span></span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        <span class="comment">// 将 subDic 的 mutable 版本赋值给 superDic[key]</span></span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 NSMutableDictionary 赋值给 superDic[key]</span></span><br><span class="line">                    <span class="comment">// 注意这里使用 subDic 间接赋值是有原因的，原因就在下面</span></span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// superDic 指向 subDic，这样在遍历 _mappedToKeyPath 时即可逐层解析</span></span><br><span class="line">                <span class="comment">// 这就是上面先把 subDic 转为 NSMutableDictionary 的原因</span></span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 KeyPath 则检测 dic[propertyMeta-&gt;_mappedToKey]，如果为 nil 则赋值 value</span></span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，对应 modelCustomTransformToDictionary 接口</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="comment">// 用于在默认的 Model 转 JSON 过程不适合当前 Model 类型时提供自定义额外过程</span></span><br><span class="line">        <span class="comment">// 也可以用这个方法来验证转换结果</span></span><br><span class="line">        <span class="type">BOOL</span> suc = [((<span class="type">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额…代码还是有些长，不过相比于之前 JSON to Model 方向上由 <code>yy_modelSetWithDictionary</code>，<code>ModelSetWithDictionaryFunction</code> 和 <code>ModelSetValueForProperty</code> 三个方法构成的间接递归来说算是非常简单了，那么总结一下上面的代码逻辑。</p>
<ul>
<li>判断入参，如果满足条件可以直接返回</li>
<li>如果 Model 从属于 NSType，则根据不同的类型做逻辑处理</li>
<li>如果上面条件不被满足，则用 Model 的 Class 初始化一个模型元 _YYModelMeta</li>
<li>判断模型元的映射关系，遍历映射表拿到对应键值对并存入字典中并返回</li>
</ul>
<blockquote>
<p>Note: 这里有一个性能优化的细节，用 <code>__unsafe_unretained</code> 修饰的 dic 指向我们最后要 return 的 NSMutableDictionary *result，看作者的注释：<code>// avoid retain and release in block</code> 是为了避免直接使用 <code>result</code> 在后面遍历映射表的代码块中不必要的 retain 和 release 操作以节省开销。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章紧接上文<a href="https://lision.me/yymodel_x01/">《揭秘 YYModel 的魔法（上）》</a>中对 YYModel 代码结构的讲解后将重点放到了对 JSON 模型相互转换的实现逻辑上。</li>
<li>从 JSON 模型的转换方向上划分，将 YYModel 的 JSON 模型转换过程正反方向剖析揭秘，希望可以解开大家对 JSON 模型自动转换的疑惑。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a><a class="tag-none-link" href="/tags/yymodel/" rel="tag">yymodel</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yymodel0x01/">
      揭秘 YYModel 的魔法 0x01
    </a>
  </h2>
  
  <time>
    11月 12, 2017
  </time>
  <section class="content">
	  <img src="/yymodel0x01/design_model_0x01.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中少不了各种各样的模型，不论是采用 MVC、MVP 还是 MVVM 设计模式都逃不过 Model。</p>
<p>那么大家在使用 Model 的时候肯定遇到过一个问题，即接口传递过来的数据（一般是 JSON 格式）需要转换为 iOS 内我们能直接使用的模型（类）。iOS 开发早期第三方框架没有那么多，大家可能会手写相关代码，但是随着业务的扩展，模型的增多，这些没什么技术含量的代码只是在重复的浪费我们的劳动力而已。</p>
<p>这时候就需要一种工具来帮助我们把劳动力从这些无意义的繁琐代码中解放出来，于是 GitHub 上出现了很多解决此类问题的第三方库，诸如 Mantle、JSONModel、MJExtension 以及 YYModel 等等。</p>
<p>这些库的神奇之处在于它们提供了模型与 JSON 数据的自动转换功能，仿佛具有魔法一般！本文将通过剖析 YYModel 源码一步一步破解这“神奇”的魔法。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a> 是一个高性能 iOS/OSX 模型转换框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 在我之前的文章【<a href="https://lision.me/yycache/">从 YYCache 源码 Get 到如何设计一个优秀的缓存</a>】中已经很详细的介绍过了，感兴趣的同学可以点进去了解一下。</p>
<p>YYModel 是一个非常轻量级的 JSON 模型自动转换库，代码风格良好且思路清晰，可以从源码中看到作者对 Runtime 深厚的理解。难能可贵的是 YYModel 在其轻量级的代码下还保留着自动类型转换，类型安全，无侵入等特性，并且具有接近手写解析代码的超高性能。</p>
<blockquote>
<p>处理 GithubUser 数据 10000 次耗时统计 (iPhone 6):</p>
</blockquote>
<img src="/yymodel0x01/yymodel_performance.png" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYModel 简介</li>
<li>YYClassInfo 剖析</li>
<li>NSObject+YYModel 探究</li>
<li>JSON 与 Model 相互转换</li>
<li>总结</li>
</ul>
<h2 id="YYModel-简介"><a href="#YYModel-简介" class="headerlink" title="YYModel 简介"></a>YYModel 简介</h2><img src="/yymodel0x01/yymodel.png" class="">
<p>撸了一遍 YYModel 的源码，果然是非常轻量级的 JSON 模型自动转换库，加上 YYModel.h 一共也只有 5 个文件。</p>
<p>抛开 YYModel.h 来看，其实只有 YYClassInfo 和 NSObject+YYModel 两个模块。</p>
<ul>
<li>YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用。</li>
<li>NSObject+YYModel 负责提供方便调用的接口以及实现具体的模型转换逻辑（借助 YYClassInfo 中的封装）。</li>
</ul>
<h2 id="YYClassInfo-剖析"><a href="#YYClassInfo-剖析" class="headerlink" title="YYClassInfo 剖析"></a>YYClassInfo 剖析</h2><img src="/yymodel0x01/yyclassinfo.jpg" class="">
<p>前面说到 YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用，我觉得如果需要与 Runtime 层级的结构体做对比的话，没什么比表格来的更简单直观了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">YYClassInfo</th>
<th style="text-align:center">Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">YYClassIvarInfo</td>
<td style="text-align:center"><code>objc_ivar</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassMethodInfo</td>
<td style="text-align:center"><code>objc_method</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassPropertyInfo</td>
<td style="text-align:center"><code>property_t</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassInfo</td>
<td style="text-align:center"><code>objc_class</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note: 本次比较基于 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime 源码</a> 723 版本。</p>
</blockquote>
<p>安~ 既然是剖析肯定不会列个表格这样子哈。</p>
<h3 id="YYClassIvarInfo-amp-amp-objc-ivar"><a href="#YYClassIvarInfo-amp-amp-objc-ivar" class="headerlink" title="YYClassIvarInfo &amp;&amp; objc_ivar"></a>YYClassIvarInfo &amp;&amp; objc_ivar</h3><p>我把 YYClassIvarInfo 看做是作者对 Runtime 层 <code>objc_ivar</code> 结构体的封装，<code>objc_ivar</code> 是 Runtime 中表示变量的结构体。</p>
<ul>
<li>YYClassIvarInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassIvarInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Ivar ivar; <span class="comment">///&lt; 变量，对应 objc_ivar</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 变量名称，对应 ivar_name</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) ptrdiff_t offset; <span class="comment">///&lt; 变量偏移量，对应 ivar_offset</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 变量类型编码，通过 ivar_getTypeEncoding 函数得到</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 变量类型，通过 YYEncodingGetType 方法从类型编码中得到</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithIvar:(Ivar)ivar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_ivar</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_name OBJC2_UNAVAILABLE; <span class="comment">// 变量名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_type OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="type">int</span> ivar_offset OBJC2_UNAVAILABLE; <span class="comment">// 变量偏移量</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__ <span class="comment">// 如果已定义 __LP64__ 则表示正在构建 64 位目标</span></span></span><br><span class="line">    <span class="type">int</span> space OBJC2_UNAVAILABLE; <span class="comment">// 变量空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 日常开发中 NSString 类型的属性我们都会用 copy 来修饰，而 YYClassIvarInfo 中的 <code>name</code> 和 <code>typeEncoding</code> 属性都用 strong 修饰。因为其内部是先通过 Runtime 方法拿到 <code>const char *</code> 之后通过 <code>stringWithUTF8String</code> 方法转为 NSString 的。所以即便是 NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。</p>
</blockquote>
<p>囧~ 不知道讲的这么细会不会反而引起反感，如果对文章有什么建议可以联系我 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">@薛定谔的猹</a> 。</p>
<blockquote>
<p>Note: 类型编码，关于 YYClassIvarInfo 中的 YYEncodingType 类型属性 type 的解析代码篇幅很长，而且没有搬出来的必要，可以参考官方文档 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Declared Properties</a> 阅读这部分源码。</p>
</blockquote>
<h3 id="YYClassMethodInfo-amp-amp-objc-method"><a href="#YYClassMethodInfo-amp-amp-objc-method" class="headerlink" title="YYClassMethodInfo &amp;&amp; objc_method"></a>YYClassMethodInfo &amp;&amp; objc_method</h3><p>相应的，YYClassMethodInfo 则是作者对 Runtime 中 <code>objc_method</code> 的封装，<code>objc_method</code> 在 Runtime 是用来定义方法的结构体。</p>
<ul>
<li>YYClassMethodInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassMethodInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Method method; <span class="comment">///&lt; 方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 方法名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL sel; <span class="comment">///&lt; 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) IMP imp; <span class="comment">///&lt; 方法实现，指向实现方法函数的函数指针</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 方法参数和返回类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *returnTypeEncoding; <span class="comment">///&lt; 返回值类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *argumentTypeEncodings; <span class="comment">///&lt; 参数类型编码数组</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMethod:(Method)method;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_method</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name OBJC2_UNAVAILABLE; <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable method_types OBJC2_UNAVAILABLE; <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp OBJC2_UNAVAILABLE; <span class="comment">// 方法实现（函数指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到基本也是一一对应的关系，除了类型编码的问题作者为了方便使用在封装时进行了扩展。</p>
<p>为了照顾对 Runtime 还没有一定了解的读者，我这里简单的解释一下 <code>objc_method</code> 结构体（都是我自己的认知，欢迎讨论）：</p>
<ul>
<li>SEL，selector 在 Runtime 中的表现形式，可以理解为方法选择器</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<ul>
<li>IMP，函数指针，指向具体实现逻辑的函数</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*IMP)(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> ); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> _Nullable (*IMP)(<span class="type">id</span> _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>关于更多 Runtime 相关的知识由于篇幅原因（真的写不完）就不在这篇文章介绍了，我推荐大家去鱼神的文章 <a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a> 学习（因为我最早接触 Runtime 就是通过这篇文章，笑~）。</p>
<p>有趣的是，鱼神的文章中对 SEL 的描述有一句“其实它就是个映射到方法的 C 字符串”，但是他在文章中没有介绍出处。本着对自己文章质量负责的原则，对于一切没有出处的表述都应该持有怀疑的态度，所以我下面讲一下自己的对于 SEL 的理解。</p>
<p>撸了几遍 Runtime 源码，发现不论是 objc-runtime-new 还是 objc-runtime-old 中都用 SEL 类型作为方法结构体的 name 属性类型，而且通过以下源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT SEL _Nonnull sel_registerName(<span class="keyword">const</span> <span class="type">char</span> * _Nonnull str)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">const</span> <span class="type">char</span> * _Nonnull sel_getName(SEL _Nonnull sel)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到通过一个 <code>const char *</code> 类型的字符串即可在 Runtime 系统中注册并返回一个 SEL，方法的名称则会映射到这个 SEL。</p>
<blockquote>
<p>官方注释：<br>Registers a method with the Objective-C runtime system, maps the method name to a selector, and returns the selector value.</p>
</blockquote>
<p>所以我觉得 SEL 和 <code>char *</code> 的的确确是有某种一一对应的映射关系，不过 SEL 的本质是否是 <code>char *</code> 就要打一个问号了。因为我在调试 SEL 阶段发现 SEL 内还有一个当前 SEL 的指针，与 <code>char *</code> 不同的是当 <code>char *</code> 赋值之后当前 <code>char *</code> 变量指针指向字符串首字符，而 SEL 则是 <no value available>，即我们无法直接看到它。</p>
<p>所以我做了一个无聊的测试，用相同的字符串初始化一个 <code>char *</code> 实例与一个 SEL 实例，之后尝试打印它们，有趣的是不论我使用 <code>%s</code> 还是 <code>%c</code> 都可以从两个实例中得到相同的打印输出，不知道鱼神是否做过相同的测试（笑~）</p>
<p>嘛~ 经过验证我们可以肯定 SEL 和 <code>char *</code> 存在某种映射关系，可以相互转换。同时猜测 SEL 本质上就是 <code>char *</code>，如果有哪位知道 SEL 与 <code>char *</code> 确切关系的可以留言讨论哟。</p>
<h3 id="YYClassPropertyInfo-amp-amp-property-t"><a href="#YYClassPropertyInfo-amp-amp-property-t" class="headerlink" title="YYClassPropertyInfo &amp;&amp; property_t"></a>YYClassPropertyInfo &amp;&amp; property_t</h3><p>YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装，<code>property_t</code> 在 Runtime 中是用来表示属性的结构体。</p>
<ul>
<li>YYClassPropertyInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassPropertyInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) objc_property_t property; <span class="comment">///&lt; 属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 属性名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 属性类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 属性类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *ivarName; <span class="comment">///&lt; 变量名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *protocols; <span class="comment">///&lt; 属性相关协议</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">getter</span>; <span class="comment">///&lt; getter 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">setter</span>; <span class="comment">///&lt; setter 方法选择器</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithProperty:(objc_property_t)property;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_t</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes; <span class="comment">// 修饰</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么说 YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> old_property *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h</span></span><br><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里唯一值得注意的就是 getter 与 setter 方法了。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先尝试获取属性的 getter 与 setter</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomGetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomSetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没有则按照标准规则自己造</span></span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">getter</span>) &#123;</span><br><span class="line">    _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>(_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">setter</span>) &#123;</span><br><span class="line">    _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;set%@%@:&quot;</span>, [_name substringToIndex:<span class="number">1</span>].uppercaseString, [_name substringFromIndex:<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="YYClassInfo-amp-amp-objc-class"><a href="#YYClassInfo-amp-amp-objc-class" class="headerlink" title="YYClassInfo &amp;&amp; objc_class"></a>YYClassInfo &amp;&amp; objc_class</h3><p>最后作者用 YYClassInfo 封装了 <code>objc_class</code>，<code>objc_class</code> 在 Runtime 中表示一个 Objective-C 类。</p>
<ul>
<li>YYClassInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class superCls; <span class="comment">///&lt; 超类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class metaCls;  <span class="comment">///&lt; 元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isMeta; <span class="comment">///&lt; 元类标识，自身是否为元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 类名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYClassInfo *superClassInfo; <span class="comment">///&lt; 父类（超类）信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassIvarInfo *&gt; *ivarInfos; <span class="comment">///&lt; 变量信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassMethodInfo *&gt; *methodInfos; <span class="comment">///&lt; 方法信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassPropertyInfo *&gt; *propertyInfos; <span class="comment">///&lt; 属性信息</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setNeedUpdate;</span><br><span class="line">- (<span class="type">BOOL</span>)needUpdate;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClassName:(<span class="built_in">NSString</span> *)className;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_class</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa OBJC_ISA_AVAILABILITY; <span class="comment">// isa 指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类（超类）指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 版本</span></span><br><span class="line">    <span class="type">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 信息</span></span><br><span class="line">    <span class="type">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 初始尺寸</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; <span class="comment">// 变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; <span class="comment">// 协议列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>额… 看来想完全避开 Runtime 的知识来讲 YYModel 源码是不现实的。这里简单介绍一下 Runtime 中关于 Class 的知识以便阅读，已经熟悉这方面知识的同学就当温习一下好了。</p>
<img src="/yymodel0x01/class_diagram.jpg" class="">
<ul>
<li>isa 指针，用于找到所属类，类对象的 isa 一般指向对应元类。</li>
<li>元类，由于 objc_class 继承于 objc_object，即类本身同时也是一个对象，所以 Runtime 库设计出元类用以表述类对象自身所具备的元数据。</li>
<li>cache，实际上当一个对象收到消息时并不会直接在 isa 指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了。为了优化方法调用的效率，加入了 cache，也就是说在收到消息时，会先去 cache 中查找，找不到才会去像上图所示遍历查找，相信苹果为了提升缓存命中率，应该也花了一些心思（笑~）。</li>
<li>version，我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<blockquote>
<p>关于 Version 的官方描述：<br>Classes derived from the Foundation framework NSObject class can set the class-definition version number using the setVersion: class method, which is implemented using the class_setVersion function.</p>
</blockquote>
<h4 id="YYClassInfo-的初始化细节"><a href="#YYClassInfo-的初始化细节" class="headerlink" title="YYClassInfo 的初始化细节"></a>YYClassInfo 的初始化细节</h4><p>关于 YYClassInfo 的初始化细节我觉得还是有必要分享出来的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 判空入参</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例缓存 classCache 与 metaCache，对应缓存类和元类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> classCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> metaCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        classCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        metaCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 这里把 dispatch_semaphore 当做锁来使用（当信号量只有 1 时）</span></span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化之前，首先会根据当前 YYClassInfo 是否为元类去对应的单例缓存中查找</span></span><br><span class="line">    <span class="comment">// 这里使用了上面的 dispatch_semaphore 加锁，保证单例缓存的线程安全 </span></span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    YYClassInfo *info = <span class="built_in">CFDictionaryGetValue</span>(class_isMetaClass(cls) ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls));</span><br><span class="line">    <span class="comment">// 如果找到了，且找到的信息需要更新的话则执行更新操作</span></span><br><span class="line">    <span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">        [info _update];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没找到，才会去老实初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">        info = [[YYClassInfo alloc] initWithClass:cls];</span><br><span class="line">        <span class="keyword">if</span> (info) &#123; <span class="comment">// 初始化成功</span></span><br><span class="line">            <span class="comment">// 线程安全</span></span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="comment">// 根据初始化信息选择向对应的类/元类缓存注入信息，key = cls，value = info</span></span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(info.isMeta ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls), (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(info));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下初始化的主要步骤：</p>
<ul>
<li>创建单例缓存，类缓存和元类缓存</li>
<li>使用 <code>dispatch_semaphore</code> 作为锁保证缓存线程安全</li>
<li>初始化前先去缓存中查找是否已经向缓存中注册过当前要初始化的 YYClassInfo</li>
<li>如果查找到缓存对象，则判断缓存对象是否需要更新并执行相关操作</li>
<li>如果缓存中未找到缓存对象则初始化</li>
<li>初始化成功后向缓存中注册该 YYClassInfo 实例</li>
</ul>
<p>其中，使用缓存可以有效减少我们在 JSON 模型转换时反复初始化 YYClassInfo 带来的开销，而 <code>dispatch_semaphore</code> 在信号量为 1 时是可以当做锁来使用的，虽然它在阻塞时效率超低，但是对于代码中的缓存阻塞这里属于低频事件，使用 <code>dispatch_semaphore</code> 在非阻塞状态下性能很高，这里锁的选择非常合适。</p>
<h4 id="关于-YYClassInfo-的更新"><a href="#关于-YYClassInfo-的更新" class="headerlink" title="关于 YYClassInfo 的更新"></a>关于 YYClassInfo 的更新</h4><p>首先 YYClassInfo 是作者对应 <code>objc_class</code> 封装出来的类，所以理应在其对应的 <code>objc_class</code> 实例发生变化时更新。那么 <code>objc_class</code> 什么时候会发生变化呢？</p>
<p>嘛~ 比如你使用了 <code>class_addMethod</code> 方法为你的模型类加入了一个方法等等。</p>
<p>YYClassInfo 有一个私有 BOOL 类型参数 <code>_needUpdate</code> 用以表示当前的 YYClassInfo 实例是否需要更新，并且提供了 <code>- (void)setNeedUpdate;</code> 接口方便我们在更改了自己的模型类时调用其将 <code>_needUpdate</code> 设置为 YES，当 <code>_needUpdate</code> 为 YES 时后面就不用我说了，相关的代码在上一节初始化中有哦。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">    [info _update];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 <code>_update</code>，它是 YYClassInfo 的私有方法，它的实现逻辑简单介绍就是清空当前 YYClassInfo 实例变量，方法以及属性，之后再重新初始化它们。由于 <code>_update</code> 实现源码并没有什么特别之处，我这里就不贴源码了。</p>
<p>嘛~ 对 YYClassInfo 的剖析到这里就差不多了。</p>
<h2 id="NSObject-YYModel-探究"><a href="#NSObject-YYModel-探究" class="headerlink" title="NSObject+YYModel 探究"></a>NSObject+YYModel 探究</h2><img src="/yymodel0x01/nsobject_yymodel.jpg" class="">
<p>如果说 YYClassInfo 主要是作者对 Runtime 层在 JSON 模型转换中需要用到的结构体的封装，那么 NSObject+YYModel 在 YYModel 中担当的责任则是利用 YYClassInfo 层级封装好的类切实的执行 JSON 模型之间的转换逻辑，并且提供了无侵入性的接口。</p>
<p>第一次阅读 NSObject+YYModel.m 的源码可能会有些不适应，这很正常。因为其大量使用了 Runtime 函数与 CoreFoundation 库，加上各种类型编码和递归解析，代码量也有 1800 多行了。</p>
<p>我简单把 NSObject+YYModel.m 的源码做了一下划分，这样划分之后代码看起来一样很简单清晰：</p>
<ul>
<li>类型编码解析</li>
<li>数据结构定义</li>
<li>递归模型转换</li>
<li>接口相关代码</li>
</ul>
<h3 id="类型编码解析"><a href="#类型编码解析" class="headerlink" title="类型编码解析"></a>类型编码解析</h3><p>类型编码解析代码主要集中在 NSObject+YYModel.m 的上面部分，涉及到 YYEncodingNSType 枚举的定义，配套 <code>YYClassGetNSType</code> 函数将 NS 类型转为 YYEncodingNSType 还有 <code>YYEncodingTypeIsCNumber</code> 函数判断类型是否可以直接转为 C 语言数值类型的函数。</p>
<p>此外还有将 id 指针转为对应 NSNumber 的函数 <code>YYNSNumberCreateFromID</code>，将 NSString 转为 NSDate 的 <code>YYNSDateFromString</code> 函数，这类函数主要是方便在模型转换时使用。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDate</span> *YYNSDateFromString(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="comment">// YYNSDateFromString 支持解析的最长时间字符串</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kParserNum 34</span></span><br><span class="line">    <span class="comment">// 这里创建了一个单例时间解析代码块数组</span></span><br><span class="line">    <span class="comment">// 为了避免重复创建这些 NSDateFormatter，它的初始化开销不小</span></span><br><span class="line">    <span class="keyword">static</span> YYNSDateParseBlock blocks[kParserNum + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 这里拿 `yyyy-MM-dd` 举例分析</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20  // Google</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@&quot;en_US_POSIX&quot;</span>];</span><br><span class="line">            formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">            <span class="comment">// 这里使用 blocks[10] 是因为 `yyyy-MM-dd` 的长度就是 10</span></span><br><span class="line">            blocks[<span class="number">10</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他的格式都是一样类型的代码，省略</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!string) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; kParserNum) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据入参的长度去刚才存满各种格式时间解析代码块的单例数组取出对应的代码块执行</span></span><br><span class="line">    YYNSDateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> kParserNum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 iOS 7 之前 NSDateFormatter 是<strong>非线程安全</strong>的。</p>
</blockquote>
<p>除此之外还用 YYNSBlockClass 指向了 NSBlock 类，实现过程也比较巧妙。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline Class YYNSBlockClass() &#123;</span><br><span class="line">    <span class="keyword">static</span> Class cls;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;&#125;;</span><br><span class="line">        cls = ((<span class="built_in">NSObject</span> *)block).class;</span><br><span class="line">        <span class="comment">// 轮询父类直到父类指向 NSObject 停止</span></span><br><span class="line">        <span class="keyword">while</span> (class_getSuperclass(cls) != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            cls = class_getSuperclass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cls; <span class="comment">// 拿到的就是 &quot;NSBlock&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>force_inline</code> 这种代码技巧，我说过我在写完 YYModel 或者攒到足够多的时候会主动拿出来与大家分享这些代码技巧，不过这里大家通过字面也不难理解，就是强制内联。</p>
<p>嘛~ 关于内联函数应该不需要我多说（笑）。</p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>NSObject+YYModel 中重新定义了两个类，通过它们来使用 YYClassInfo 中的封装。</p>
<table>
<thead>
<tr>
<th style="text-align:center">NSObject+YYModel</th>
<th style="text-align:center">YYClassInfo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>_YYModelPropertyMeta</code></td>
<td style="text-align:center">YYClassPropertyInfo</td>
</tr>
<tr>
<td style="text-align:center"><code>_YYModelMeta</code></td>
<td style="text-align:center">YYClassInfo</td>
</tr>
</tbody>
</table>
<h4 id="YYModelPropertyMeta"><a href="#YYModelPropertyMeta" class="headerlink" title="_YYModelPropertyMeta"></a>_YYModelPropertyMeta</h4><p><code>_YYModelPropertyMeta</code> 表示模型对象中的属性信息，它包含 YYClassPropertyInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelPropertyMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;             <span class="comment">///&lt; 属性名称</span></span><br><span class="line">    YYEncodingType _type;        <span class="comment">///&lt; 属性类型</span></span><br><span class="line">    YYEncodingNSType _nsType;    <span class="comment">///&lt; 属性在 Foundation 框架中的类型</span></span><br><span class="line">    <span class="type">BOOL</span> _isCNumber;             <span class="comment">///&lt; 是否为 CNumber</span></span><br><span class="line">    Class _cls;                  <span class="comment">///&lt; 属性类</span></span><br><span class="line">    Class _genericCls;           <span class="comment">///&lt; 属性包含的泛型类型，没有则为 nil</span></span><br><span class="line">    SEL _<span class="keyword">getter</span>;                 <span class="comment">///&lt; getter</span></span><br><span class="line">    SEL _<span class="keyword">setter</span>;                 <span class="comment">///&lt; setter</span></span><br><span class="line">    <span class="type">BOOL</span> _isKVCCompatible;       <span class="comment">///&lt; 如果可以使用 KVC 则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _isStructAvailableForKeyedArchiver; <span class="comment">///&lt; 如果可以使用 archiver/unarchiver 归/解档则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _hasCustomClassFromDictionary; <span class="comment">///&lt; 类/泛型自定义类型，例如需要在数组中实现不同类型的转换需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *_mappedToKey;      <span class="comment">///&lt; 映射 key</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyPath;   <span class="comment">///&lt; 映射 keyPath，如果没有映射到 keyPath 则返回 nil</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyArray;  <span class="comment">///&lt; key 或者 keyPath 的数组，如果没有映射多个键的话则返回 nil</span></span><br><span class="line">    YYClassPropertyInfo *_info;  <span class="comment">///&lt; 属性信息，详见上文 YYClassPropertyInfo &amp;&amp; property_t 章节</span></span><br><span class="line">    _YYModelPropertyMeta *_next; <span class="comment">///&lt; 如果有多个属性映射到同一个 key 则指向下一个模型属性元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="YYModelMeta"><a href="#YYModelMeta" class="headerlink" title="_YYModelMeta"></a>_YYModelMeta</h4><p><code>_YYModelMeta</code> 表示模型的类信息，它包含 YYClassInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    YYClassInfo *_classInfo;</span><br><span class="line">    <span class="comment">/// Key:被映射的 key 与 keyPath, Value:_YYModelPropertyMeta.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *_mapper;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 当前模型的所有 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_allPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到 keyPath 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_keyPathPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到多个 key 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_multiKeysPropertyMetas;</span><br><span class="line">    <span class="comment">/// 映射 key 与 keyPath 的数量，等同于 _mapper.count</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _keyMappedCount;</span><br><span class="line">    <span class="comment">/// 模型 class 类型</span></span><br><span class="line">    YYEncodingNSType _nsType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="递归模型转换"><a href="#递归模型转换" class="headerlink" title="递归模型转换"></a>递归模型转换</h3><p>NSObject+YYModel.m 内写了一些（间接）递归模型转换相关的函数，如 <code>ModelToJSONObjectRecursive</code> 之类的，由于涉及繁杂的模型编码解析以及代码量比较大等原因我不准备放在这里详细讲解。</p>
<p>我认为这种逻辑并不复杂但是牵扯较多的函数代码与结构/类型定义代码不同，后者更适合列出源码让读者对数据有全面清醒的认识，而前者结合功能实例讲更容易使读者对整条功能的流程有一个更透彻的理解。</p>
<p>所以我准备放到后面 JSON 与 Model 相互转换时一起讲。</p>
<h3 id="接口相关代码"><a href="#接口相关代码" class="headerlink" title="接口相关代码"></a>接口相关代码</h3><p>嘛~ 理由同上。</p>
<h2 id="半章总结"><a href="#半章总结" class="headerlink" title="半章总结"></a>半章总结</h2><ul>
<li>文章对 YYModel 源码进行了系统解读，有条理的介绍了 YYModel 的结构，相信会让各位对 YYModel 的代码结构有一个清晰的认识。</li>
<li>深入剖析了 YYClassInfo 的 4 个类，并详细讲解了它们与 Runtime 层级结构体的对应。</li>
<li>在剖析 YYClassInfo 章节中分享了一些我在阅读源码的过程中发现的并且觉得值得分享的处理细节，比如为什么作者选择用 <code>strong</code> 来修饰 NSString 等。顺便还对 SEL 与 <code>char *</code> 的关系做了实验得出了我的推论。</li>
<li>把 YYClassInfo 的初始化以及更新细节单独拎出来做了分析。</li>
<li>探究 NSObject+YYModel 源码（分享了一些实现细节）并对其实现代码做了划分，希望能够对读者阅读 YYModel 源码时提供一些小小的帮助。</li>
</ul>
<p>嘛~ 上篇差不多就这样了。我写的上一篇 YYKit 源码系列文章<a href="https://lision.me/yycache/">【从 YYCache 源码 Get 到如何设计一个优秀的缓存】</a>收到了不少的好评和支持（掘金里一位读者 <a target="_blank" rel="noopener" href="https://juejin.im/user/5912c8b2da2f600053723275">@ios123456</a> 的评论更是暖化了我），这些美好的东西让我更加坚定了继续用心创作文章的决心。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a><a class="tag-none-link" href="/tags/yymodel/" rel="tag">yymodel</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yycache/">
      从 YYCache 源码 Get 到如何设计一个优秀的缓存
    </a>
  </h2>
  
  <time>
    10月 30, 2017
  </time>
  <section class="content">
	  <img src="/yycache/how_to_design_a_good_cache.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中总会用到各种缓存，但是各位有没有考虑过什么样的缓存才能被叫做优秀的缓存，或者说优秀的缓存应该具备哪些特质？</p>
<p><strong>闭上眼睛，想一想如果面试官让你设计一个缓存你会怎么回答？</strong></p>
<p>本文将结合 YYCache 的源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 是一个线程安全的高性能键值缓存（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 是在 2015 年发布到 Github 的，由于其代码质量很高，在短时间内就收获了大量的 Star（目前已经 1w+ Star 了），而且在 iOS 各大社区反响广泛，Google 一下也是漫天赞叹。</p>
<p>YYKit 作者是 <a target="_blank" rel="noopener" href="https://github.com/ibireme">@ibireme</a>，原名郭曜源（猜测 YY 前缀来源于曜源？），是我个人非常喜欢的国人开发者（何止喜欢，简直是迷弟😘）。</p>
<p>YYCache 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加难能可贵的是它的性能还非常高。</p>
<img src="/yycache/performance_yymemorycache.jpg" class="">
<img src="/yycache/performance_yydiskcache.jpg" class="">
<p>我对它的评价是<strong>小而美</strong>，这种小而美的缓存源码对于我们今天的主题太合适不过了（本文中 YYCache 源码版本为 v1.0.4）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYCache 简介</li>
<li>YYMemoryCache 细节剖析</li>
<li>YYDiskCache 细节剖析</li>
<li>优秀的缓存应该具备哪些特质</li>
<li>总结</li>
</ul>
<h2 id="YYCache-简介"><a href="#YYCache-简介" class="headerlink" title="YYCache 简介"></a>YYCache 简介</h2><img src="/yycache/yycache.jpg" class="">
<p>简单把 YYCache 从头到尾撸了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了。</p>
<p>由于代码整体阅读难度不是非常大，本文不会去逐字逐句的解读源码，而是提炼 YYCache 作为一个小而美的缓存实现了哪些缓存该具备的特质，并且分析实现细节。</p>
<p>我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。</p>
<blockquote>
<p>通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的代码我做了简化，只保留了最基本的代码（我认为作者在最初设计 YYCache 雏形时很可能也只是提供了这些基本的接口），其他的接口只是通过调用基本的接口再附加对应处理代码而成。</p>
<blockquote>
<p>Note: 其实源码中作者用了一些技巧性的宏，例如 <code>NS_ASSUME_NONNULL_BEGIN</code> 与 <code>NS_ASSUME_NONNULL_END</code> 来通过编译器层检测入参是否为空并给予警告，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a>。</p>
<p>类似上述的编码技巧还有很多，我并非不想与大家分享我 get 到的这些编码技巧，只是觉得它与本文的主题似乎不太相符。我准备在之后专门写一篇文章来与大家分享我在阅读各大源码库过程中 get 到的编码技巧（感兴趣的话可以 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">关注我</a>）。</p>
</blockquote>
<p>从代码中我们可以看到 YYCache 中持有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，类似于 iOS 原生的字典类接口（增删改查）。</p>
<h2 id="YYMemoryCache-细节剖析"><a href="#YYMemoryCache-细节剖析" class="headerlink" title="YYMemoryCache 细节剖析"></a>YYMemoryCache 细节剖析</h2><img src="/yycache/yymemorycache.jpg" class="">
<p>YYMemoryCache 是一个高速的内存缓存，用于存储键值对。它与 NSDictionary 相反，Key 被保留并且不复制。API 和性能类似于 NSCache，所有方法都是线程安全的。</p>
<p>YYMemoryCache 对象与 NSCache 的不同之处在于：</p>
<ul>
<li>YYMemoryCache 使用 LRU(least-recently-used) 算法来驱逐对象；NSCache 的驱逐方式是非确定性的。</li>
<li>YYMemoryCache 提供 age、cost、count 三种方式控制缓存；NSCache 的控制方式是不精确的。</li>
<li>YYMemoryCache 可以配置为在收到内存警告或者 App 进入后台时自动逐出对象。</li>
</ul>
<blockquote>
<p>Note: YYMemoryCache 中的 <code>Access Methods</code> 消耗时长通常是稳定的 <code>(O(1))</code>。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount; <span class="comment">// 缓存对象总数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost; <span class="comment">// 缓存对象总开销</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 5s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning; <span class="comment">// 是否应该在收到内存警告时删除所有缓存内对象</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground; <span class="comment">// 是否应该在 App 进入后台时删除所有缓存内对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到内存警告时自定义处理缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到 App 进入后台时自定义处理缓存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseOnMainThread; <span class="comment">// 是否在主线程释放对象，默认 NO，有些对象（例如 UIView/CALayer）应该在主线程释放</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseAsynchronously; <span class="comment">// 是否异步释放对象，默认 YES</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)objectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count; <span class="comment">// 用 LRU 算法删除对象，直到 totalCount &lt;= count</span></span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost; <span class="comment">// 用 LRU 算法删除对象，直到 totalCost &lt;= cost</span></span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age; <span class="comment">// 用 LRU 算法删除对象，直到所有到期对象全部被删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYMemoryCache 的定义代码比较简单~ 该有的注释我已经加到了上面，这里 LRU 算法的实现我准备单独拎出来放到后面和（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）一起讲。我们这里只需要再关注一下 YYMemoryCache 是如何做到线程安全的。</p>
<h3 id="YYMemoryCache-是如何做到线程安全的"><a href="#YYMemoryCache-是如何做到线程安全的" class="headerlink" title="YYMemoryCache 是如何做到线程安全的"></a>YYMemoryCache 是如何做到线程安全的</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYMemoryCache</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 线程锁，旨在保证 YYMemoryCache 线程安全</span></span><br><span class="line">    _YYLinkedMap *_lru; <span class="comment">// _YYLinkedMap，YYMemoryCache 通过它间接操作缓存对象</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _queue; <span class="comment">// 串行队列，用于 YYMemoryCache 的 trim 操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这里 ibireme 选择使用 <code>pthread_mutex</code> 线程锁来确保 YYMemoryCache 的线程安全。</p>
<blockquote>
<p>有趣的是，这里 ibireme 使用 <code>pthread_mutex</code> 是有一段小故事的。在最初 YYMemoryCache 这里使用的锁是 <code>OSSpinLock</code> 自旋锁（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 备注-关于锁），后面有人在 Github 向作者提 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel/issues/43">issue</a> 反馈 <code>OSSpinLock</code> 不安全，经过作者的确认（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a>）最后选择用 <code>pthread_mutex</code> 替代 <code>OSSpinLock</code>。</p>
</blockquote>
<img src="/yycache/lock_benchmark.jpg" class="">
<p>上面是 ibireme 在确认 <code>OSSpinLock</code> 不再安全之后为了寻找替代方案做的简单性能测试，对比了一下几种能够替代 <code>OSSpinLock</code> 锁的性能。在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a> 文末的评论中，我找到了作者使用 <code>pthread_mutex</code> 的原因。</p>
<blockquote>
<p>ibireme: 苹果员工说 libobjc 里 <code>spinlock</code> 是用了一些私有方法 (<code>mach_thread_switch</code>)，贡献出了高线程的优先来避免优先级反转的问题，但是我翻了下 libdispatch 的源码倒是没发现相关逻辑，也可能是我忽略了什么。在我的一些测试中，<code>OSSpinLock</code> 和 <code>dispatch_semaphore</code> 都不会产生特别明显的死锁，所以我也无法确定用 <code>dispatch_semaphore</code> 代替 <code>OSSpinLock</code> 是否正确。能够肯定的是，用 <code>pthread_mutex</code> 是安全的。</p>
</blockquote>
<h3 id="YYLinkedMapNode-与-YYLinkedMap"><a href="#YYLinkedMapNode-与-YYLinkedMap" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code></h3><p>上文介绍了 YYMemoryCache，其实 YYMemoryCache 并不直接操作缓存对象，而是通过内部的 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 来间接的操作缓存对象。这两个类对于上文中提到的 LRU 缓存算法的理解至关重要，所以我把他们俩单独拎出来放在这里详细解读一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 中的一个节点。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    <span class="type">id</span> _key;</span><br><span class="line">    <span class="type">id</span> _value;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost; <span class="comment">// 记录开销，对应 YYMemoryCache 提供的 cost 控制</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">// 记录时间，对应 YYMemoryCache 提供的 age 控制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYMemoryCache 内的一个链表。</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// 不要直接设置该对象</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;</span><br><span class="line">    _YYLinkedMapNode *_head; <span class="comment">// MRU, 最常用节点，不要直接修改它</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// LRU, 最少用节点，不要直接修改它</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseOnMainThread; <span class="comment">// 对应 YYMemoryCache 的 releaseOnMainThread</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseAsynchronously; <span class="comment">// 对应 YYMemoryCache 的 releaseAsynchronously</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表操作，看接口名称应该不需要注释吧~</span></span><br><span class="line">- (<span class="type">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line">- (<span class="type">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便大家阅读，我标注了必要的中文注释。其实对数据结构与算法不陌生的同学应该一眼就看的出来 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 这俩货的本质。没错，丫就是双向链表节点和双向链表。</p>
<p><code>_YYLinkedMapNode</code> 作为双向链表节点，除了基本的 <code>_prev</code>、<code>_next</code>，还有键值缓存基本的 <code>_key</code> 与 <code>_value</code>，<strong>我们可以把 <code>_YYLinkedMapNode</code> 理解为 YYMemoryCache 中的一个缓存对象</strong>。</p>
<p><code>_YYLinkedMap</code> 作为由 <code>_YYLinkedMapNode</code> 节点组成的双向链表，使用 <code>CFMutableDictionaryRef _dic</code> 字典存储 <code>_YYLinkedMapNode</code>。这样在确保 <code>_YYLinkedMapNode</code> 被强引用的同时，能够利用字典的 Hash 快速定位用户要访问的缓存对象，这样既符合了键值缓存的概念又省去了自己实现的麻烦（笑）。</p>
<p>嘛~ 总得来说 YYMemoryCache 是通过使用 <code>_YYLinkedMap</code> 双向链表来操作 <code>_YYLinkedMapNode</code> 缓存对象节点的。</p>
<h3 id="LRU-least-recently-used-算法的实现"><a href="#LRU-least-recently-used-算法的实现" class="headerlink" title="LRU(least-recently-used) 算法的实现"></a>LRU(least-recently-used) 算法的实现</h3><p>上文我们认清了 <code>_YYLinkedMap</code> 与 <code>_YYLinkedMapNode</code> 本质上就是双向链表和链表节点，这里我们简单讲一下 YYMemoryCache 是如何利用双向链表实现 LRU(least-recently-used) 算法的。</p>
<h4 id="缓存替换策略"><a href="#缓存替换策略" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h4><p>首先 LRU 是缓存替换策略（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Cache replacement policies</a>）的一种，还有很多缓存替换策略诸如：</p>
<ul>
<li>First In First Out (FIFO)</li>
<li>Last In First Out (LIFO)</li>
<li>Time aware Least Recently Used (TLRU)</li>
<li>Most Recently Used (MRU)</li>
<li>Pseudo-LRU (PLRU)</li>
<li>Random Replacement (RR)</li>
<li>Segmented LRU (SLRU)</li>
<li>Least-Frequently Used (LFU)</li>
<li>Least Frequent Recently Used (LFRU)</li>
<li>LFU with Dynamic Aging (LFUDA)</li>
<li>Low Inter-reference Recency Set (LIRS)</li>
<li>Adaptive Replacement Cache (ARC)</li>
<li>Clock with Adaptive Replacement (CAR)</li>
<li>Multi Queue (MQ) caching algorithm|Multi Queue (MQ)</li>
<li>Pannier: Container-based caching algorithm for compound objects</li>
</ul>
<p>是不是被唬到了？不要担心，我这里会表述的尽量易懂。</p>
<h4 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h4><img src="/yycache/cache_hit_ratio.png" class="">
<p>为什么有这么多缓存替换策略，或者说搞这么多名堂究竟是为了什么呢？</p>
<p>答案是提高缓存命中率，那么何谓缓存命中率呢？</p>
<p>Google 一下自然是有不少解释，不过很多都是 web 相关的，而且不说人话（很难理解），我个人非常讨厌各种不说人话的“高深”抽象概念。</p>
<p>这里抖了好几抖胆才敢谈一下我对于缓存命中率的理解（限于 YYCache 和 iOS 开发）。</p>
<ul>
<li>缓存命中 = 用户要访问的缓存对象在高速缓存中，我们直接在高速缓存中通过 Hash 将其找到并返回给用户。</li>
<li>缓存命中率 = 用户要访问的缓存对象在高速缓存中被我们访问到的概率。</li>
</ul>
<p>既然谈到了自己的理解，我索性说个够。</p>
<ul>
<li>缓存丢失 = 由于高速缓存数量有限（占据内存等原因），所以用户要访问的缓存对象很有可能被我们从有限的高速缓存中淘汰掉了，我们可能会将其存储于低速的磁盘缓存中（如果磁盘缓存还有资源的话），那么就要从磁盘缓存中获取该缓存对象以返回给用户，这种情况我理解为（高速）缓存未命中，即缓存丢失（并不是真的被我们丢掉了，但肯定是被我们从高速缓存淘汰掉了）。</li>
</ul>
<p>缓存命中是 cache-hit，那么如果你玩游戏，可以理解为这次 hit miss 了（笑，有人找我开黑吗）。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>首先来讲一下 LRU 的概念让大家有一个基本的认识。LRU(least-recently-used) 翻译过来是“最近最少使用”，顾名思义这种缓存替换策略是基于用户最近最少访问过的缓存对象而建立。</p>
<p>我认为 LRU 缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。</p>
<h4 id="YYLinkedMapNode-与-YYLinkedMap-实现-LRU"><a href="#YYLinkedMapNode-与-YYLinkedMap-实现-LRU" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap 实现 LRU"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 实现 LRU</h4><p>YYCache 作者通过 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 双向链表实现 LRU 缓存替换策略的思路其实很简捷清晰，我们一步一步来看。</p>
<p>双向链表中有头结点和尾节点：</p>
<ul>
<li>头结点 = 链表中用户最近一次使用（访问）的缓存对象节点，MRU。</li>
<li>尾节点 = 链表中用户已经很久没有再次使用（访问）的缓存对象节点，LRU。</li>
</ul>
<p>如何让头结点和尾节点指向我们想指向的缓存对象节点？我们结合代码来看：</p>
<ul>
<li>在用户使用（访问）时更新缓存节点信息，并将其移动至双向链表头结点。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)objectForKey:(<span class="type">id</span>)key &#123;</span><br><span class="line">    <span class="comment">// 判断入参</span></span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 找到对应缓存节点</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 更新缓存节点时间，并将其移动至双向链表头结点</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 返回找到的缓存节点 value</span></span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在用户设置缓存对象时，判断入参 key 对应的缓存对象节点是否存在？存在则更新缓存对象节点并将节点移动至链表头结点；不存在则根据入参生成新的缓存对象节点并插入链表表头。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setObject:(<span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    <span class="comment">// 判断入参，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 判断入参 key 对应的缓存对象节点是否存在</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存在则更新缓存对象节点并将节点移动至链表头结点</span></span><br><span class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class="line">        _lru-&gt;_totalCost += cost;</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在则根据入参生成新的缓存对象节点并插入链表表头</span></span><br><span class="line">        node = [_YYLinkedMapNode new];</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_key = key;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru insertNodeAtHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入、更新节点之后是否超过了限制 cost、count，如果超过则 trim，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在资源不足时，从双线链表的尾节点（LRU）开始清理缓存，释放资源。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里拿 count 资源举例，cost、age 自己举一反三</span></span><br><span class="line">- (<span class="type">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="comment">// 判断 countLimit 为 0，则全部清空缓存，省略</span></span><br><span class="line">    <span class="comment">// 判断 _lru-&gt;_totalCount &lt;= countLimit，没有超出资源限制则不作处理，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class="line">                <span class="comment">// 从双线链表的尾节点（LRU）开始清理缓存，释放资源</span></span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程</span></span><br><span class="line">            <span class="comment">// 对比 sleep 用 usleep 能更好的利用 CPU 时间</span></span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要在主线程释放，采取释放缓存对象操作</span></span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 是不是感觉敲简单？上面代码去掉了可能会分散大家注意力的代码，我们这里仅仅讨论 LRU 的实现，其余部分的具体实现源码也非常简单，我觉得没必要贴出来单独讲解，感兴趣的同学可以自己去 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 下载源码查阅。</p>
<h4 id="异步释放技巧"><a href="#异步释放技巧" class="headerlink" title="异步释放技巧"></a>异步释放技巧</h4><p>关于上面的异步释放缓存对象的代码，我觉得还是有必要单独拎出来讲一下的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">    [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个技巧 ibireme 在他的另一篇文章 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a> 中有提及：</p>
<blockquote>
<p>Note: 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
</blockquote>
<p>而上面代码中的 YYMemoryCacheGetReleaseQueue 这个队列源码为：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内联 dispatch_queue_t</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码中可以看到 YYMemoryCacheGetReleaseQueue 是一个低优先级 <code>DISPATCH_QUEUE_PRIORITY_LOW</code> 队列，猜测这样设计的原因是可以让 iOS 在系统相对空闲时再来异步释放缓存对象。</p>
<h2 id="YYDiskCache-细节剖析"><a href="#YYDiskCache-细节剖析" class="headerlink" title="YYDiskCache 细节剖析"></a>YYDiskCache 细节剖析</h2><img src="/yycache/yydiskcache.jpg" class="">
<p>YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。</p>
<p>YYDiskCache 具有以下功能：</p>
<ul>
<li>它使用 LRU(least-recently-used) 来删除对象。</li>
<li>支持按 cost，count 和 age 进行控制。</li>
<li>它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。</li>
<li>它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。</li>
</ul>
<blockquote>
<p>Note: 您可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYDiskCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path; <span class="comment">// 缓存路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold; <span class="comment">// 阈值，大于阈值则存储类型为 file；否则存储类型为 sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSData</span> *(^customArchiveBlock)(<span class="type">id</span> object); <span class="comment">// 用来替换 NSKeyedArchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">id</span> (^customUnarchiveBlock)(<span class="built_in">NSData</span> *data); <span class="comment">// 用来替换 NSKeyedUnarchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *(^customFileNameBlock)(<span class="built_in">NSString</span> *key); <span class="comment">// 当一个对象将以 file 的形式保存时，该代码块用来生成指定文件名。如果为 nil，则默认使用 md5(key) 作为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> freeDiskSpaceLimit; <span class="comment">// 缓存应该保留的最小可用磁盘空间（以字节为单位），默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 60s</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> errorLogsEnabled; <span class="comment">// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line">                                 </span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCount;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCost;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Extended Data</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getExtendedDataFromObject:(<span class="type">id</span>)object;</span><br><span class="line">+ (<span class="type">void</span>)setExtendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData toObject:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYDiskCache 结构与 YYMemoryCache 类似，由于很多接口都是基于基本的接口做了扩展所得，这里贴的代码省略了一些接口。代码还是一如既往的干净简洁，相信各位都能看懂。</p>
<p>YYDiskCache 是基于 sqlite 和 file 来做的磁盘缓存，我们的缓存对象可以自由的选择存储类型，下面简单对比一下：</p>
<ul>
<li>sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。</li>
<li>file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。</li>
</ul>
<p>所以 YYDiskCache 使用两者配合，灵活的存储以提高性能。</p>
<h3 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h3><p>NSMapTable 是类似于字典的集合，但具有更广泛的可用内存语义。NSMapTable 是 iOS6 之后引入的类，它基于 NSDictionary 建模，但是具有以下差异：</p>
<ul>
<li>键/值可以选择 “weakly” 持有，以便于在回收其中一个对象时删除对应条目。</li>
<li>它可以包含任意指针（其内容不被约束为对象）。</li>
<li>您可以将 NSMapTable 实例配置为对任意指针进行操作，而不仅仅是对象。</li>
</ul>
<blockquote>
<p>Note: 配置映射表时，请注意，只有 NSMapTableOptions 中列出的选项才能保证其余的 API 能够正常工作，包括复制，归档和快速枚举。 虽然其他 NSPointerFunctions 选项用于某些配置，例如持有任意指针，但并不是所有选项的组合都有效。使用某些组合，NSMapTableOptions 可能无法正常工作，甚至可能无法正确初始化。</p>
</blockquote>
<p>更多信息详见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsmaptable?language=objc">NSMapTable 官方文档</a>。</p>
<p>需要特殊说明的是，YYDiskCache 内部是基于一个单例 NSMapTable 管理的，这点有别于 YYMemoryCache。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSMapTable</span> *_globalInstances; <span class="comment">// 引用管理所有的 YYDiskCache 实例</span></span><br><span class="line"><span class="keyword">static</span> dispatch_semaphore_t _globalInstancesLock; <span class="comment">// YYDiskCache 使用 dispatch_semaphore 保障 NSMapTable 线程安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> YYDiskCache *_YYDiskCacheGetGlobal(<span class="built_in">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="type">id</span> cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做也会提升不少性能。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="comment">// 判断是否可以成功初始化，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先从 NSMapTable 单例中根据 path 获取 YYDiskCache 实例，如果获取到就直接返回该实例</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有获取到则初始化一个 YYDiskCache 实例</span></span><br><span class="line">    <span class="comment">// 要想初始化一个 YYDiskCache 首先要初始化一个 YYKVStorage</span></span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据刚才得到的 kv 和 path 入参初始化一个 YYDiskCache 实例，代码太长省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启递归清理，会根据 _autoTrimInterval 对 YYDiskCache trim</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    <span class="comment">// 向 NSMapTable 单例注册新生成的 YYDiskCache 实例</span></span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// App 生命周期通知相关代码，省略</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中找到了作者使用 dispatch_semaphore 作为 YYDiskCache 锁的原因：</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<h3 id="YYKVStorageItem-与-YYKVStorage"><a href="#YYKVStorageItem-与-YYKVStorage" class="headerlink" title="YYKVStorageItem 与 YYKVStorage"></a>YYKVStorageItem 与 YYKVStorage</h3><p>刚才在 YYDiskCache 的初始化源码中，我们不难发现一个类 YYKVStorage。与 YYMemoryCache 相对应的，YYDiskCache 也不会直接操作缓存对象（sqlite/file），而是通过 YYKVStorage 来间接的操作缓存对象。</p>
<p>从这一点上不难发现，YYKVStorage 等价于 YYMemoryCache 中的双向链表 <code>_YYLinkedMap</code>，而对应于 <code>_YYLinkedMap</code> 中的节点 <code>_YYLinkedMapNode</code>，YYKVStorage 中也有一个类 YYKVStorageItem 充当着与缓存对象一对一的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorageItem 是 YYKVStorage 中用来存储键值对和元数据的类</span></span><br><span class="line"><span class="comment">// 通常情况下，我们不应该直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">///&lt; key</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">///&lt; value</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">///&lt; filename (nil if inline)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> size;                             <span class="comment">///&lt; value&#x27;s size in bytes</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> modTime;                          <span class="comment">///&lt; modification unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> accessTime;                       <span class="comment">///&lt; last access unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">///&lt; extended data (nil if no extended data)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYKVStorage 是基于 sqlite 和文件系统的键值存储。</span></span><br><span class="line"><span class="comment"> 通常情况下，我们不应该直接使用这个类。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @warning </span></span><br><span class="line"><span class="comment">  这个类的实例是 *非* 线程安全的，你需要确保</span></span><br><span class="line"><span class="comment">  只有一个线程可以同时访问该实例。如果你真的</span></span><br><span class="line"><span class="comment">  需要在多线程中处理大量的数据，应该分割数据</span></span><br><span class="line"><span class="comment">  到多个 KVStorage 实例（分片）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorage</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;        <span class="comment">/// storage 路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYKVStorageType type;  <span class="comment">/// storage 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> errorLogsEnabled;           <span class="comment">/// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path type:(YYKVStorageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Save Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Remove Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Items</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Storage Status</span></span><br><span class="line">- (<span class="type">BOOL</span>)itemExistsForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">int</span>)getItemsCount;</span><br><span class="line">- (<span class="type">int</span>)getItemsSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>代码美哭了有木有！？这种代码根本不需要翻译，我觉得相比于逐行的翻译，直接看代码更舒服。这里我们只需要看一下 YYKVStorageType 这个枚举，他决定着 YYKVStorage 的存储类型。</p>
<h4 id="YYKVStorageType"><a href="#YYKVStorageType" class="headerlink" title="YYKVStorageType"></a>YYKVStorageType</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 存储类型，指示“YYKVStorageItem.value”存储在哪里。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @discussion</span></span><br><span class="line"><span class="comment">  通常，将数据写入 sqlite 比外部文件更快，但是</span></span><br><span class="line"><span class="comment">  读取性能取决于数据大小。在我的测试（环境 iPhone 6 64G），</span></span><br><span class="line"><span class="comment">  当数据较大（超过 20KB）时从外部文件读取数据比 sqlite 更快。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class="line">    YYKVStorageTypeFile = <span class="number">0</span>, <span class="comment">// value 以文件的形式存储于文件系统</span></span><br><span class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>, <span class="comment">// value 以二进制形式存储于 sqlite</span></span><br><span class="line">    YYKVStorageTypeMixed = <span class="number">2</span>, <span class="comment">// value 将根据你的选择基于上面两种形式混合存储</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 YYKVStorageType 的注释中标记了作者写 YYCache 时做出的测试结论，大家也可以基于自己的环境去测试验证作者的说法（这一点是可以讨论的，我们可以根据自己的测试来设置 YYDiskCache 中的 inlineThreshold 阈值）。</p>
<blockquote>
<p>如果想要了解更多的信息可以点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/intern-v-extern-blob.html">Internal Versus External BLOBs in SQLite</a> 查阅 SQLite 官方文档。</p>
</blockquote>
<h4 id="YYKVStorage-性能优化细节"><a href="#YYKVStorage-性能优化细节" class="headerlink" title="YYKVStorage 性能优化细节"></a>YYKVStorage 性能优化细节</h4><p>上文说到 YYKVStorage 可以基于 SQLite 和文件系统做磁盘存储，这里再提一些我阅读源码发现到的有趣细节：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYKVStorage</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">CFMutableDictionaryRef</span> _dbStmtCache; <span class="comment">// 焦点集中在这里</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>CFMutableDictionaryRef _dbStmtCache;</code> 是 YYKVStorage 中的私有成员，它是一个可变字典充当着 sqlite3_stmt 缓存的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite3_stmt *)_dbPrepareStmt:(<span class="built_in">NSString</span> *)sql &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> _dbCheck] || sql.length == <span class="number">0</span> || !_dbStmtCache) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt</span></span><br><span class="line">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class="built_in">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql));</span><br><span class="line">    <span class="keyword">if</span> (!stmt) &#123;</span><br><span class="line">        <span class="comment">// 如果没有缓存再从新生成一个 sqlite3_stmt</span></span><br><span class="line">        <span class="type">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 生成结果异常则根据错误日志开启标识打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite stmt prepare error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成成功则放入 _dbStmtCache 缓存</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql), stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlite3_reset(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以省去一些重复生成 sqlite3_stmt 的开销。</p>
<blockquote>
<p>sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。</p>
</blockquote>
<p>更多关于 SQLite 的信息请点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/docs.html">SQLite 官方文档</a> 查阅。</p>
<h2 id="优秀的缓存应该具备哪些特质"><a href="#优秀的缓存应该具备哪些特质" class="headerlink" title="优秀的缓存应该具备哪些特质"></a>优秀的缓存应该具备哪些特质</h2><img src="/yycache/good_cache.jpg" class="">
<p>嘛~ 我们回到文章最初提到的问题，优秀的缓存应该具备哪些特质？</p>
<p>如果跟着文章一步步读到这里，相信很容易举出以下几点：</p>
<ul>
<li>内存缓存和磁盘缓存</li>
<li>线程安全</li>
<li>缓存控制</li>
<li>缓存替换策略</li>
<li>缓存命中率</li>
<li>性能</li>
</ul>
<p>我们简单的总结一下 YYCache 源码中是如何体现这些特质的。</p>
<h3 id="内存缓存和磁盘缓存"><a href="#内存缓存和磁盘缓存" class="headerlink" title="内存缓存和磁盘缓存"></a>内存缓存和磁盘缓存</h3><p>YYCache 是由内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。</p>
<p>在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果说 YYCache 这个类是一个纯逻辑层的缓存类（指 YYCache 的接口实现全部是调用其他类完成），那么 YYMemoryCache 与 YYDiskCache 还是做了一些事情的（并没有 YYCache 当甩手掌柜那么轻松），其中最显而易见的就是 YYMemoryCache 与 YYDiskCache 为 YYCache 保证了线程安全。</p>
<p>YYMemoryCache 使用了 <code>pthread_mutex</code> 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 <code>dispatch_semaphore</code>，上文已经给出了作者选择这些锁的原因。</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>YYCache 提供了三种控制维度，分别是：cost、count、age。这已经满足了绝大多数开发者的需求，我们在自己设计缓存时也可以根据自己的使用环境提供合适的控制方式。</p>
<h3 id="缓存替换策略-1"><a href="#缓存替换策略-1" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h3><p>在上文解析 YYCache 源码的时候，介绍了缓存替换策略的概念并且列举了很多经典的策略。YYCache 使用了双向链表（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）实现了 LRU(least-recently-used) 策略，旨在提高 YYCache 的缓存命中率。</p>
<h3 id="缓存命中率-1"><a href="#缓存命中率-1" class="headerlink" title="缓存命中率"></a>缓存命中率</h3><p>这一概念是在上文解析 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 小节介绍的，我们在自己设计缓存时不一定非要使用 LRU 策略，可以根据我们的实际使用环境选择最适合我们自己的缓存替换策略。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>其实性能这个东西是隐而不见的，又是到处可见的（笑）。它从我们最开始设计一个缓存架构时就被带入，一直到我们具体的实现细节中慢慢成形，最后成为了我们设计出来的缓存优秀与否的决定性因素。</p>
<p>上文中剖析了太多 YYCache 中对于性能提升的实现细节：</p>
<ul>
<li>异步释放缓存对象</li>
<li>锁的选择</li>
<li>使用 NSMapTable 单例管理的 YYDiskCache</li>
<li>YYKVStorage 中的 <code>_dbStmtCache</code></li>
<li>甚至使用 CoreFoundation 来换取微乎其微的性能提升</li>
</ul>
<p>看到这里是不是恍然大悟，性能是怎么来的？就是这样对于每一个细节的极致追求一点一滴积少成多抠出来的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的解读了 YYCache 源码，相信可以让各位读者对 YYCache 的整体架构有一个清晰的认识。</li>
<li>文章结合作者 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中的内容对 YYCache 具体功能点实现源码做了深入剖析，再用我自己的理解表述出来，希望可以对读者理解 YYCache 中具体功能的实现提供帮助。</li>
<li>根据我自己的源码理解，把我认为做的不错的提升性能的源码细节单独拎出来做出详细分析。</li>
<li>总结归纳出“一个优秀缓存需要具备哪些特质？”这一问题的答案，希望大家在面试中如果被问及“如何设计一个缓存”这类问题时可以游刃有余。额，至少可以为大家提供一些回答思路，抛砖引玉（笑）。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yycache/" rel="tag">yycache</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/ios_native_js/">
      iOS 与 JS 交互开发知识总结
    </a>
  </h2>
  
  <time>
    10月 23, 2017
  </time>
  <section class="content">
	  <img src="/ios_native_js/hybrid.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而说到 Native 与 JS 交互，就不得不提一嘴 Hybrid。</p>
<p>Hybrid 的翻译结果并不是很文明（擦汗，不知道为啥很多翻译软件会译为“杂种”，但我更喜欢将它翻译为“混合、混血”），Hybrid Mobile App 我对它的理解为通过 Web 网络技术（如 HTML，CSS 和 JavaScript）与 Native 相结合的混合移动应用程序。</p>
<p>那么我们来看一下 Hybrid 对比 Native 有哪些优劣：</p>
<img src="/ios_native_js/hybrid_vs_native.jpg" class="">
<p>因为 Hybrid 的灵活性（更改 Web 页面不必重新发版）以及通用性（一份 H5 玩遍所有平台）再加上门槛低（前端猿可以无痛上手开撸）的优势，所以在非核心功能模块使用 Web 通过 Hybrid 的方式来实现可能从各方面都会优于 Native。而 Native 则可以在核心功能和设备硬件的调用上为 JS 提供强有力的支持。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Hybrid 的发展简史</li>
<li>JavaScriptCore 简介</li>
<li>iOS Native 与 JS 交互的方法</li>
<li>WKWebView 与 JS 交互的特有方法</li>
<li>JS 通过 Native 调用 iOS 设备摄像头的 Demo</li>
<li>总结</li>
</ul>
<h2 id="Hybrid-的发展简史"><a href="#Hybrid-的发展简史" class="headerlink" title="Hybrid 的发展简史"></a>Hybrid 的发展简史</h2><p>下面简述一下 Hybrid 的发展史：</p>
<h3 id="1-H5-发布"><a href="#1-H5-发布" class="headerlink" title="1.H5 发布"></a>1.H5 发布</h3><img src="/ios_native_js/html5.png" class="">
<p>Html5 是在 2014 年 9 月份正式发布的，这一次的发布做了一个最大的改变就是“从以前的 XML 子集升级成为一个独立集合”。</p>
<h3 id="2-H5-渗入-Mobile-App-开发"><a href="#2-H5-渗入-Mobile-App-开发" class="headerlink" title="2.H5 渗入 Mobile App 开发"></a>2.H5 渗入 Mobile App 开发</h3><p>Native APP 开发中有一个 webview 的组件（Android 中是 webview，iOS 有 UIWebview和 WKWebview），这个组件可以加载 Html 文件。</p>
<p>在 H5 大行其道之前，webview 加载的 web 页面很单调（因为只能加载一些静态资源），自从 H5 火了之后，前端猿们开发的 H5 页面在 webview 中的表现不俗使得 H5 开发慢慢渗透到了 Mobile App 开发中来。</p>
<h3 id="3-Hybrid-现状"><a href="#3-Hybrid-现状" class="headerlink" title="3.Hybrid 现状"></a>3.Hybrid 现状</h3><p>虽然目前已经出现了 RN 和 Weex 这些使用 JS 写 Native App 的技术，但是 Hybrid 仍然没有被淘汰，市面上大多数应用都不同程度的引入了 Web 页面。</p>
<h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>JavaScriptCore 这个库是 Apple 在 iOS 7 之后加入到标准库的，它对 iOS Native 与 JS 做交互调用产生了划时代的影响。</p>
<p>JavaScriptCore 大体是由 4 个类以及 1 个协议组成的：</p>
<img src="/ios_native_js/javascriptcore_framework.jpg" class="">
<ul>
<li>JSContext 是 JS 执行上下文，你可以把它理解为 JS 运行的环境。</li>
<li>JSValue 是对 JavaScript 值的引用，任何 JS 中的值都可以被包装为一个 JSValue。</li>
<li>JSManagedValue 是对 JSValue 的包装，加入了“conditional retain”。</li>
<li>JSVirtualMachine 表示 JavaScript 执行的独立环境。</li>
</ul>
<p>还有 JSExport 协议：</p>
<blockquote>
<p>实现将 Objective-C 类及其实例方法，类方法和属性导出为 JavaScript 代码的协议。</p>
</blockquote>
<p>这里的 JSContext，JSValue，JSManagedValue 相对比较好理解，下面我们把 JSVirtualMachine 单拎出来说明一下：</p>
<h3 id="JSVirtualMachine-的用法和其与-JSContext-的关系"><a href="#JSVirtualMachine-的用法和其与-JSContext-的关系" class="headerlink" title="JSVirtualMachine 的用法和其与 JSContext 的关系"></a>JSVirtualMachine 的用法和其与 JSContext 的关系</h3><img src="/ios_native_js/jsvirtualmachine.jpg" class="">
<p>官方文档的介绍：</p>
<blockquote>
<p>JSVirtualMachine 实例表示用于 JavaScript 执行的独立环境。 您使用此类有两个主要目的：支持并发 JavaScript 执行，并管理 JavaScript 和 Objective-C 或 Swift 之间桥接的对象的内存。</p>
</blockquote>
<p>关于 JSVirtualMachine 的使用，一般情况下我们不用手动去创建 JSVirtualMachine。因为当我们获取 JSContext 时，获取到的 JSContext 从属于一个 JSVirtualMachine。</p>
<p>每个 JavaScript 上下文（JSContext 对象）都属于一个 JSVirtualMachine。 每个 JSVirtualMachine 可以包含多个上下文，允许在上下文之间传递值（JSValue 对象）。 但是，每个 JSVirtualMachine 是不同的，即我们不能将一个 JSVirtualMachine 中创建的值传递到另一个 JSVirtualMachine 中的上下文。</p>
<p>JavaScriptCore API 是线程安全的 —— 例如，我们可以从任何线程创建 JSValue 对象或运行 JS 脚本 - 但是，尝试使用相同 JSVirtualMachine 的所有其他线程将被阻塞。 要在多个线程上同时（并发）运行 JavaScript 脚本，请为每个线程使用单独的 JSVirtualMachine 实例。</p>
<h3 id="JSValue-与-JavaScript-的转换表"><a href="#JSValue-与-JavaScript-的转换表" class="headerlink" title="JSValue 与 JavaScript 的转换表"></a>JSValue 与 JavaScript 的转换表</h3><table>
<thead>
<tr>
<th>OBJECTIVE-C</th>
<th>JAVASCRIPT</th>
<th>JSVALUE CONVERT</th>
<th>JSVALUE CONSTRUCTOR</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil</td>
<td>undefined</td>
<td></td>
<td>valueWithUndefinedInContext</td>
</tr>
<tr>
<td>NSNull</td>
<td>null</td>
<td></td>
<td>valueWithNullInContext:</td>
</tr>
<tr>
<td>NSString</td>
<td>string</td>
<td>toString</td>
<td></td>
</tr>
<tr>
<td>NSNumber</td>
<td>number, boolean</td>
<td>toNumber<br />toBool<br />toDouble<br />toInt32<br />toUInt32</td>
<td>valueWithBool:inContext:<br />valueWithDouble:inContext:<br />valueWithInt32:inContext:<br />valueWithUInt32:inContext:</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Object object</td>
<td>toDictionary</td>
<td>valueWithNewObjectInContext:</td>
</tr>
<tr>
<td>NSArray</td>
<td>Array object</td>
<td>toArray</td>
<td>valueWithNewArrayInContext:</td>
</tr>
<tr>
<td>NSDate</td>
<td>Date object</td>
<td>toDate</td>
<td></td>
</tr>
<tr>
<td>NSBlock</td>
<td>Function object</td>
<td></td>
<td></td>
</tr>
<tr>
<td>id</td>
<td>Wrapper object</td>
<td>toObject<br />toObjectOfClass:</td>
<td>valueWithObject:inContext:</td>
</tr>
<tr>
<td>Class</td>
<td>Constructor object</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="iOS-Native-与-JS-交互"><a href="#iOS-Native-与-JS-交互" class="headerlink" title="iOS Native 与 JS 交互"></a>iOS Native 与 JS 交互</h2><p>对于 iOS Native 与 JS 交互我们先从调用方向上分为两种情况来看：</p>
<ul>
<li>JS 调用 Native</li>
<li>Native 调用 JS</li>
</ul>
<img src="/ios_native_js/call_eachother.jpg" class="">
<h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>其实 JS 调用 iOS Native 也分为两种实现方式：</p>
<ul>
<li>假 Request 方法</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="假-Request-方法"><a href="#假-Request-方法" class="headerlink" title="假 Request 方法"></a>假 Request 方法</h4><p>原理：其实这种方式就是利用了 webview 的代理方法，在 webview 开始请求的时候截获请求，判断请求是否为约定好的假请求。如果是假请求则表示是 JS 想要按照约定调用我们的 Native 方法，按照约定去执行我们的 Native 代码就好。</p>
<h5 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 代理有用于截获请求的函数，在里面做判断就好：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>WKWebView 有两个代理，一个是 WKNavigationDelegate，另一个是 WKUIDelegate。WKUIDelegate 我们在下面的章节会讲到，这里我们需要设置并实现它的 WKNavigationDelegate 方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>decisionHandler</code> 是当你的应用程序决定是允许还是取消导航时，要调用的代码块。 该代码块使用单个参数，它必须是枚举类型 <code>WKNavigationActionPolicy</code> 的常量之一。如果不调用 <code>decisionHandler</code> 会引起 crash。</p>
</blockquote>
<p>这里补充一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callNative</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">loadURL</span>(<span class="string">&quot;your_func_name://xxx&quot;</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>然后拿个 button 标签用一下就好了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;callNative()&quot;&gt;Call Native!&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="JavaScriptCore-方法"><a href="#JavaScriptCore-方法" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>iOS 7 有了 JavaScriptCore 专门用来做 Native 与 JS 的交互。我们可以在 webview 完成加载之后获取 JSContext，然后利用 JSContext 将 JS 中的对象引用过来用 Native 代码对其作出解释或响应：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再 UIWebView 的完成加载的代理方法中</span></span><br><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="comment">// 获取 JS 上下文</span></span><br><span class="line">    jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line">    <span class="comment">// 做引用，将 JS 内的元素引用过来解释，比如方法可以解释成 Block，对象也可以指向 OC 的 Native 对象哦</span></span><br><span class="line">    jsContext[<span class="string">@&quot;iosDelegate&quot;</span>] = <span class="keyword">self</span>;</span><br><span class="line">    jsContext[<span class="string">@&quot;yourFuncName&quot;</span>] = ^(<span class="type">id</span> parameter)&#123;</span><br><span class="line">        <span class="comment">// 注意这里的线程默认是 web 处理的线程，如果涉及主线程操作需要手动转到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 JS 这边代码更简单了，干脆声明一个不解释的函数（约定好名字的），用于给 Native 做引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parameter = xxx;</span><br><span class="line"><span class="title function_">yourFuncName</span>(parameter);</span><br></pre></td></tr></table></figure>
<h3 id="iOS-Native-调用-JS"><a href="#iOS-Native-调用-JS" class="headerlink" title="iOS Native 调用 JS"></a>iOS Native 调用 JS</h3><p>iOS Native 调用 JS 的实现方法也被 JavaScriptCore 划分开来：</p>
<ul>
<li>webview 直接注入 JS 并执行</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="webview-直接注入-JS-并执行"><a href="#webview-直接注入-JS-并执行" class="headerlink" title="webview 直接注入 JS 并执行"></a>webview 直接注入 JS 并执行</h4><p>在 iOS 平台，webview 有注入并执行 JS 的 API。</p>
<h5 id="UIWebView-1"><a href="#UIWebView-1" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 有直接注入 JS 的方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;showAlert(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;alert msg&quot;</span>];</span><br><span class="line">[_webView stringByEvaluatingJavaScriptFromString:jsStr];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 这个方法会返回运行 JS 的结果（<code>nullable NSString *</code>），它是一个同步方法，会阻塞当前线程！尽管此方法不被弃用，但最佳做法是使用 <code>WKWebView</code> 类的 <code>evaluateJavaScript：completionHandler：method</code>。</p>
<p>官方文档：<br>The stringByEvaluatingJavaScriptFromString: method waits synchronously for JavaScript evaluation to complete. If you load web content whose JavaScript code you have not vetted, invoking this method could hang your app. Best practice is to adopt the WKWebView class and use its evaluateJavaScript:completionHandler: method instead.</p>
</blockquote>
<h5 id="WKWebView-1"><a href="#WKWebView-1" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>不同于 UIWebView，WKWebView 注入并执行 JS 的方法不会阻塞当前线程。因为考虑到 webview 加载的 web content 内 JS 代码不一定经过验证，如果阻塞线程可能会挂起 App。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;setLocation(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;北京市东城区南锣鼓巷纳福胡同xx号&quot;</span>];</span><br><span class="line">[_webview evaluateJavaScript:jsStr completionHandler:^(<span class="type">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@----%@&quot;</span>, result, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 方法不会阻塞线程，而且它的回调代码块总是在主线程中运行。</p>
<p>官方文档：<br>Evaluates a JavaScript string.<br>The method sends the result of the script evaluation (or an error) to the completion handler. The completion handler always runs on the main thread.</p>
</blockquote>
<h4 id="JavaScriptCore-方法-1"><a href="#JavaScriptCore-方法-1" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>上面简单提到过 JavaScriptCore 库提供的 JSValue 类，这里再提供一下官方文档对 JSValue 的介绍翻译：</p>
<blockquote>
<p>JSValue 实例是对 JavaScript 值的引用。 您可以使用 JSValue 类来转换 JavaScript 和 Objective-C 或 Swift 之间的基本值（如数字和字符串），以便在本机代码和 JavaScript 代码之间传递数据。</p>
</blockquote>
<p>不过你也看到了我贴在上面的 OC 和 JS 数据类型转换表，那里面根本没有限定为官方文档所说的基本值。如果你不熟悉 JS 的话，我这里解释一下为什么 JSValue 也可以指向 JS 中的对象和函数，因为 JS 语言不区分基本值和对象以及函数，在 JS 中“万物皆为对象”。</p>
<p>好了下面直接 show code：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先获取 JS 上下文</span></span><br><span class="line"><span class="keyword">self</span>.jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line"><span class="comment">// 如果涉及 UI 操作，切回主线程调用 JS 代码中的 YourFuncName，通过数组@[parameter] 入参</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    JSValue *jsValue = <span class="keyword">self</span>.jsContext[<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">    [jsValue callWithArguments:@[parameter]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码调用了 JS 代码中 YourFuncName 函数，并且给函数加了 @[parameter] 作为入参。为了方便阅读理解，这里再贴一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">YourFuncName</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="comment">// do what u want to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WKWebView-与-JS-交互的特有方法"><a href="#WKWebView-与-JS-交互的特有方法" class="headerlink" title="WKWebView 与 JS 交互的特有方法"></a>WKWebView 与 JS 交互的特有方法</h2><img src="/ios_native_js/wkwebview.jpg" class="">
<p>关于 WKWebView 与 UIWebView 的区别就不在本文加以详细说明了，更多信息还请自行查阅。这里要讲的是 WKWebView 在与 JS 的交互时特有的方法：</p>
<ul>
<li>WKUIDelegate 方法</li>
<li>MessageHandler 方法</li>
</ul>
<h3 id="WKUIDelegate-方法"><a href="#WKUIDelegate-方法" class="headerlink" title="WKUIDelegate 方法"></a>WKUIDelegate 方法</h3><p>对于 WKWebView 上文提到过，除了 WKNavigationDelegate，它还有一个 WKUIDelegate，这个 WKUIDelegate 是做什么用的呢？ </p>
<p>WKUIDelegate 协议包含一些函数用来监听 web JS 想要显示 alert 或 confirm 时触发。我们如果在 WKWebView 中加载一个 web 并且想要 web JS 的 alert 或 confirm 正常弹出，就需要实现对应的代理方法。</p>
<blockquote>
<p>Note: 如果没有实现对应的代理方法，则 webview 将会按照默认操作去做出行为。</p>
<ul>
<li>Alert: If you do not implement this method, the web view will behave as if the user selected the OK button.</li>
<li>Confirm: If you do not implement this method, the web view will behave as if the user selected the Cancel button.</li>
</ul>
</blockquote>
<p>我们这里就拿 alert 举例，相信各位读者可以自己举一反三。下面是在 WKUIDelegate 监听 web 要显示 alert 的代理方法中用 Native UIAlertController 替代 JS 中的 alert 显示的栗子 ：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="type">void</span> (^)(<span class="type">void</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// 用 Native 的 UIAlertController 弹窗显示 JS 将要提示的信息</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@&quot;提醒&quot;</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    [alert addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;知道了&quot;</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="comment">// 函数内必须调用 completionHandler</span></span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MessageHandler-方法"><a href="#MessageHandler-方法" class="headerlink" title="MessageHandler 方法"></a>MessageHandler 方法</h3><p>MessageHandler 是继 Native 截获 JS 假请求后另一种 JS 调用 Native 的方法，该方法利用了 WKWebView 的新特性实现。对比截获假 Request 的方法来说，MessageHandler 传参数更加简单方便。</p>
<h4 id="MessageHandler-指什么？"><a href="#MessageHandler-指什么？" class="headerlink" title="MessageHandler 指什么？"></a>MessageHandler 指什么？</h4><p>WKUserContentController 类有一个方法:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addScriptMessageHandler:(<span class="type">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><br>该方法用来添加一个脚本处理器，可以在处理器内对 JS 脚本调用的方法做出处理，从而达到 JS 调用 Native 的目的。</p>
<p>那么 WKUserContentController 类和 WKWebView 有毛关系呢？</p>
<p>在 WKWebView 的初始化函数中有一个入参 configuration，它的类型是 WKWebViewConfiguration。WKWebViewConfiguration 中包含一个属性 userContentController，这个 userContentController 就是 WKUserContentController 类型的实例，我们可以用这个 userContentController 来添加不同名称的脚本处理器。</p>
<img src="/ios_native_js/wkusercontentcontroller.jpg" class="">
<h5 id="MessageHandler-的坑"><a href="#MessageHandler-的坑" class="headerlink" title="MessageHandler 的坑"></a>MessageHandler 的坑</h5><p>那么回到 <code>- (void)addScriptMessageHandler:name:</code> 方法上面，该方法添加一个脚本消息处理器（第一个入参 scriptMessageHandler），并且给这个处理器起一个名字（第二个入参 name）。不过这个函数在使用的时候有个坑：scriptMessageHandler 入参会被强引用，那么如果你把当前 WKWebView 所在的 UIViewController 作为第一个入参，这个 viewController 被他自己所持有的 <code>webview.configuration. userContentController</code> 所持有，就会造成循环引用。</p>
<img src="/ios_native_js/retaincycle.jpg" class="">
<p>我们可以通过 <code>- (void)removeScriptMessageHandlerForName:</code> 方法删掉 userContentController 对 viewController 的强引用。所以一般情况下我们的代码会在 <code>viewWillAppear</code> 和 <code>viewWillDisappear</code> 成对儿的添加和删除 MessageHandler：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController removeScriptMessageHandlerForName:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKScriptMessageHandler-协议"><a href="#WKScriptMessageHandler-协议" class="headerlink" title="WKScriptMessageHandler 协议"></a>WKScriptMessageHandler 协议</h5><p>WKScriptMessageHandler 是脚本信息处理器协议，如果想让一个对象具有脚本信息处理能力（比如上文中 webview 的所属 viewController 也就是上面代码的 self）就必须使其遵循该协议。</p>
<p>WKScriptMessageHandler 协议内部非常简单，只有一个方法，我们必须要实现该方法（@required）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKScriptMessageHandler 协议方法，在接收到脚本信息时触发</span></span><br><span class="line">- (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    <span class="comment">// message 有两个属性：name 和 body</span></span><br><span class="line">    <span class="comment">// message.name 可以用于区别要做的处理</span></span><br><span class="line">    <span class="keyword">if</span> ([message.name isEqualToString:<span class="string">@&quot;YourFuncName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// message.body 相当于 JS 传递过来的参数</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;JS call native success %@&quot;</span>, message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充 JS 的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;name&gt; 换 YourFuncName，&lt;messageBody&gt; 换你要的入参即可</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.&lt;name&gt;.<span class="title function_">postMessage</span>(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure>
<p>搞定收工！</p>
<h2 id="JS-通过-Native-调用-iOS-设备摄像头的-Demo"><a href="#JS-通过-Native-调用-iOS-设备摄像头的-Demo" class="headerlink" title="JS 通过 Native 调用 iOS 设备摄像头的 Demo"></a>JS 通过 Native 调用 iOS 设备摄像头的 Demo</h2><p>徒手撸了一个 Demo，实现了 JS 与 Native 代码的交互，达到用 JS 在 webview 内调用 iOS 设备摄像头的功能。Demo 内含权限申请，用户拒绝授权等细节（技术上就是 JS 和 Native 相互传值调用），还请各位大佬指教。</p>
<p>向各位基佬低头，献上我的膝盖~<a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">（Demo 地址）</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这篇文章简单的介绍了一下 Hybrid Mobile App（其中还包括 Hybrid 的发展简史）。</li>
<li>介绍了 JavaScriptCore 的组成，并且把 JSVirtualMachine 与 JSContext 和 JSValue 之间的关系用图片的形式表述出来（JSVirtualMachine 包含 JSContext 包含 JSValue，都是 1 对 n 的关系，且由于同一个 JSVirtualMachine 下的代码会相互阻塞，所以如果想异步执行交互需要在不同的线程声明 JSVirtualMachine 并发执行）。</li>
<li>从调用方向的角度把 JS 与 iOS Native 相互调用的方式方法分别用代码示例讲解了一遍。</li>
<li>介绍了 WKWebView 与 JS 交互特有的方法：WKUIDelegate 和 MessageHandler。</li>
<li>提供了一个 JS 通过 Native 调用 iOS 设备摄像头的 Demo。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
</section>



      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
