<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/page/19/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      





<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/yymodel0x01/">
      揭秘 YYModel 的魔法 0x01
    </a>
  </h2>
  
  <time>
    11月 12, 2017
  </time>
  <section class="content">
	  <img src="/yymodel0x01/design_model_0x01.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中少不了各种各样的模型，不论是采用 MVC、MVP 还是 MVVM 设计模式都逃不过 Model。</p>
<p>那么大家在使用 Model 的时候肯定遇到过一个问题，即接口传递过来的数据（一般是 JSON 格式）需要转换为 iOS 内我们能直接使用的模型（类）。iOS 开发早期第三方框架没有那么多，大家可能会手写相关代码，但是随着业务的扩展，模型的增多，这些没什么技术含量的代码只是在重复的浪费我们的劳动力而已。</p>
<p>这时候就需要一种工具来帮助我们把劳动力从这些无意义的繁琐代码中解放出来，于是 GitHub 上出现了很多解决此类问题的第三方库，诸如 Mantle、JSONModel、MJExtension 以及 YYModel 等等。</p>
<p>这些库的神奇之处在于它们提供了模型与 JSON 数据的自动转换功能，仿佛具有魔法一般！本文将通过剖析 YYModel 源码一步一步破解这“神奇”的魔法。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a> 是一个高性能 iOS/OSX 模型转换框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 在我之前的文章【<a href="https://lision.me/yycache/">从 YYCache 源码 Get 到如何设计一个优秀的缓存</a>】中已经很详细的介绍过了，感兴趣的同学可以点进去了解一下。</p>
<p>YYModel 是一个非常轻量级的 JSON 模型自动转换库，代码风格良好且思路清晰，可以从源码中看到作者对 Runtime 深厚的理解。难能可贵的是 YYModel 在其轻量级的代码下还保留着自动类型转换，类型安全，无侵入等特性，并且具有接近手写解析代码的超高性能。</p>
<blockquote>
<p>处理 GithubUser 数据 10000 次耗时统计 (iPhone 6):</p>
</blockquote>
<img src="/yymodel0x01/yymodel_performance.png" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYModel 简介</li>
<li>YYClassInfo 剖析</li>
<li>NSObject+YYModel 探究</li>
<li>JSON 与 Model 相互转换</li>
<li>总结</li>
</ul>
<h2 id="YYModel-简介"><a href="#YYModel-简介" class="headerlink" title="YYModel 简介"></a>YYModel 简介</h2><img src="/yymodel0x01/yymodel.png" class="">
<p>撸了一遍 YYModel 的源码，果然是非常轻量级的 JSON 模型自动转换库，加上 YYModel.h 一共也只有 5 个文件。</p>
<p>抛开 YYModel.h 来看，其实只有 YYClassInfo 和 NSObject+YYModel 两个模块。</p>
<ul>
<li>YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用。</li>
<li>NSObject+YYModel 负责提供方便调用的接口以及实现具体的模型转换逻辑（借助 YYClassInfo 中的封装）。</li>
</ul>
<h2 id="YYClassInfo-剖析"><a href="#YYClassInfo-剖析" class="headerlink" title="YYClassInfo 剖析"></a>YYClassInfo 剖析</h2><img src="/yymodel0x01/yyclassinfo.jpg" class="">
<p>前面说到 YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用，我觉得如果需要与 Runtime 层级的结构体做对比的话，没什么比表格来的更简单直观了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">YYClassInfo</th>
<th style="text-align:center">Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">YYClassIvarInfo</td>
<td style="text-align:center"><code>objc_ivar</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassMethodInfo</td>
<td style="text-align:center"><code>objc_method</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassPropertyInfo</td>
<td style="text-align:center"><code>property_t</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassInfo</td>
<td style="text-align:center"><code>objc_class</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note: 本次比较基于 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime 源码</a> 723 版本。</p>
</blockquote>
<p>安~ 既然是剖析肯定不会列个表格这样子哈。</p>
<h3 id="YYClassIvarInfo-amp-amp-objc-ivar"><a href="#YYClassIvarInfo-amp-amp-objc-ivar" class="headerlink" title="YYClassIvarInfo &amp;&amp; objc_ivar"></a>YYClassIvarInfo &amp;&amp; objc_ivar</h3><p>我把 YYClassIvarInfo 看做是作者对 Runtime 层 <code>objc_ivar</code> 结构体的封装，<code>objc_ivar</code> 是 Runtime 中表示变量的结构体。</p>
<ul>
<li>YYClassIvarInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassIvarInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Ivar ivar; <span class="comment">///&lt; 变量，对应 objc_ivar</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 变量名称，对应 ivar_name</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) ptrdiff_t offset; <span class="comment">///&lt; 变量偏移量，对应 ivar_offset</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 变量类型编码，通过 ivar_getTypeEncoding 函数得到</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 变量类型，通过 YYEncodingGetType 方法从类型编码中得到</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithIvar:(Ivar)ivar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_ivar</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_name OBJC2_UNAVAILABLE; <span class="comment">// 变量名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_type OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="type">int</span> ivar_offset OBJC2_UNAVAILABLE; <span class="comment">// 变量偏移量</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__ <span class="comment">// 如果已定义 __LP64__ 则表示正在构建 64 位目标</span></span></span><br><span class="line">    <span class="type">int</span> space OBJC2_UNAVAILABLE; <span class="comment">// 变量空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 日常开发中 NSString 类型的属性我们都会用 copy 来修饰，而 YYClassIvarInfo 中的 <code>name</code> 和 <code>typeEncoding</code> 属性都用 strong 修饰。因为其内部是先通过 Runtime 方法拿到 <code>const char *</code> 之后通过 <code>stringWithUTF8String</code> 方法转为 NSString 的。所以即便是 NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。</p>
</blockquote>
<p>囧~ 不知道讲的这么细会不会反而引起反感，如果对文章有什么建议可以联系我 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">@薛定谔的猹</a> 。</p>
<blockquote>
<p>Note: 类型编码，关于 YYClassIvarInfo 中的 YYEncodingType 类型属性 type 的解析代码篇幅很长，而且没有搬出来的必要，可以参考官方文档 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Declared Properties</a> 阅读这部分源码。</p>
</blockquote>
<h3 id="YYClassMethodInfo-amp-amp-objc-method"><a href="#YYClassMethodInfo-amp-amp-objc-method" class="headerlink" title="YYClassMethodInfo &amp;&amp; objc_method"></a>YYClassMethodInfo &amp;&amp; objc_method</h3><p>相应的，YYClassMethodInfo 则是作者对 Runtime 中 <code>objc_method</code> 的封装，<code>objc_method</code> 在 Runtime 是用来定义方法的结构体。</p>
<ul>
<li>YYClassMethodInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassMethodInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Method method; <span class="comment">///&lt; 方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 方法名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL sel; <span class="comment">///&lt; 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) IMP imp; <span class="comment">///&lt; 方法实现，指向实现方法函数的函数指针</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 方法参数和返回类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *returnTypeEncoding; <span class="comment">///&lt; 返回值类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *argumentTypeEncodings; <span class="comment">///&lt; 参数类型编码数组</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMethod:(Method)method;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_method</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name OBJC2_UNAVAILABLE; <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable method_types OBJC2_UNAVAILABLE; <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp OBJC2_UNAVAILABLE; <span class="comment">// 方法实现（函数指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到基本也是一一对应的关系，除了类型编码的问题作者为了方便使用在封装时进行了扩展。</p>
<p>为了照顾对 Runtime 还没有一定了解的读者，我这里简单的解释一下 <code>objc_method</code> 结构体（都是我自己的认知，欢迎讨论）：</p>
<ul>
<li>SEL，selector 在 Runtime 中的表现形式，可以理解为方法选择器</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<ul>
<li>IMP，函数指针，指向具体实现逻辑的函数</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*IMP)(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> ); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> _Nullable (*IMP)(<span class="type">id</span> _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>关于更多 Runtime 相关的知识由于篇幅原因（真的写不完）就不在这篇文章介绍了，我推荐大家去鱼神的文章 <a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a> 学习（因为我最早接触 Runtime 就是通过这篇文章，笑~）。</p>
<p>有趣的是，鱼神的文章中对 SEL 的描述有一句“其实它就是个映射到方法的 C 字符串”，但是他在文章中没有介绍出处。本着对自己文章质量负责的原则，对于一切没有出处的表述都应该持有怀疑的态度，所以我下面讲一下自己的对于 SEL 的理解。</p>
<p>撸了几遍 Runtime 源码，发现不论是 objc-runtime-new 还是 objc-runtime-old 中都用 SEL 类型作为方法结构体的 name 属性类型，而且通过以下源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT SEL _Nonnull sel_registerName(<span class="keyword">const</span> <span class="type">char</span> * _Nonnull str)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">const</span> <span class="type">char</span> * _Nonnull sel_getName(SEL _Nonnull sel)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到通过一个 <code>const char *</code> 类型的字符串即可在 Runtime 系统中注册并返回一个 SEL，方法的名称则会映射到这个 SEL。</p>
<blockquote>
<p>官方注释：<br>Registers a method with the Objective-C runtime system, maps the method name to a selector, and returns the selector value.</p>
</blockquote>
<p>所以我觉得 SEL 和 <code>char *</code> 的的确确是有某种一一对应的映射关系，不过 SEL 的本质是否是 <code>char *</code> 就要打一个问号了。因为我在调试 SEL 阶段发现 SEL 内还有一个当前 SEL 的指针，与 <code>char *</code> 不同的是当 <code>char *</code> 赋值之后当前 <code>char *</code> 变量指针指向字符串首字符，而 SEL 则是 <no value available>，即我们无法直接看到它。</p>
<p>所以我做了一个无聊的测试，用相同的字符串初始化一个 <code>char *</code> 实例与一个 SEL 实例，之后尝试打印它们，有趣的是不论我使用 <code>%s</code> 还是 <code>%c</code> 都可以从两个实例中得到相同的打印输出，不知道鱼神是否做过相同的测试（笑~）</p>
<p>嘛~ 经过验证我们可以肯定 SEL 和 <code>char *</code> 存在某种映射关系，可以相互转换。同时猜测 SEL 本质上就是 <code>char *</code>，如果有哪位知道 SEL 与 <code>char *</code> 确切关系的可以留言讨论哟。</p>
<h3 id="YYClassPropertyInfo-amp-amp-property-t"><a href="#YYClassPropertyInfo-amp-amp-property-t" class="headerlink" title="YYClassPropertyInfo &amp;&amp; property_t"></a>YYClassPropertyInfo &amp;&amp; property_t</h3><p>YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装，<code>property_t</code> 在 Runtime 中是用来表示属性的结构体。</p>
<ul>
<li>YYClassPropertyInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassPropertyInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) objc_property_t property; <span class="comment">///&lt; 属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 属性名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 属性类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 属性类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *ivarName; <span class="comment">///&lt; 变量名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *protocols; <span class="comment">///&lt; 属性相关协议</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">getter</span>; <span class="comment">///&lt; getter 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">setter</span>; <span class="comment">///&lt; setter 方法选择器</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithProperty:(objc_property_t)property;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_t</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes; <span class="comment">// 修饰</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么说 YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> old_property *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h</span></span><br><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里唯一值得注意的就是 getter 与 setter 方法了。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先尝试获取属性的 getter 与 setter</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomGetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomSetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没有则按照标准规则自己造</span></span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">getter</span>) &#123;</span><br><span class="line">    _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>(_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">setter</span>) &#123;</span><br><span class="line">    _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;set%@%@:&quot;</span>, [_name substringToIndex:<span class="number">1</span>].uppercaseString, [_name substringFromIndex:<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="YYClassInfo-amp-amp-objc-class"><a href="#YYClassInfo-amp-amp-objc-class" class="headerlink" title="YYClassInfo &amp;&amp; objc_class"></a>YYClassInfo &amp;&amp; objc_class</h3><p>最后作者用 YYClassInfo 封装了 <code>objc_class</code>，<code>objc_class</code> 在 Runtime 中表示一个 Objective-C 类。</p>
<ul>
<li>YYClassInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class superCls; <span class="comment">///&lt; 超类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class metaCls;  <span class="comment">///&lt; 元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isMeta; <span class="comment">///&lt; 元类标识，自身是否为元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 类名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYClassInfo *superClassInfo; <span class="comment">///&lt; 父类（超类）信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassIvarInfo *&gt; *ivarInfos; <span class="comment">///&lt; 变量信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassMethodInfo *&gt; *methodInfos; <span class="comment">///&lt; 方法信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassPropertyInfo *&gt; *propertyInfos; <span class="comment">///&lt; 属性信息</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setNeedUpdate;</span><br><span class="line">- (<span class="type">BOOL</span>)needUpdate;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClassName:(<span class="built_in">NSString</span> *)className;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_class</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa OBJC_ISA_AVAILABILITY; <span class="comment">// isa 指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类（超类）指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 版本</span></span><br><span class="line">    <span class="type">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 信息</span></span><br><span class="line">    <span class="type">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 初始尺寸</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; <span class="comment">// 变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; <span class="comment">// 协议列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>额… 看来想完全避开 Runtime 的知识来讲 YYModel 源码是不现实的。这里简单介绍一下 Runtime 中关于 Class 的知识以便阅读，已经熟悉这方面知识的同学就当温习一下好了。</p>
<img src="/yymodel0x01/class_diagram.jpg" class="">
<ul>
<li>isa 指针，用于找到所属类，类对象的 isa 一般指向对应元类。</li>
<li>元类，由于 objc_class 继承于 objc_object，即类本身同时也是一个对象，所以 Runtime 库设计出元类用以表述类对象自身所具备的元数据。</li>
<li>cache，实际上当一个对象收到消息时并不会直接在 isa 指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了。为了优化方法调用的效率，加入了 cache，也就是说在收到消息时，会先去 cache 中查找，找不到才会去像上图所示遍历查找，相信苹果为了提升缓存命中率，应该也花了一些心思（笑~）。</li>
<li>version，我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<blockquote>
<p>关于 Version 的官方描述：<br>Classes derived from the Foundation framework NSObject class can set the class-definition version number using the setVersion: class method, which is implemented using the class_setVersion function.</p>
</blockquote>
<h4 id="YYClassInfo-的初始化细节"><a href="#YYClassInfo-的初始化细节" class="headerlink" title="YYClassInfo 的初始化细节"></a>YYClassInfo 的初始化细节</h4><p>关于 YYClassInfo 的初始化细节我觉得还是有必要分享出来的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 判空入参</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例缓存 classCache 与 metaCache，对应缓存类和元类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> classCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> metaCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        classCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        metaCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 这里把 dispatch_semaphore 当做锁来使用（当信号量只有 1 时）</span></span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化之前，首先会根据当前 YYClassInfo 是否为元类去对应的单例缓存中查找</span></span><br><span class="line">    <span class="comment">// 这里使用了上面的 dispatch_semaphore 加锁，保证单例缓存的线程安全 </span></span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    YYClassInfo *info = <span class="built_in">CFDictionaryGetValue</span>(class_isMetaClass(cls) ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls));</span><br><span class="line">    <span class="comment">// 如果找到了，且找到的信息需要更新的话则执行更新操作</span></span><br><span class="line">    <span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">        [info _update];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没找到，才会去老实初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">        info = [[YYClassInfo alloc] initWithClass:cls];</span><br><span class="line">        <span class="keyword">if</span> (info) &#123; <span class="comment">// 初始化成功</span></span><br><span class="line">            <span class="comment">// 线程安全</span></span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="comment">// 根据初始化信息选择向对应的类/元类缓存注入信息，key = cls，value = info</span></span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(info.isMeta ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls), (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(info));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下初始化的主要步骤：</p>
<ul>
<li>创建单例缓存，类缓存和元类缓存</li>
<li>使用 <code>dispatch_semaphore</code> 作为锁保证缓存线程安全</li>
<li>初始化前先去缓存中查找是否已经向缓存中注册过当前要初始化的 YYClassInfo</li>
<li>如果查找到缓存对象，则判断缓存对象是否需要更新并执行相关操作</li>
<li>如果缓存中未找到缓存对象则初始化</li>
<li>初始化成功后向缓存中注册该 YYClassInfo 实例</li>
</ul>
<p>其中，使用缓存可以有效减少我们在 JSON 模型转换时反复初始化 YYClassInfo 带来的开销，而 <code>dispatch_semaphore</code> 在信号量为 1 时是可以当做锁来使用的，虽然它在阻塞时效率超低，但是对于代码中的缓存阻塞这里属于低频事件，使用 <code>dispatch_semaphore</code> 在非阻塞状态下性能很高，这里锁的选择非常合适。</p>
<h4 id="关于-YYClassInfo-的更新"><a href="#关于-YYClassInfo-的更新" class="headerlink" title="关于 YYClassInfo 的更新"></a>关于 YYClassInfo 的更新</h4><p>首先 YYClassInfo 是作者对应 <code>objc_class</code> 封装出来的类，所以理应在其对应的 <code>objc_class</code> 实例发生变化时更新。那么 <code>objc_class</code> 什么时候会发生变化呢？</p>
<p>嘛~ 比如你使用了 <code>class_addMethod</code> 方法为你的模型类加入了一个方法等等。</p>
<p>YYClassInfo 有一个私有 BOOL 类型参数 <code>_needUpdate</code> 用以表示当前的 YYClassInfo 实例是否需要更新，并且提供了 <code>- (void)setNeedUpdate;</code> 接口方便我们在更改了自己的模型类时调用其将 <code>_needUpdate</code> 设置为 YES，当 <code>_needUpdate</code> 为 YES 时后面就不用我说了，相关的代码在上一节初始化中有哦。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">    [info _update];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 <code>_update</code>，它是 YYClassInfo 的私有方法，它的实现逻辑简单介绍就是清空当前 YYClassInfo 实例变量，方法以及属性，之后再重新初始化它们。由于 <code>_update</code> 实现源码并没有什么特别之处，我这里就不贴源码了。</p>
<p>嘛~ 对 YYClassInfo 的剖析到这里就差不多了。</p>
<h2 id="NSObject-YYModel-探究"><a href="#NSObject-YYModel-探究" class="headerlink" title="NSObject+YYModel 探究"></a>NSObject+YYModel 探究</h2><img src="/yymodel0x01/nsobject_yymodel.jpg" class="">
<p>如果说 YYClassInfo 主要是作者对 Runtime 层在 JSON 模型转换中需要用到的结构体的封装，那么 NSObject+YYModel 在 YYModel 中担当的责任则是利用 YYClassInfo 层级封装好的类切实的执行 JSON 模型之间的转换逻辑，并且提供了无侵入性的接口。</p>
<p>第一次阅读 NSObject+YYModel.m 的源码可能会有些不适应，这很正常。因为其大量使用了 Runtime 函数与 CoreFoundation 库，加上各种类型编码和递归解析，代码量也有 1800 多行了。</p>
<p>我简单把 NSObject+YYModel.m 的源码做了一下划分，这样划分之后代码看起来一样很简单清晰：</p>
<ul>
<li>类型编码解析</li>
<li>数据结构定义</li>
<li>递归模型转换</li>
<li>接口相关代码</li>
</ul>
<h3 id="类型编码解析"><a href="#类型编码解析" class="headerlink" title="类型编码解析"></a>类型编码解析</h3><p>类型编码解析代码主要集中在 NSObject+YYModel.m 的上面部分，涉及到 YYEncodingNSType 枚举的定义，配套 <code>YYClassGetNSType</code> 函数将 NS 类型转为 YYEncodingNSType 还有 <code>YYEncodingTypeIsCNumber</code> 函数判断类型是否可以直接转为 C 语言数值类型的函数。</p>
<p>此外还有将 id 指针转为对应 NSNumber 的函数 <code>YYNSNumberCreateFromID</code>，将 NSString 转为 NSDate 的 <code>YYNSDateFromString</code> 函数，这类函数主要是方便在模型转换时使用。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDate</span> *YYNSDateFromString(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="comment">// YYNSDateFromString 支持解析的最长时间字符串</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kParserNum 34</span></span><br><span class="line">    <span class="comment">// 这里创建了一个单例时间解析代码块数组</span></span><br><span class="line">    <span class="comment">// 为了避免重复创建这些 NSDateFormatter，它的初始化开销不小</span></span><br><span class="line">    <span class="keyword">static</span> YYNSDateParseBlock blocks[kParserNum + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 这里拿 `yyyy-MM-dd` 举例分析</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20  // Google</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@&quot;en_US_POSIX&quot;</span>];</span><br><span class="line">            formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">            <span class="comment">// 这里使用 blocks[10] 是因为 `yyyy-MM-dd` 的长度就是 10</span></span><br><span class="line">            blocks[<span class="number">10</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他的格式都是一样类型的代码，省略</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!string) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; kParserNum) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据入参的长度去刚才存满各种格式时间解析代码块的单例数组取出对应的代码块执行</span></span><br><span class="line">    YYNSDateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> kParserNum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 iOS 7 之前 NSDateFormatter 是<strong>非线程安全</strong>的。</p>
</blockquote>
<p>除此之外还用 YYNSBlockClass 指向了 NSBlock 类，实现过程也比较巧妙。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline Class YYNSBlockClass() &#123;</span><br><span class="line">    <span class="keyword">static</span> Class cls;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;&#125;;</span><br><span class="line">        cls = ((<span class="built_in">NSObject</span> *)block).class;</span><br><span class="line">        <span class="comment">// 轮询父类直到父类指向 NSObject 停止</span></span><br><span class="line">        <span class="keyword">while</span> (class_getSuperclass(cls) != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            cls = class_getSuperclass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cls; <span class="comment">// 拿到的就是 &quot;NSBlock&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>force_inline</code> 这种代码技巧，我说过我在写完 YYModel 或者攒到足够多的时候会主动拿出来与大家分享这些代码技巧，不过这里大家通过字面也不难理解，就是强制内联。</p>
<p>嘛~ 关于内联函数应该不需要我多说（笑）。</p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>NSObject+YYModel 中重新定义了两个类，通过它们来使用 YYClassInfo 中的封装。</p>
<table>
<thead>
<tr>
<th style="text-align:center">NSObject+YYModel</th>
<th style="text-align:center">YYClassInfo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>_YYModelPropertyMeta</code></td>
<td style="text-align:center">YYClassPropertyInfo</td>
</tr>
<tr>
<td style="text-align:center"><code>_YYModelMeta</code></td>
<td style="text-align:center">YYClassInfo</td>
</tr>
</tbody>
</table>
<h4 id="YYModelPropertyMeta"><a href="#YYModelPropertyMeta" class="headerlink" title="_YYModelPropertyMeta"></a>_YYModelPropertyMeta</h4><p><code>_YYModelPropertyMeta</code> 表示模型对象中的属性信息，它包含 YYClassPropertyInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelPropertyMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;             <span class="comment">///&lt; 属性名称</span></span><br><span class="line">    YYEncodingType _type;        <span class="comment">///&lt; 属性类型</span></span><br><span class="line">    YYEncodingNSType _nsType;    <span class="comment">///&lt; 属性在 Foundation 框架中的类型</span></span><br><span class="line">    <span class="type">BOOL</span> _isCNumber;             <span class="comment">///&lt; 是否为 CNumber</span></span><br><span class="line">    Class _cls;                  <span class="comment">///&lt; 属性类</span></span><br><span class="line">    Class _genericCls;           <span class="comment">///&lt; 属性包含的泛型类型，没有则为 nil</span></span><br><span class="line">    SEL _<span class="keyword">getter</span>;                 <span class="comment">///&lt; getter</span></span><br><span class="line">    SEL _<span class="keyword">setter</span>;                 <span class="comment">///&lt; setter</span></span><br><span class="line">    <span class="type">BOOL</span> _isKVCCompatible;       <span class="comment">///&lt; 如果可以使用 KVC 则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _isStructAvailableForKeyedArchiver; <span class="comment">///&lt; 如果可以使用 archiver/unarchiver 归/解档则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _hasCustomClassFromDictionary; <span class="comment">///&lt; 类/泛型自定义类型，例如需要在数组中实现不同类型的转换需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *_mappedToKey;      <span class="comment">///&lt; 映射 key</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyPath;   <span class="comment">///&lt; 映射 keyPath，如果没有映射到 keyPath 则返回 nil</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyArray;  <span class="comment">///&lt; key 或者 keyPath 的数组，如果没有映射多个键的话则返回 nil</span></span><br><span class="line">    YYClassPropertyInfo *_info;  <span class="comment">///&lt; 属性信息，详见上文 YYClassPropertyInfo &amp;&amp; property_t 章节</span></span><br><span class="line">    _YYModelPropertyMeta *_next; <span class="comment">///&lt; 如果有多个属性映射到同一个 key 则指向下一个模型属性元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="YYModelMeta"><a href="#YYModelMeta" class="headerlink" title="_YYModelMeta"></a>_YYModelMeta</h4><p><code>_YYModelMeta</code> 表示模型的类信息，它包含 YYClassInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    YYClassInfo *_classInfo;</span><br><span class="line">    <span class="comment">/// Key:被映射的 key 与 keyPath, Value:_YYModelPropertyMeta.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *_mapper;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 当前模型的所有 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_allPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到 keyPath 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_keyPathPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到多个 key 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_multiKeysPropertyMetas;</span><br><span class="line">    <span class="comment">/// 映射 key 与 keyPath 的数量，等同于 _mapper.count</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _keyMappedCount;</span><br><span class="line">    <span class="comment">/// 模型 class 类型</span></span><br><span class="line">    YYEncodingNSType _nsType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="递归模型转换"><a href="#递归模型转换" class="headerlink" title="递归模型转换"></a>递归模型转换</h3><p>NSObject+YYModel.m 内写了一些（间接）递归模型转换相关的函数，如 <code>ModelToJSONObjectRecursive</code> 之类的，由于涉及繁杂的模型编码解析以及代码量比较大等原因我不准备放在这里详细讲解。</p>
<p>我认为这种逻辑并不复杂但是牵扯较多的函数代码与结构/类型定义代码不同，后者更适合列出源码让读者对数据有全面清醒的认识，而前者结合功能实例讲更容易使读者对整条功能的流程有一个更透彻的理解。</p>
<p>所以我准备放到后面 JSON 与 Model 相互转换时一起讲。</p>
<h3 id="接口相关代码"><a href="#接口相关代码" class="headerlink" title="接口相关代码"></a>接口相关代码</h3><p>嘛~ 理由同上。</p>
<h2 id="半章总结"><a href="#半章总结" class="headerlink" title="半章总结"></a>半章总结</h2><ul>
<li>文章对 YYModel 源码进行了系统解读，有条理的介绍了 YYModel 的结构，相信会让各位对 YYModel 的代码结构有一个清晰的认识。</li>
<li>深入剖析了 YYClassInfo 的 4 个类，并详细讲解了它们与 Runtime 层级结构体的对应。</li>
<li>在剖析 YYClassInfo 章节中分享了一些我在阅读源码的过程中发现的并且觉得值得分享的处理细节，比如为什么作者选择用 <code>strong</code> 来修饰 NSString 等。顺便还对 SEL 与 <code>char *</code> 的关系做了实验得出了我的推论。</li>
<li>把 YYClassInfo 的初始化以及更新细节单独拎出来做了分析。</li>
<li>探究 NSObject+YYModel 源码（分享了一些实现细节）并对其实现代码做了划分，希望能够对读者阅读 YYModel 源码时提供一些小小的帮助。</li>
</ul>
<p>嘛~ 上篇差不多就这样了。我写的上一篇 YYKit 源码系列文章<a href="https://lision.me/yycache/">【从 YYCache 源码 Get 到如何设计一个优秀的缓存】</a>收到了不少的好评和支持（掘金里一位读者 <a target="_blank" rel="noopener" href="https://juejin.im/user/5912c8b2da2f600053723275">@ios123456</a> 的评论更是暖化了我），这些美好的东西让我更加坚定了继续用心创作文章的决心。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a><a class="tag-none-link" href="/tags/yymodel/" rel="tag">yymodel</a>
	  </div>
    

  </section>
</article>
  
</section>


  <nav id="page-nav">
    
    <a class="prev" rel="prev" href="/page/18/">
      <span class="icon icon-chevron-left"></span>
      <span class="text">Previous</span>
    </a>
    
    
    <a class="next" rel="next" href="/page/20/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  

      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
