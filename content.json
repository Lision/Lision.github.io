{"pages":[],"posts":[{"title":"理解 Hood","comments":true,"permalink":"https://lision.me/hood/","text":"Hood 官方中文指引：理解 hood这篇文章是在我利用个人时间做的 App —— Hood 初版快要完成时写的，旨在让 Hood 的用户可以通过阅读本文提升对 Hood 产品逻辑的理解从而更加科学合理的使用 Hood。 索引 Hood 是什么? 核心概念 设计理念 无可奈何 未来计划 Hood 是什么？Hood 是我利用业余时间做的一款 App。 你可以把 Hood 当作一个隐私工具，在他人借用设备时禁用掉私密 App；你可以把 Hood 当作一个效率工具，在工作或者集中注意力时隐藏分散你注意力的 App；你可以把 Hood 当作一个家长管理工具，必要时将那些使用时长过多对孩子健康造成影响的 App 限制起来。 总之，基于屏幕使用时间管理的核心功能可以派生出好多有趣的用法，因此 Hood 未来的迭代方向也有很多。 核心概念 授权，Hood 的主要能力是屏幕时间管理，这项能力来自于 ScreenTime API，所以在没有得到授权时 Hood 几乎没有任何用，这也是 Hood 在用户未授权 ScreenTime 时向用户申请权限的原因。 隐私，ScreenTime API 的设计非常注重隐私安全，Hood 不会知道你安装了哪些 Apps，以及什么 Apps 是你想要限制使用的。其实 Hood 的使用并不需要网络授权，目前请求网络权限也仅仅是为了同步 AppStore 的信息。 限制，Hood 只会对没有 ScreenTime API 授权的 App 生效，这意味着 Hood 不可以隐藏自己，所以不是很有趣。这也意味着如果你想取消 Hood 的控制，只需要收回 Hood 拿到的 ScreenTime 授权或者干脆卸载 Hood，那些被 Hood 限制的 Apps 就会一切如初。 设计理念 应用分组，管理单个应用比较麻烦，所以 Hood 加入了分组的概念，以卡片形式展示。 身份认证，看到 Hood 内容的人应该是设备的主人，当前 Hood 只做了生物识别认证，也就是 Face ID 或 Touch ID。 限制卸载，如果 Hood 不再那么小众，那么可能拿到你设备的人即使不进行身份认证依然可以通过卸载 Hood 的方式看到那些你不愿意让 TA 看到的 Apps，所以 Hood 做了这个功能；相应的还有「限制安装应用」和「限制应用内购买」功能，笔者认为这三个功能对于监护人更好的约束被监护人这个场景很有用，可以防止孩子安装新的手游或私下购买游戏道具/打赏女主播。 无可奈何 图标乱序，被 ScreenTime API 禁用的 Apps 在还原时会按照某种规则重新出现到设备桌面，就好像它们被禁用时真的被卸载然后出现时又重新从 AppStore 安装一样，遗憾的是这暂时无解。不过可以通过在第二屏预留相应空位或者参照 Hood 内切换隐藏模式时的提示绕过去。当然，你也可以试试通过 Hood 的锁定模式来禁用 App。 界面简陋，呃… 因为目前还没找到合作的设计师，所以整个 App 的交互和界面设计都是我自己做的，确实有点偏性冷淡的素。其实仔细体会的话你也许可以发现所有的交互路径都是尽可能短的，目的自然是为了更高效。AppIcon 的 H 不只是 Hood 的首字母，也是一个栅栏的形象，意味着约束和控制；主题色是绿色和蓝色的混色，表示健康/距离感与可靠。 未来计划正如文章开头说的那样，基于屏幕使用时间管理的核心功能可以派生出好多有趣的用法，因此 Hood 未来的迭代方向也有很多。老实说，我目前对于 Hood 的规划更倾向于效率类工具，所以后续大概率会往这个方向做迭代。"},{"title":"Understanding Hood","comments":true,"permalink":"https://lision.me/hood-en/","text":"The article was translated from Chinese by ChatGPT. Hood Official English Guide: Understanding HoodThis article was written when I was about to complete the first version of my app, Hood, in my spare time. The purpose is to help users of Hood better understand the product logic through reading this article and use it more scientifically and reasonably. Index What is Hood? Core Concepts Design Philosophy Helplessness Future Plans What is Hood?Hood is an app that I made in my spare time. You can think of Hood as a privacy tool to protect private apps when others borrow your phone; you can think of it as an efficiency tool to block distracting apps while working or focusing attention; you can think of it as a parental management tool to block Apps that have been used too much and may affect children’s health if necessary. In short, based on the core function of Screen Time Management, many interesting uses can be derived from them. Therefore, there are many future directions for iteration on Hood. Core Concepts Authorization: The main ability of Hood is Screen Time Management. This ability comes from the ScreenTime API. Therefore, without authorization, Hood is almost useless. This is also why Hood applies for permission to users who have not authorized ScreenTime. Privacy: The design of the ScreenTime API pays great attention to privacy and security. Hood does not know which Apps you have installed or what Apps you want to manage. In fact, using Hood does not require network authorization at present, and requesting network permissions only synchronizes AppStore information. Limitation: Hood only works on Apps that do not have ScreenTime API authorization. This means that Hood cannot hide itself, so it is not very interesting. It also means that if you want to cancel the control of Hood, just revoke the ScreenTime authorization obtained by Hood or simply uninstall it, and those Apps controlled by hidden will return to their original state. Design Philosophy Application grouping: Managing individual applications can be cumbersome, so Hood introduces the concept of grouping in card form display. Identity authentication: People who see content in Hidde should be device owners. Hood only did biometric authentication - Face ID or Touch ID. Uninstall limitation: If Hood is no longer so niche, people who get your device may still be able to see the Apps you don’t want them to see by uninstalling Hood even if they do not authenticate. Therefore, Hood has this function; corresponding functions also include “Limit installation of applications” and “Limit in-app purchases”, which I think are very useful for guardianship scenarios where parents need to restrict their children from installing new mobile games or buying game props/rewarding anchors. Helplessness Icon disorder: When blocking apps restore, they will be rearranged on the device desktop according to some rules, as if they were really uninstalled when blocked and then reinstalled from the App Store when they appear again. There is currently no solution for this problem, but you can bypass it by reserving corresponding space on the second screen or referring to the prompt when switching to block mode in Hidde. Of course, you can also try disabling apps through Hood’s lock mode. Locking won’t cause disorder and is suitable for non-essential blocking scenarios such as self-discipline. Simple interface: Um… because I haven’t found a cooperating designer yet, so I did all of Hood’s interaction and interface design myself. It does have a bit of bias towards minimalism. If you carefully experience it, you may find that all interaction paths are as short as possible for higher efficiency. The interface elements are mostly simple graphics that directly map to code logic. To say more, actually “H” in AppIcon not only stands for “Hood”, but also represents a fence image which means constraint and control; The theme color is a mixture of green and blue representing health/distance sense and reliability. Future plansAs mentioned at the beginning of this article, many interesting uses can be derived from Hood’s core function of Screen Time Management; therefore there are many directions for future iterations of Hood. Honestly speaking, my current plan for Hood leans more towards efficient tools; therefore subsequent iterations will probably move in this direction."},{"title":"Hood 隐私政策","comments":true,"permalink":"https://lision.me/hood-privacy-policy/","text":"隐私政策 Hood 中选择的应用程序以不透明令牌的形式由 iOS 屏幕时间提供。Hood 永远不会知道您选择了哪些应用程序。 Hood 不收集任何数据，包括您选择了哪些应用程序、位置信息或使用信息。 Hood 请求网络授权仅用于应用内购买服务。 Hood 不使用任何第三方 SDK 或服务。 最后更新于 2023 年 06 月 20 日"},{"title":"Hood Privacy Policy","comments":true,"permalink":"https://lision.me/hood-privacy-policy-en/","text":"Privacy Policy The applications selected in Hood are provided by iOS Screen Time in the form of opaque tokens. Hood will never know which applications you have chosen. Hood does not collect any data, including which applications you have selected, location information or usage information. Hood requests network authorization only for In-App Purchase services. Hood does not use any third-party SDKs or services. Last updated on June 20, 2023"},{"title":"聊聊我对知识付费的理解","comments":true,"permalink":"https://lision.me/talk-about-pay-for-knowledge/","text":"写在前面Emmmmm…上一篇文章结尾聊到自己要尝试开始去《小专栏》写文章的事儿，本来是准备简单写几句一笔带过的，不过在我写完《Flutter 状态管理》系列第二篇文章之后仔细想了想还是应该抽出来聊聊自己对于知识付费的看法。 索引 知识付费 时间成本 正向激励 商业化 知识付费 知识付费，知识付费主要指知识的接收者为所阅览知识付出资金的现象。知识付费让知识的获得者间接为向知识的传播者与筛选者给予报酬，而不是让参与知识传播链条的人通过流量或广告等其它方式获得收益。 请原谅我这里引用了百度百科，因为我其实觉得百度百科对于知识付费的描述很对我的胃口，作为技术从业者我知道很多人比较鄙视百度生态，但是我觉得还是不能为了鄙视而鄙视，也不是说鄙视了百度用了谷歌就能说明自己高人一等，你说对吧？ 时间成本百科里对我胃口的主要是「时间成本」小节的描述： 选择太多，用户决策瘫痪，自己选择的时间成本增加，愿意通过付费来代替个人搜寻选择，这使知识付费成为可能。 这句话从技术从业者的角度来讲也是适用的，我相信也期望所有知识付费的付费者都具备一定的内容识别能力，即自己可以辨别文章/音频/视频等媒介传播的内容质量。 正向激励随着互联网越来越发达，各种碎片化的教程类文章/音频/视频越来越多，辨别这些媒介内容质量并过滤出对自己有用的内容这件事儿的时间成本越来越大了… 遗憾的是，之前自己在学习过程中好不容易收集和订阅的各种牛人的博客更新频率越来越低了，甚至有些以及停更了。一种可能是这些自己喜欢的人他们真的越来越忙所以没有时间来写文章分享了，另外一种可能就是缺乏正向激励。 做技术手艺人在中国特色国情下其实还是蛮焦虑的，即便是做到了专家 Title 带了团队之后这种焦虑也会存在，甚至随着年龄的提升而逐渐增大。这种情况下有些聪明人踩对了时代的节奏，做独立开发，少数人坚持并成功了，相当于有了自己的事业；另外一部分人也渴望有自己的事业，但是这毕竟不可强求，所以只有两种选择： 深度优先，持续深入自己的工作领域，深耕并保持分享输出，保持业界影响力在业界扎根 广度优先，做其他副业，甚至群里有朋友转 PM 很多真正喜欢编程的人都更倾向于第一种选择，但是一直用心写的技术文章被各种无良网站和公众号剽窃走甚至被「套娃」，还是挺让人伤心和打击人积极性的。因此很多技术大佬们纷纷转投知识付费领域，将自己用心写的内容付费传播，其中不乏一些 Level 很高的大厂专家 Title 的牛人。其实这些人的薪资并不低，从专栏定价和付费用户数量来看算一算也不一定有一个月工资的收益，我理解更多的是借助知识付费对自己产生正向激励让自己保持分享输出。 商业化涉及付费就有利益，有利益的地方就有商机，所以知识付费经历数年之后慢慢有了成熟的体系。 商业化的加入喜忧参半： 好处是有专业的商业团队帮助真正想要在自己领域深耕并扎根的技术手艺人做推广，让更多优秀的内容和创作者被人知晓 坏处是商业团队缺乏内容把控，内容质量出现下降，不少付费用户表示被当成了「技术韭菜」，被收了智商税，非常伤心 我觉得目前国内做的比较好的平台就是「极客时间」了，其他的平台也有比较小众做的不错的比如「小专栏」。不过平台不重要，内容这块我觉得更多的是看准内容创作者本身，高质量内容的创作者无论是在哪个平台都会对自己严格要求的，这种人也会比较有口碑并看中自己的口碑，久而久之就树立起了个人品牌，非常不容易。 总结Emmmmm…貌似也没什么好总结的，如你所见这是一篇吹水文。 如果你想系统全面的学习一些经典基础知识，我建议直接买书，比如想学操作系统推荐买《深入理解计算机系统》，这种口碑爆表且经典的教材类书籍是我这边的不二推荐；如果你想快速系统的掌握一些新进技术，我建议可以尝试从知识付费领域下手。"},{"title":"Flutter 状态管理 0x00 - 基础知识及 State.setState 背后逻辑","comments":true,"permalink":"https://lision.me/flutter-state-management_0x00/","text":"前言 Emmmmm…正式开始文章前先交代个事儿，2019 开年计划那篇文章被我删了。原因没啥特别的，就真的只是脸疼… 嘛～ 好久没更 Blog 了，最近笔者正在学习 Flutter 相关的知识（貌似现在学也不算特别晚），所以后续可能会有一波连续的 Flutter 相关的更新（关键字已加粗 😂）。 因为之前我的文章大多是源码剖析相关的，所以这次决定换种方式先从 Flutter 开发的状态管理聊起。由于个人能力不足、水平有限，文章中难免有纰漏和谬误，加上工作确实比较忙可能没有时间校验，希望发现的朋友能够在文章下方评论交流讨论（主要是避免误人子弟，不过评论应该需要科学上网）。 本文会简单介绍 Flutter 以及声明式编程思想和代码画风，对比 StatelessWidget &amp; StatefulWidget 这两个重要的 Widget，再聊聊 setState 背后的那些事儿。 索引 Flutter 简介 声明式 UI &amp; 响应式编程 Flutter 如何渲染 Widget StatelessWidget &amp; StatefulWidget State.setState 背后的那些事儿 Flutter 简介 Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。 「Write once, run anywhere.」始终是大前端开发乃至整个程序界的一个永恒的话题。诚然 Flutter 的目标也是如此，不过它与之前业界已经存在的 React Native、Xamarin、Hybrid 等框架有何不同？ 从上图可以看到 Flutter 的设计整体上有三层抽象： 最上层 Framework 封装好了 Material 和 Cupertino 这两种分别对应 Android 和 iOS 官方设计风格的 UI 库，除此之外还包含了渲染、动画、绘制、手势等等，这一层主要是提供给开发者便捷构建 App 使用的，其在开发时为 JIT、发布时为 AOT 的特性兼顾了开发调试的便捷与线上运行的高性能； Engine 作为中间层，使用 C/C++ 实现了一套高性能、可移植的 Runtime，屏蔽了平台间差异的同时支撑了上层的 Flutter 应用。 Embedder 由平台指定语言实现，提供了 Flutter 所需的事件循环、线程、渲染等基础 API。 Flutter 通过这套机制接管了最底层的系统接口，提供了一整套从底层渲染逻辑到上层开发语言的完整解决方案，使得它有着超越 React Native 的高保真、多端一致的体验，和超越 Web 容器的高性能渲染能力。 声明式 UI &amp; 响应式编程声明式 UI 这张图很好的描述了声明式 UI 的核心思想，简单来说就是通过 state 作为入参根据已经写好的构建 func 就能得到我们想要的 UI 效果。举个 🌰 更直观： 默认的 Flutter Demo 界面： 对应的代码： 12345678910111213141516171819202122232425return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( &#x27;You have pushed the button this many times:&#x27;, ), Text( &#x27;$_counter&#x27;, style: Theme.of(context).textTheme.display1, ), ], ), ), floatingActionButton: FloatingActionButton( // _incrementCounter 内部逻辑可忽略 onPressed: _incrementCounter, tooltip: &#x27;Increment&#x27;, child: Icon(Icons.add), ),); In flutter, everything is a widget. Emmmmm…可以注意到上面的代码中 children: &lt;Widget&gt;[...] 一行，Flutter 开发中就是通过这种方式嵌套组合 Widget 来描述用户界面的。从这一角度讲，Widget 是对一部分用户界面的不可变描述。 默认的 Flutter Demo 跑起来很简单，推荐大家亲身体验。简单说一下我的感受，声明式 UI 的优势很大，具体表现为只需要在写 UI 时将不同 state 对应的 UI 展示考虑并描述清楚就可以省去后续 state 变更时命令式 UI 需要手动管理视图层级（新增或删除视图元素）和更新属性（颜色、字号等）等麻烦。 值得一提的是 SwiftUI 也使用了声明式 UI 的思想（声明式 UI 才是未来）。 响应式编程 响应式编程 ，在计算机领域，响应式编程是一个专注于数据流和变化传递的异步编程范式。这意味着可以使用编程语言很容易地表示静态（例如数组）或动态（例如事件发射器）数据流，并且在关联的执行模型中，存在着可推断的依赖关系，这个关系的存在有利于自动传播与数据流有关的更改。 响应式编程对于大家来说应该早已不是什么新鲜事物了，单在移动客户端领域就有诸如 ReactiveCocoa、RxSwift、RxJava、RxXxx…简单来说这种编程思想或者说范式下开发者只需关注可能存在的数据状态以及与之对应的逻辑从而大大减轻了维护这些对应关系与状态细节的工作负担。因为用过的人都说好，所以目前渐渐被推为移动客户端乃至整个大前端的主流编程思想。 不难看出其实声明式 UI 和响应式编程从思想上是完全契合的，我们只需要将数据流对应到 UI=f(state) 公式中的 state 就可以了。 Flutter 如何渲染 Widget 在介绍 StatelessWidget 与 StatefulWidget 之前先要了解一下 Flutter 的渲染模型，简单来讲 Flutter 在渲染 Widget 时用到三棵树： Widget，负责描述 Element 的配置。 Element，负责管理 Widget 和 RenderObject 的生命周期。 RenderObject，负责控制尺寸，布局和绘制工作。 一言以蔽之，Element 会根据我们书写的 Widget 对其的配置描述来生成并管理对应的 Element 与 RenderObject，由 RenderObject 负责最终的绘制工作。 NOTE: Element 会根据 Widget 的描述最大程度复用现有 Element 与 RenderObject 以提升性能。 StatelessWidget &amp; StatefulWidgetStatelessWidget StatelessWidget, A widget that does not require mutable state. StatelessWidget 如其名 Stateless，它不需要追踪 State 并根据 State 更新 UI，所以一般 StatelessWidget 内部的属性用 final 修饰声明且构造方法一般以 const 修饰。 NOTE: const 修饰的 Widget 构造方法使用时可以提效。 StatefulWidget StatefulWidget, A widget that has mutable state. StatefulWidget 与 StatelessWidget 一样，也可以通过一系列（组合嵌套）其他更具体描述 UI 的 Widget（比如 Text）来构建部分用户界面。区别在于 Stateful，即它需要追踪 State 并根据 State 更新 UI。 区别StatelessWidget 与 StatefulWidget 大概是我们用 Flutter 技术栈开发 App 时最常打交道的两个 Widget 了。 共同点： 这两个 Widget 都可以用来通过对其他一系列 Widget 构建完成一部分用户界面的封装。 不同点： StatelessWidget 更适用于一些不需通过用户交互或其他原因通过 State 控制更新的 UI 封装。 StatefulWidget 更适用于追踪某个会根据用户交互或其他因素影响的 State，并根据最新的 State 实时更新的 UI 封装。 此外，Flutter 对于 StateLessWidget 与 StatefulWidget 的绘制也有差异： StatelessWidget 通过 StatelessElement.build 触发 build StatefulWidget 通过 StatefulElement.build 触发 State.build State.setState 背后的那些事儿 NOTE: 下面分析的 State.setState 源码版本为 Flutter SDK v1.9.1+hotfix.6。 我们还以 Flutter 默认 Demo 来分析，在 Demo 中我们点击界面右下角的 FloatingActionButton (就是蓝色带有 + 号的圆形按钮)之后会刷新界面，屏幕中间的 Text Widget 会显示按钮被按下的次数。 FloatingActionButton 点击之后调用了 _incrementCounter 方法： 12345678910class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; ...&#125; _MyHomePageState._incrementCounter 内部逻辑也仅仅是调用了 State.setState 而已。正如 Flutter 所宣传的公式 UI = f(state) 一样，开发者只需要调用 State.setState 传入 VoidCallback 内部写好相关数据更新逻辑即可更新 UI，那么 Flutter 是如何做到这一点的呢？ State.setState 背后逻辑 State.setState 背后调用嵌套较多，实际所做的事情理解起来却很简单。如不喜在文内阅读源码可直接跳转至「总结 State.setState 背后逻辑」小节看相关逻辑总结。 State.setState123456789101112@optionalTypeArgsabstract class State&lt;T extends StatefulWidget&gt; extends Diagnosticable &#123; ... @protected void setState(VoidCallback fn) &#123; // assert ... final dynamic result = fn() as dynamic; // assert ... _element.markNeedsBuild(); &#125; ...&#125; 可见 State.setState 内除去断言的逻辑只有两行代码： 执行入参 VoidCallback 逻辑，Demo 中对应 _counter++; 执行 _element.markNeedsBuild(); Element.markNeedsBuild1234567891011121314abstract class Element extends DiagnosticableTree implements BuildContext &#123; ... void markNeedsBuild() &#123; // assert ... if (!_active) return; // assert ... if (dirty) return; _dirty = true; owner.scheduleBuildFor(this); &#125; ...&#125; Element.markNeedsBuild 内部的逻辑也很简单明了： 如此 Element 不再活跃则直接 return 无需做任何事 如此 Element 已经被标记为 dirty 也无需重复标记直接 return 以上条件不满足时说明此 Element 是活跃且需要重新构建的，所以标记为 dirty 后调用 owner.scheduleBuildFor(this); BuildOwner.scheduleBuildFor1234567891011121314class BuildOwner &#123; ... void scheduleBuildFor(Element element) &#123; // assert ... if (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != null) &#123; _scheduledFlushDirtyElements = true; onBuildScheduled(); &#125; _dirtyElements.add(element); element._inDirtyList = true; // assert ... &#125; ...&#125; BuildOwner.scheduleBuildFor(this); 内部逻辑也不复杂： !_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != null 可以理解为如果还没有安排过刷新此 BuildOwner 下被标记为 Dirty 的 Elements 且安排构建的逻辑不为空，满足以上条件则将此 BuildOwner 安排刷新 Dirty Elements 的标记置为 true 将传入的 Element 加入此 BuildOwner 管理的 _dirtyElements 并将此 Element _inDirtyList 标记为 true BuildOwner.onBuildScheduled其实 onBuildScheduled(); 跟下去是 BuildOwner 内部属性 onBuildScheduled，类型为 VoidCallback，在 WidgetsBinding.initInstances 时被赋值为 WidgetsBinding._handleBuildScheduled: 12345678910mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123; ... @override void initInstances() &#123; ... buildOwner.onBuildScheduled = _handleBuildScheduled; ... &#125; ...&#125; WidgetsBinding 可以理解为 Widget 层与 Flutter engine 之间的胶水层，篇幅原因不展开讲，我们直接看 WidgetsBinding._handleBuildScheduled。 12345678mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123; ... void _handleBuildScheduled() &#123; // assert ... ensureVisualUpdate(); &#125; ...&#125; SchedulerBinding.ensureVisualUpdate12345678910111213141516mixin SchedulerBinding on BindingBase, ServicesBinding &#123; ... void ensureVisualUpdate() &#123; switch (schedulerPhase) &#123; case SchedulerPhase.idle: case SchedulerPhase.postFrameCallbacks: scheduleFrame(); return; case SchedulerPhase.transientCallbacks: case SchedulerPhase.midFrameMicrotasks: case SchedulerPhase.persistentCallbacks: return; &#125; &#125; ...&#125; 这里通过当前 SchedulerPhase 的状态进行取舍，仅在 SchedulerPhase.idle &amp; SchedulerPhase.postFrameCallbacks 时调用 scheduleFrame();。 SchedulerPhase.scheduleFrame1234567891011mixin SchedulerBinding on BindingBase, ServicesBinding &#123; ... void scheduleFrame() &#123; if (_hasScheduledFrame || !_framesEnabled) return; // assert ... window.scheduleFrame(); _hasScheduledFrame = true; &#125; ...&#125; 这里的逻辑更简单： _hasScheduledFrame || !_framesEnabled 可理解为如果已经安排过 Frame 或当前 Frame 不可用，这种情况直接 return 不满足上述情况则调用 window.scheduleFrame(); 然后标记 _hasScheduledFrame 为 true Window.scheduleFrame1void scheduleFrame() native &#x27;Window_scheduleFrame&#x27;; 这里的 Window.scheduleFrame 是 Native 方法，可以理解为通过 Window 与 Flutter engine 打交道，注册了 VSync 回调。 总结 State.setState 背后逻辑 简单来说 State.setState 就干了这么几件事： 执行入参 VoidCallback 逻辑，即执行开发者写好的信息变更逻辑 尝试将当前 StatefulWidget 对应的 StatefulElement 标记为 dirty 通过 BuildOwner.onBuildScheduled 到 SchedulerPhase.scheduleFrame 再到 Window.scheduleFrame 一步步完成了 VSync 的回调注册 注意上面 State.setState 第二条主要逻辑就是把 State 关联的 Element 标记为 dirty。在 VSync 回调后会通过 Native 到 Flutter engine 调用 Flutter _drawFrame 方法，将之前标记为 dirty 的 Element 重新构建，最终会执行到开发者熟悉的 State.build 方法。 State.build 是如何被执行的这里因为篇幅原因简单描述下后续逻辑，毕竟本文重点不在于 Flutter 如何渲染 Widget： State 是开发者重写 StatefulWidget.createState 返回的 State 对应的 Element 是 StatefulWidget.createElement 返回的，类型为 StatefulElement StatefulElement 被标记为 dirty 后在 Flutter _drawFrame 时重新构建会调用 StatefulElement.build，其源码为 Widget build() =&gt; state.build(this); state.build(this) 中的 state 就是我们的 State，开发者写的 State.build 方法就这样被执行了 总结本文是 Flutter 状态管理的开篇，为了照顾一些还没来得及学习 Flutter 或者刚入门 Flutter 的初心者所以文章从前到后做了一些铺垫介绍过渡。文章内容也比较浅显易懂，基本上是围绕 Flutter 创建 App 默认的 Demo 来展开讲解一些基本的 Flutter 知识点： Flutter 渲染 Widget 的三颗树概念 StatelessWidget &amp; StatefulWidget State.setState 背后逻辑 由于状态管理这个话题非常大且复杂，文章因为篇幅原因就到这里，后续的文章（如果有的话）应该不会再花大篇幅做 Flutter 基础知识的铺垫和过渡了（但是该有的前置知识点肯定还会有）。时间紧张，文章难免出现谬误，估计自己也没有时间做校对了，有问题还望在评论区提醒。 扩展补充写到这里我意识到 Flutter 状态管理这个话题下可以引出很多值得挖掘的内容，而且笔者坚信声明式 UI + 响应式编程会是未来移动客户端乃至整个大前端的主流编程范式。鉴于此，后续的文章计划围绕 Flutter 状态管理逐步深挖，内容也将在 Flutter 技术栈的基础上做适度横向对比。 Emmmmm…后续的文章将会发布在我的《Flutter 状态管理》小专栏。至于专栏定价嘛，目前随便定了 ¥69（作为小透明的我瑟瑟发抖 ing~）。其实倒也不是很在意能卖出多少份，或者从中收到多少钱，毕竟自己写文章的精力拿去随便接个朋友的私活都应该比这次通过小专栏赚到的多。比起收入更多的是对自己的鞭策吧，毕竟是收费的东西，只要有一个人订阅了这个专栏就意味着对我的肯定，我就有责任把这个方向挖掘的更深入，同时文章质量也应该比博客内容更高。 其实早在去年就有幸被小专栏的开发者@安卓大王子邀请去小专栏写文章，不过当时自己感觉没什么好的内容方向所以只是开通了专栏但没有任何输出。时至今日终于找到了一个值得深挖的方向，自然而然想到了这个平台。个人感觉小专栏这个平台没有太重的商业化味道，这点很讨喜，在微信上面的阅读体验也比自己发公众号要好一些，更难能可贵的是省去了发公众号的繁琐操作流程。可能正是商业化氛围弱的原因，上面的文章质量还都挺不错的，推荐各位读者朋友可以上去试读或者写作。"},{"title":"写在 2018 年的最后一天","comments":true,"permalink":"https://lision.me/summary_for_2018/","text":"前言打眼一瞧，上一篇文章还是十一长假的时候由于旅行计划破灭后闲着无聊破解 Bartender 时写的，这一转眼的功夫就到了元旦假期了… Emmmmm… 本来已经放弃要写年末总结的~ 众所周知，写年末总结约等于自抽嘴巴。末了还要对应着列出新一年的计划，为明年年末相同的环节埋下伏笔。一般来说，年初的计划写的越是具体、生动、形象，年末的嘴巴抽的就越是啪！啪！！啪！！！ 让我惊喜的是，我的年初计划之前没有记到博客里，翻了一下仅有的一篇相关内容的文章《嘛~ 又一年了啊…》，里面并没有什么具体的自定 KPI~ 原来我是这么的深谋远虑，早就想好了这一天的到来 😂 索引 工作篇 技术篇 生活篇 总结 工作篇嘛~ 这一年在工作中的整体表现算是达到了自己的预期，里程碑如下： 年初接到了美团外卖团队的 Offer 并成功入职 参加美团·点评技术通道秋季晋级答辩并成功晋升 年初的 Offer 抉择没让自己后悔，这一年外卖商家侧的业务发展很迅猛，随之而言工作中面临的挑战也很多，工作内容充实。我的老板对组员和其自身都有着很高的要求，有一个优秀的 Leader 是一件很幸运的事，因为他（她）会直接决定你所处团队的方方面面。 技术篇这一年在技术方面值得记录的事： 年初在 GitHub 开源了两个轮子，一年维护下来虽然累，但从中收获不少 加入了 @SwiftGG 翻译组 并参与了一些优质文章的校对工作 阅读了一些公司内部自己感兴趣的源码 关于开源 Emmmmm… 年初的时候写了两个开源项目： LSAnimator - An easy to read and write, non-invasive multi-chain animation framework, inspired by JHChainableAnimations. WKWebViewJavascriptBridge - A Bridge for Sending Messages between Swift and JavaScript in WKWebViews. 早在开坑时就做好了填坑的觉悟，得益于推广之前有写覆盖较为全面的单测用例并配置了 Travis-CI，这一年来两个开源项目并未对使用者造成任何负面影响，用户提的 Issue 也都有抽出时间解答 &amp; 处理。 阅读 &amp; 实践 「纸上得来终觉浅，绝知此事要躬行。」 对于这句话的理解越发深刻了，自己之前在书本上学到过的知识好多都没有动手实践过，今年在学习时多次有茅塞顿开的感觉。经过复盘，这种感觉产生的根本原因是自己之前阅读技术书籍时没有完全弄明白，类似于在脑中记录了一个符号，在后期阅读源码 &amp; 解决问题时找到了该符号的对应实现体（笑）。 生活篇 工作之余我的时间主要花费在电子游戏上面 😂 今年又败了一些游戏： 《马里奥赛车 8 豪华版》 《龙珠斗士 z》 《精灵宝可梦 Let’s go 皮卡丘》 《任天堂全明星大乱斗 sp》 《Dead Cell》 《传说法师》 《空洞骑士》 Ps: 为了玩大乱斗还入手了 Switch Pro 手柄，不过 Pro 手柄的操控感真的是非常让我惊喜，想不到任天堂这种品控也能有这种精品外设产出（手动滑稽）。 遗憾的是，自己貌似并没有太多时间去享受这些游戏，最为典型的应该是 2016 年入手的《黑暗之魂 III》，到现在还都是未开封状态 o(╯□╰)o … 感觉一过了 25 周岁之后身体机能大不如前了，最明显的区别就是现在下班回家之后开机器的意愿非常弱，周末几乎不会有通宵肝游戏的想法出现。 总结Emmmmm… 感觉这一年来最大的变化是写文章的意愿越来越弱了，其实计划中是有很多东西想转为文字沉淀在自己的博客里的，奈何要做的事情太多，时间却又太少。有些东西当时梳理成了笔记（方便自己回顾），随着时间的推移也就不想再写成文章发出来了… 通过复盘也发现自己对于生活的态度过于随意，导致年末复盘几乎没什么可写的东西，准备在明年的年度计划中明确生活相关的各项指标，现在想到的有理财，健身，观影，游戏…"},{"title":"逆向 Mac 应用 Bartender","comments":true,"permalink":"https://lision.me/mac_re_bartender/","text":"前言 本文内容仅作为学习交流，希望大家多多支持正版软件。 Emmmmm… 其实最初是准备写一篇关于 iOS 应用的逆向笔记的，不过一直没找到合适的目标 App 以及难度适宜的功能点来作为写作素材… 破解了 Bartender 之后我觉得对于 Bartender 的破解过程难度适中，非常适合当做素材来写，且不论是 Mac App 还是 iOS App，逆向的思路都是相通的，所以就写了这篇文章~ 国庆之前，果果放出了最新操作系统 macOS Mojave 的正式版本，相信很多小伙伴都跟我一样在正式版发布后紧跟着就升级了系统（此前由于工作设备参与项目产出需要确保系统稳定性所以没敢尝鲜的同学应该不只我一个人哈）。 升级到正式版 macOS Mojave 之后，我兴致勃勃的在新系统中各处探索了一番，然后将系统切换到 Dark Mode 后打开 Xcode 心满意足地敲（搬）起了代码（砖）… 嘛~ 又是一个惬意的午后，有时候人就是这么容易满足（笑）~ 等等！这是什么鬼！？我的 Bartender 怎么不能正常工作了（其实现在回想起来应该是试用期到期了）… 本文将以 Bartender 为目标 App，讲解如何通过静态分析工具 Hopper 逐步分析 Bartender 的内部实现逻辑并结合动态分析等手段逐步破解 Bartender 的过程与思路~ 索引 Bartender Hopper 逆向过程 &amp; 思路 总结 Bartender Bartender 是一款可以帮助我们整理屏幕顶部菜单栏图标的工具。 随着我们安装的 App 不断增多，屏幕顶部菜单栏上面的图标也会对应不断增加。这些 App 的图标并非出自一家之手，风格各异，随着数目增多逐渐显得杂乱不堪。 我们可以通过 Bartender 来隐藏或重新排列这些恼人的小图标，可以将没什么用但是运行起来却要显示的 App 图标始终隐藏，将偶尔会用的 App 图标隐藏到 Bartender 功能按钮后面（用到的时候可以通过点击 Bartender 功能按钮切换显隐），只显示常用的或者我们认为好看的应用图标。 除此之外 Bartender 还具备一些其他更加深入的功能（比如支持全部菜单栏条目范围的搜索等等），毫无疑问它是一款非常棒的菜单栏图标管理工具。 Note: 重申，Bartender 仅售 15 刀，还是推荐各位使用正版，本文仅作为学习交流。 Hopper Hopper 是一款不错的 mac OS 与 Linux 反汇编工具，同时还提供一定的反编译能力，可以利用它来调试我们的程序。此外，Hopper 还支持控制流视图模式，Python 脚本，LLDB &amp; GDB，并且提供了 Hopper SDK 可供扩展，在 Hopper SDK 的基础上你甚至可以扩展自己的文件格式和 CPU 支持。 值得一提的是 Hopper 的作者是一名独立开发者，他的日常工作环境也是在 mac OS 上，所以在 mac OS 上的 Hopper 是完全使用 Cocoa Framework 实现的，而 Linux 版本的 Hopper 则选择使用 Qt 5 来实现。 个人认为 Hopper 在 mac OS 上面的运行表现非常好，很多细节（比如类型颜色区分等）都做的不错，功能简洁的同时快捷键也很好记（Hopper 提供的功能已经覆盖了绝大多数使用场景）。 最关键的一点是收费良心，个人证书只要 99 刀，当之无愧的人人都买得起的逆向工具！当然如果你觉得贵，Hopper 还提供试用，试用形式类似于 Charles，每次开启后可以试用 30 分钟，一般情况下这已经够用了。 Note: Hopper v4.4.0 支持 Mojave Dark Mode。 逆向过程 &amp; 思路这一章节的内容会详细的讲述我个人在破解 Bartender 过程中的想法以及中间遇到问题时解决问题的思路，之前没有涉足逆向或者逆向经验尚浅的同学可能会觉得比较晦涩，这种情况最好结合自己的实际操作反复阅读没有理解的地方直到真正弄明白为止。 相信自己，每一份努力终会有所回报！当有朝一日自己也可以通过自己的逆向技术破解 &amp; 定制化自己感兴趣的 App 时，你会发现一切的努力都是值得的。 获取目标二进制从 Bartender 官网下载最新的 Bartender，截止本文提笔之前 Bartender 的最新版本为 3.0.47。 将下载好的压缩包解压之后得到 Bartender 3.app，将 Bartender 3.app 文件复制到自己的 Application 文件夹下。右键点击 Bartender 3.app 选择“显示包内容”，在 Contents 目录下找到 MacOS 目录，里面有我们要的目标二进制文件 Bartender 3。 从“授权”着手打开 Hopper，将目标二进制文件拖入 Hopper，在弹出的弹窗中选择 OK 后等待 Hopper 分析完毕。 在左侧的分栏中选择 Proc. ，这可以让我们查看 Hopper 分析出来的方法。分栏下面有搜索框，内部可以通过输入关键词来过滤出我们想要的结果。因为一般的 App 都是通过某些方法判断是否授权的，这里我们先输入 is （注意 is 前面加空格），然后观察过滤出来的结果。 果不其然，发现里面有三个 [xxx isLicensed] 方法，点击方法 Hopper 会跳转至方法处。 Note: 三处 [xxx isLicensed] 的方法内部逻辑几乎一样，这里拿 [Bartender_3.AppDelegate isLicensed] 讲解，其他两处不做赘述。 Emmmmm… 这里的汇编代码还是比较简单的，虽然我不是很了解 x86 的汇编指令，不过 Hopper 已经帮助我们做了一些辅助性工作。其中开始处的 push rbp 以及结束处 pop rbp 可以简单理解为入栈出栈，call sub_100067830 可以理解为调用地址 0x100067830 处的方法，pop 之前的 movsx eax, al 和 ARM64 中的 mov 指令类似，可以理解为将 al 内存储的东西移动到 eax 寄存器中，eax 寄存器用于存储 x86 的方法返回值。 我们可以看出这里调用了地址 0x100067830 处的函数，拿到结果之后又调用了 imp___stubs__$S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF 方法将结果做了转化，最后将结果赋值给 eax 寄存器用于结果返回。其中 imp___stubs__$S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF 我们可以根据名称推测出该方法的作用应该是将 Bool 转化为 Objective-C 的 BOOL 而已。 那么关键信息应该在 sub_100067830 处，双击 sub_100067830 Hopper 会跳转到 0x100067830 处，这样我们就可以分析其中的具体实现了。不过 0x100067830 内部的实现比较复杂，跳转过去之后发现汇编代码非常多，还有很多跳转… 这时候我们可以通过 Hopper 顶部中间靠右一点的分栏，点击显示为 if(b) f(x); 的按钮查看伪代码。 Hopper 解析出来的伪代码风格类似 Objective-C 代码，可以看到 0x100067830 内部通过 NSUserDefaults 以及其他的逻辑实现，其中还包括其他的形式为 sub_xxxxxx 的方法调用，这种情况下如果我们继续跳转到这些方法的地址查看其内部实现很有可能陷入递归中… 那么这种情况该如何处理呢？ 分析问题，我们找到 [xxx isLicensed] 并且觉得这有可能就是 Bartender 中判断授权与否的函数，那么我们只需要将三处 [xxx isLicensed] 的返回值改为 true 即可。所以这里我们没有必要一步步的看其内部实现，先返回 [Bartender_3.AppDelegate isLicensed] 处。前面讲过在 x86 汇编中 eax 寄存器用于存储方法的返回值，我们在 [Bartender_3.AppDelegate isLicensed] 按快捷键 option + A 插入汇编代码 mov eax, 0x1 将 eax 永远赋值为 1 即 true 之后跟 ret 即 return 指令直接让函数返回 true 就可以达到我们的目的了。 用快捷键 shift + command + E 导出二进制文件，覆盖到原 Bartender 目录中，尝试运行。你会发现一开始是成功的，屏幕顶部的菜单栏图标也被正常管理了，但是过了大约 10s 之后一切又变回了原样，并且还会弹出一个试用期到期的弹窗… 重拾思路那么我们刚才修改的三处 [xxx isLicensed] 为什么没有产生作用呢？其实它已经产生作用了，虽然我们不可以正常使用 Bartender，但是打开 Bartender 的 License 界面我们可以发现这里的界面已经显示我们付过款了，尽管这并没有什么卵用就是了… 到这里我们似乎没有什么头绪了，因为延时方法有很多，光是凭借这一条线索很难定位到阻止我们破解的目标代码位置。 逆向过程中的思路很重要，如果遇到思路断了的情况不要着急也不要气馁，我们可以重新运行程序，尝试不同的操作并观察操作对应的表现 &amp; 结果。 经过反复运行程序，我发现每次重新启动 Bartender 都可以有大约 10s 的可用时间，如果启动之后直接主动点击 Bartender 的功能按钮则会直接弹出试用期到期弹窗且顶部菜单栏图标也会直接回到之前杂乱的样子。 这时候我的思路从延时方法转移到了这个 Trial ended 弹窗以及 Bartender 的功能按钮点击之后的对应方法上。这就是动态分析，它可以帮助我们重新找回思路。 按钮响应方法有了思路，对应的方法并不难找。我们可以利用 Hopper 的 Tag Scope 先把可能出现的区域找出来，再到对应的区域下的方法列表中寻找我们的目标方法位置。 这里我很快就找到了目标函数 -[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:], 其内部调用了 sub_100029ac0(arg2); 其中 arg2 就是 sender，也就是这个 Bartender 的功能按钮了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148int sub_100029ac0(int arg0) &#123; sub_100022840(arg0); rbx = **_NSApp; if (rbx == 0x0) goto loc_100029f44;loc_100029ae7: [rbx retain]; r14 = [[rbx currentEvent] retain]; rdi = rbx; if (r14 == 0x0) goto loc_100029bef;loc_100029b18: [rdi release]; if (([r14 modifierFlags] &amp; 0x80000) != 0x0) goto loc_100029b6e;loc_100029b33: [r14 retain]; if ((([r14 modifierFlags] &amp; 0x40000) != 0x0) || ([r14 type] == 0x4)) goto loc_100029b66;loc_100029bcc: rbx = [r14 type]; [r14 release]; if (rbx == 0x3) goto loc_100029b6e;loc_100029bec: rdi = r14; goto loc_100029bef;loc_100029bef: [rdi release]; r14 = [[swift_getInitializedObjCClass(@class(NSUserDefaults)) standardUserDefaults] retain]; if (*qword_1000e7e70 != 0xffffffffffffffff) &#123; swift_once(qword_1000e7e70, sub_100069790); &#125; rbx = *qword_1000ee1f8; r15 = *qword_1000ee200; swift_bridgeObjectRetain(rbx); r15 = (extension in Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, r15); swift_bridgeObjectRelease(rbx); rbx = [[r14 objectForKey:r15] retain]; [r15 release]; [r14 release]; if (rbx != 0x0) &#123; swift_getObjectType(rbx); var_50 = rbx; &#125; else &#123; intrinsic_movaps(var_40, 0x0); var_50 = intrinsic_movaps(var_50, 0x0); &#125; rax = sub_10001c9a0(&amp;var_50, &amp;var_78); if (var_58 != 0x1) goto loc_100029cd8;loc_100029ccd: sub_10001c2f0(&amp;var_78); goto loc_100029d44;loc_100029d44: if (*(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded) == 0x1) &#123; rax = sub_1000230e0(0x1); &#125; else &#123; *(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks) = 0x1; rax = sub_1000215f0(); if ((rax &amp; 0x1) == 0x0) &#123; rbx = *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks; rax = *(int8_t *)(r13 + rbx); rax = !rax &amp; 0x1; *(int8_t *)(r13 + rbx) = rax; &#125; &#125; return rax;loc_100029cd8: rcx = *qword_1000e8a98; if (rcx == 0x0) &#123; rcx = swift_getObjCClassMetadata(swift_getInitializedObjCClass(@class(NSDictionary))); *qword_1000e8a98 = rcx; &#125; rax = swift_dynamicCast(&amp;var_28, &amp;var_78, *type metadata for Any + 0x8); if (rax == 0x0) goto loc_100029d44;loc_100029d24: r14 = var_28; if ([r14 count] == 0x0) goto loc_100029d8f;loc_100029d3c: [r14 release]; goto loc_100029d44;loc_100029d8f: r15 = [objc_allocWithZone(@class(NSAlert)) init]; rbx = sub_1000a7f20(&quot;No menu items have been setup&quot;, 0x1d, 0x1, rcx, 0x6); r12 = (extension in Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, 0x1); swift_bridgeObjectRelease(rbx); [r15 setMessageText:r12]; [r12 release]; rbx = sub_1000a7f20(&quot;No menu items have been setup in Bartender Preferences, so Bartender is not doing anything yet. Would you like to open preferences now.&quot;, 0x87, 0x1, rcx, 0x6); r12 = (extension in Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, 0x1); swift_bridgeObjectRelease(rbx); [r15 setInformativeText:r12]; [r12 release]; [r15 setAlertStyle:0x1]; rbx = sub_1000a7f20(&quot;Open Preferences&quot;, 0x10, 0x1, rcx, 0x6); r12 = (extension in Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, 0x1); swift_bridgeObjectRelease(rbx); rbx = [[r15 addButtonWithTitle:r12] retain]; [r12 release]; [rbx release]; rbx = sub_1000a7f20(&quot;Dismiss&quot;, 0x7, 0x1, rcx, 0x6); r12 = (extension in Foundation):Swift.String._bridgeToObjectiveC() -&gt; __ObjC.NSString(rbx, 0x1); swift_bridgeObjectRelease(rbx); rbx = [[r15 addButtonWithTitle:r12] retain]; [r12 release]; [rbx release]; if ([r15 runModal] == 0x3e8) &#123; sub_100029a10(); &#125; [r15 release]; rax = [r14 release]; return rax;loc_100029b6e: *(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_performDelayedClicks) = 0x0; rdi = r14; if (([rdi modifierFlags] &amp; 0x40000) == 0x0) &#123; sub_100020de0(); &#125; else &#123; if (*(int8_t *)(r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded) == 0x1) &#123; sub_1000230e0(0x1); &#125; else &#123; sub_100020fe0(rdi); &#125; &#125; rax = [r14 release]; return rax;loc_100029b66: [r14 release]; goto loc_100029b6e;loc_100029f44: asm &#123; ud2 &#125;; rax = sub_100029f46(); return rax;&#125; PS: 为了便于读者结合后面分析部分的内容快速定位（Command + F），上面的伪代码没有使用截图形式展示。 其中很醒目的是 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 我们按照之前的方法，将伪代码先切回汇编模式，找到对应的汇编代码处。 这是一段明显的 if 语句汇编代码，看下面的 mov edi, 0x1 这一小节就是指 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 为 true 之后执行的代码，表示要是试用期到期就执行 0x1000230e0 处的方法。我们记下这个地址之后把这两处的汇编代码通过上文插入汇编代码的方式修改一下，将这个 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 直接替换为 0x0 即 false 。 在逆向工程中，切忌不可以冒进，时值今日几乎所有应用都会采取措施来增加其逆向难度。这时候千万不要想着一步到位，应该在适量修改之后尝试导出二进制，用动态分析的方法验证一下结果。因为我们这时候不是正向开发者，在没有见到上下文的情况下修改代码很可能会把程序改成一个不可用的状态（比如正常功能损坏或者频繁 Crash），所以最好步步为营。 这里我们导出修改之后的二进制文件，按照 Bartender 的原路径覆盖之前的二进制文件验证一下结果。我在这个阶段运行时发现如果正常开启 Bartender 还是会有一个 10s 左右的可用时长，之后依然会弹出试用期到期弹窗，并且程序变为不可用状态；而如果重启 Bartender 在试用期弹窗弹出之前点击功能按钮则可以正常切换，但是再次点击按钮却切换不回来了，并且程序运行 10s 左右仍会弹出试用期到期弹窗，但是菜单栏上面的图标不会变失效，只是切不回去而已。 功能破解到目前为止如果不在乎功能仅仅想要隐藏菜单栏的图标已经是可以凑合用了，但是这显然不是我们想要的最终结果。 通过上面运行程序后观察到的情况我推测在 -[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:] 内部切换回来的逻辑中仍然有地方对是否到期做了判断，我们上面只是成功修改了切换过去的逻辑，那么切换回来的逻辑在哪呢？ 按逻辑推测，正向切换的时候是使用 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 做判断，反向切换应该同理才对，我们去追踪 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 的使用，最终发现 sub_10001f870 中使用了 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 且 sub_10001f870 被 sub_100029a10 调用，sub_100029a10 又被 sub_100029ac0 调用，sub_100029ac0 就是上文在 -[_TtC11Bartender_311AppDelegate bartenderStatusItemClickWithSender:] 中被调用的函数，这不仅满足了被 Bartender 功能按钮所引用的条件，同时还对 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 有所引用，所以我用插入汇编的方式将 sub_10001f870 中关于 objc_ivar_offset__TtC11Bartender_311AppDelegate_trialEnded 的使用改为了 0x0，即 false。 嘛~ 导出二进制覆盖，发现这次的 Bartender 已经可以正常使用功能了，不过试用期到期的弹窗问题依然存在，尽管它并不影响使用，但我还是无法接受这样一个半成品的状态。 完美破解还记得上文中得出的 0x1000230e0 吗，如果试用期到期则会执行 0x1000230e0 地址处的方法，我们通过快捷键 G 跳转到 0x1000230e0 地址，看一下里面的实现逻辑。 123456789101112131415161718192021222324252627282930313233void sub_1000230e0(int arg0) &#123; r14 = arg0; r15 = r13 + *objc_ivar_offset__TtC11Bartender_311AppDelegate_trialOverWindow; rbx = swift_unknownWeakLoadStrong(r15); if (rbx != 0x0) &#123; [rbx center]; [rbx release]; rbx = **_NSApp; if (rbx != 0x0) &#123; [rbx retain]; [rbx activateIgnoringOtherApps:sign_extend_64($S10ObjectiveC22_convertBoolToObjCBoolyAA0eF0VSbF(r14 &amp; 0xff))]; [rbx release]; rbx = swift_unknownWeakLoadStrong(r15); if (rbx != 0x0) &#123; [rbx makeKeyAndOrderFront:0x0]; [rbx release]; &#125; else &#123; asm &#123; ud2 &#125;; sub_100023199(); &#125; &#125; else &#123; asm &#123; ud2 &#125;; loc_100023195(); &#125; &#125; else &#123; asm &#123; ud2 &#125;; loc_100023191(); &#125; return;&#125; 通过上面的伪代码，我们可以初步判断这个 0x1000230e0 内部就是弹出试用期到期弹窗的方法。接着我们通过快捷键 X 查看关于 0x1000230e0 的引用，可以发现有三处调用，一个一个看下去发现第一个 sub_100022840 中的调用最像是延时调用，因为其中有 Hopper 反编译出来的 Dispatch 相关的伪代码。 123456789101112$Ss10SetAlgebraPyxqd__cs8SequenceRd__7ElementQyd__ADRtzlufCTj(&amp;var_A0, r13); swift_release(*__swiftEmptyArrayStorage); (extension in Dispatch):__ObjC.OS_dispatch_queueasyncAfterdeadlineqosflags.execute(Dispatch.DispatchTime, Dispatch.DispatchQoS, Dispatch.DispatchWorkItemFlags, @convention(block) () -&gt; ()) -&gt; ()(var_40, var_68, var_B0, var_30); (*(var_D0 + 0x8))(var_B0, var_C8); (*(var_C0 + 0x8))(var_68, var_B8); _Block_release(var_30); swift_release(var_D8); (var_38)(var_40, var_70, rdx); [var_A8 release]; sub_1000230e0(0x0); rbx = var_48; goto loc_100022df5; 切到汇编模式，找到对应的汇编代码。 由于 sub_1000230e0(0x0); 是在 Dispatch 中调用的，考虑到修改后程序的稳定性，这里通过 Hopper 的 Modify 菜单中提供的 NOP Region 填平 call sub_1000230e0 汇编代码。 老规矩，导出二进制文件覆盖 Bartender 中的二进制后重启 Bartender 验收成果。 清爽~ 这次运行 Bartender 发现不但可以正常使用功能，之前烦人的试用期到期弹窗也被我们成功干掉了。 总结 文章简单介绍了本次要破解的目标 Mac 应用 Bartender，如果各位同学还没有找到合适的顶部菜单栏图标管理工具不妨试着使用 Bartender。 文章介绍了 maxOS 与 iOS 逆向工程中主流的静态分析工具 Hopper，从文章后面破解 Bartender 的实战过程中就可以看出 Hopper 对于我们逆向过程的帮助有多么大。 文章最后详细讲述了我在破解 Bartender 过程中的经历，从初始常规思路到不起作用思路被截断再到通过动态分析重拾思路…一直到最后的完美破解中间经历了许多关键节点，希望对大家有所帮助。 每一次逆向的过程都是未知的，有的时候可能会很顺利（直接 mov eax, 0x1 + ret 就搞定），有的时候可能会很曲折，有的时候可能还会以失败收尾。我写这篇文章主要是想与大家交流在逆向过程中的常规方法以及遇到困难时的一些解决思路，其实不论是 Bartender 还是其他应用，不论是 Mac 应用还是 iOS 应用，逆向的思路都是相通的，愿各位同学日后可以举一反三。 如果有任何问题欢迎在文章下方留言或在我的微博 @Lision 联系我，真心希望我的文章可以为你带来价值~"},{"title":"WWDC18 What’s New in LLVM","comments":true,"permalink":"https://lision.me/wwdc18_llvm/","text":"前言LLVM 作为 Apple 御用的编译基础设施其重要性不言而喻，Apple 从未停止对 LLVM 的维护和更新，并且几乎在每年的 WWDC 中都有专门的 Session 来针对 LLVM 的新特性做介绍和讲解，刚刚过去的 WWDC18 也不例外。 WWDC18 Session 409 What’s New in LLVM 中 Apple 的工程师们又为我们介绍了 LLVM 最新的特性，这篇文章将会结合 WWDC18 Session 409 给出的 官方演示文稿 分享一下 LLVM 的新特性并谈谈笔者自己个人对这些特性的拙见。 Note: 本文不会对官方演示文稿做逐字逐句的翻译工作，亦不会去过多介绍 LLVM 的基本常识。 索引 ARC 更新 Xcode 10 新增诊断 Clang 静态分析 增加安全性 新指令集扩展 总结 ARC 更新本次 ARC 更新的亮点在于 C struct 中允许使用 ARC Objective-C 对象。 在之前版本的 Xcode 中尝试在 C struct 的定义中使用 Obj—C 对象，编译器会抛出 Error: ARC forbids Objective-C objects in struct，如下图所示： 嘛~ 这是因为之前 LLVM 不支持，如果在 Xcode 10 中书写同样的代码则不会有任何 Warning 与 Error： 那么直接在 C struct 中使用 Objective-C 对象的话难道就没有内存上的问题吗？Objective-C 所占用的内存空间是何时被销毁的呢？ 1234567// ARC Object Pointers in C Structs!typedef struct &#123; NSString *name; NSNumber *price;&#125; MenuItem; void orderFreeFood(NSString *name) &#123; MenuItem item = &#123; name, [NSNumber numberWithInt:0] &#125;; // [item.name retain]; // [item.price retain]; orderMenuItem(item); // [item.name release]; // [item.price release]; &#125; 如上述代码所示，编译器会在 C struct MenuItem 创建后 retain 其中的 ARC Objective-C 对象，并在 orderMenuItem(item); 语句之后，即其他使用 MenuItem item 的函数调用结束之后 release 掉相关 ARC Objective-C 对象。 思考，在动态内存管理时，ARC Objective-C 对象的内存管理会有什么不同呢？ Note: 动态内存管理（Dynamic Memory Management），指非 int a[100]; 或 MenuItem item = &#123;name, [NSNumber numberWithInt:0]&#125;; 这种在决定了使用哪一存储结构之后，就自动决定了作用域和存储时期的代码，这种代码必须服从预先制定的内存管理规则。 我们知道 C 语言中如果想要灵活的创建一个动态大小的数组需要自己手动开辟、管理、释放相关的内存，示例： 1234567891011121314151617void foo() &#123; int max; double *ptd; puts(&quot;What is the maximum number of type double entries?&quot;); scanf(&quot;%d&quot;, &amp;max); ptd = malloc(max * sizeof(double)); if (ptd == NULL) &#123; // memory allocation failed ... &#125; // some logic ... free(ptd);&#125; 那么 C struct 中 ARC Objective-C 的动态内存管理是否应该这么写呢？ 123456// Structs with ARC Fields Need Care for Dynamic Memory Managementtypedef struct &#123; NSString *name; NSNumber *price;&#125; MenuItem; void testMenuItems() &#123; // Allocate an array of 10 menu items MenuItem *items = malloc(10 * sizeof(MenuItem)); orderMenuItems(items, 10); free(items); &#125; 答案是否定的！ 可以看到通过 malloc 开辟内存初始化带有 ARC Objective-C 的 C struct 中 ARC Objective-C 指针不会 zero-initialized。 嘛~ 这个时候自然而然的会想起使用 calloc ^_^ Note: calloc 和 malloc 均可完成内存分配，不同之处在于 calloc 会将分配过来的内存块中全部位置都置 0（然而要注意，在某些硬件系统中，浮点值 0 不是全部位为 0 来表示的）。 另一个问题就是 free(items); 语句执行之前，ARC Objective-C 并没有被清理。 Emmmmm… 官方推荐的写法是在 free(items); 之前将 items 内的所有 struct 中使用到的 ARC Objective-C 指针手动职位 nil … 所以在动态内存管理时，上面的代码应该这么写： 123456// Structs with ARC Fields Need Care for Dynamic Memory Managementtypedef struct &#123; NSString *name; NSNumber *price;&#125; MenuItem; void testMenuItems() &#123; // Allocate an array of 10 menu items MenuItem *items = calloc(10, sizeof(MenuItem)); orderMenuItems(items, 10); // ARC Object Pointer Fields Must be Cleared Before Deallocation for (size_t i = 0; i &lt; 10; ++i) &#123; items[i].name = nil; items[i].price = nil; &#125; free(items); &#125; 瞬间有种日了狗的感觉有木有？ 个人观点嘛~ 在 C struct 中增加对 ARC Objective-C 对象字段的支持意味着我们今后 Objective-C 可以构建跨语言模式的交互操作。 Note: 官方声明为了统一 ARC 与 manual retain/release (MRR) 下部分 function 按值传递、返回 struct 对 Objective-C++ ABI 做出了些许调整。 值得一提的是 Swift 并不支持这一特性（2333~ 谁说 Objective-C 的更新都是为了迎合 Swift 的变化）。 Xcode 10 新增诊断Swift 与 Objective-C 互通性我们都知道 Swift 与 Objective-C 具有一定程度的互通性，即 Swift 与 Objective-C 可以混编，在混编时 Xcode 生成一个头文件将 Swift 可以转化为 Objective-C 的部分接口暴露出来。 不过由于 Swift 与 Objective-C 的兼容性导致用 Swift 实现的部分代码无法转换给 Objective-C 使用。 近些年来 LLVM 一致都在尝试让这两种语言可以更好的互通（这也就是上文中提到 Objective-C 的更新都是为了迎合 Swift 说法的由来），本次 LLVM 支持将 Swift 中的闭包（Closures）导入 Objective-C。 123@objc protocol Executor &#123; func performOperation(handler: () -&gt; Void)&#125; 1234#import “Executor-Swift.h”@interface DispatchExecutor : NSObject&lt;Executor&gt;- (void)performOperation:(void (^)(void))handler; @end Note: 在 Swift 中闭包默认都是非逃逸闭包（non-escaping closures），即闭包不应该在函数返回之后执行。 Objective-C 中与 Swift 闭包对应的就是 Block 了，但是 Objective-C 中的 Block 并没有诸如 Swift 中逃逸与否的限制，那么我们这样将 Swift 的非逃逸闭包转为 Objective-C 中无限制的 Block 岂不是会有问题？ 别担心，转换过来的闭包（非逃逸）会有 Warnning 提示，而且我们说过一般这种情况下 Apple 的工程师都会在 LLVM 为 Objective-C 加一个宏来迎合 Swift… 12// Warning for Missing Noescape Annotations for Method Overrides #import “Executor-Swift.h” @interface DispatchExecutor : NSObject&lt;Executor&gt; - (void)performOperation:(NS_NOESCAPE void (^)(void))handler; @end @implementation DispatchExecutor - (void)performOperation:(NS_NOESCAPE void (^)(void))handler &#123; &#125;// Programmer must ensure that handler is not called after performOperation returns @end 个人观点如果 Swift 5 真的可以做到 ABI 稳定，那么 Swift 与 Objective-C 混编的 App 包大小也应该回归正常，相信很多公司的项目都会慢慢从 Objective-C 转向 Swift。在 Swift 中闭包（Closures）作为一等公民的存在奠定了 Swift 作为函数式语言的根基，本次 LLVM 提供了将 Swift 中的 Closures 与 Objective-C 中的 Block 互通转换的支持无疑是很有必要的。 使用 #pragma pack 打包 Struct 成员Emmmmm… 老实说这一节的内容更底层，所以可能会比较晦涩，希望自己可以表述清楚吧。在 C 语言中 struct 有 内存布局（memory layout） 的概念，C 语言允许编译器为每个基本类型指定一些对齐方式，通常情况下是以类型的大小为标准对齐，但是它是特定于实现的。 嘛~ 还是举个例子吧，就拿 WWDC18 官方演示文稿中的吧： 12345struct Struct &#123; uint8_t a, b; // 2 byte padding uint32_t c;&#125;; 在上述例子中，编译器为了对齐内存布局不得不在 Struct 的第二字段与第三字段之间插入 2 个 byte。 123| 1 | 2 | 3 | 4 || a | b | pad.......... || c(1) | c(2) | c(3) | c(4) | 这样本该占用 6 byte 的 struct 就占用了 8 byte，尽管其中只有 6 byte 的数据。 C 语言允许每个远程现代编译器实现 #pragma pack，它允许程序猿对填充进行控制来依从 ABI。 From C99 §6.7.2.1: 12 Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type. 13 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning. 实际上关于 #pragma pack 的相关信息可以在 MSDN page 中找到。 LLVM 本次也加入了对 #pragma pack 的支持，使用方式如下： 123456#pragma pack (push, 1) struct PackedStruct &#123; uint8_t a, b; uint32_t c; &#125;;#pragma pack (pop) 经过 #pragma pack 之后我们的 struct 对齐方式如下： 1234567| 1 || a | | b || c(1) || c(2) || c(3) || c(4) | 其实 #pragma pack (push, 1) 中的 1 就是对齐字节数，如果设置为 4 那么对齐方式又会变回到最初的状态： 123| 1 | 2 | 3 | 4 || a | b | pad.......... || c(1) | c(2) | c(3) | c(4) | 值得一提的是，如果你使用了 #pragma pack (push, n) 之后忘记写 #pragma pack (pop) 的话，Xcode 10 会抛出 warning： 个人观点嘛~ 当在网络层面传输 struct 时，通过 #pragma pack 自定义内存布局的对齐方式可以为用户节约更多流量。 Clang 静态分析Xcode 一直都提供静态分析器（Static Analyzer），使用 Clang Static Analyzer 可以帮助我们找出边界情况以及难以发觉的 Bug。 点击 Product -&gt; Analyze 或者使用快捷键 Shift+Command+B 就可以静态分析当前构建的项目了，当然也可以在项目的 Build Settings 中设置构建项目时自动执行静态分析（个人不推荐）： 本地静态分析器有以下提升： GCD 性能反模式 自动释放变量超出自动释放池 性能和可视化报告的提升 GCD 性能反模式在之前某些迫不得已的情况下，我们可能需要使用 GCD 信号（dispatch_semaphore_t）来阻塞某些异步操作，并将阻塞后得到的最终的结果同步返回： 12345678__block NSString *taskName = nil;dispatch_semaphore_t sema = dispatch_semaphore_create(0);[self.connection.remoteObjectProxy requestCurrentTaskName:^(NSString *task) &#123; taskName = task; dispatch_semaphore_signal(sema);&#125;];dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);return taskName; 嘛~ 这样写有什么问题呢？ 上述代码存在通过使用异步线程执行任务来阻塞当前线程，而 Task 队列通常优先级较低，所以会导致优先级反转。 那么 Xcode 10 之后我们应该怎么写呢？ 1234567__block NSString *taskName = nil;id remoteObjectProxy = [self.connection synchronousRemoteObjectProxyWithErrorHandler: ^(NSError *error) &#123; NSLog(@&quot;Error: %@&quot;, error); &#125;];[remoteObjectProxy requestCurrentTaskName:^(NSString *task) &#123; taskName = task; &#125;];return taskName; 如果可能的话，尽量使用 synchronous 版本的 API。或者，使用 asynchronous 方式的 API： 123[self.connection.remoteObjectProxy requestCurrentTaskName:^(NSString *task) &#123; completionHandler(task);&#125;]; 可以在 build settings 下启用 GCD 性能反模式的静态分析检查： 自动释放变量超出自动释放池众所周知，使用 __autoreleasing 修饰符修饰的变量会在自动释放池离开时被释放（release）： 123@autoreleasepool &#123; __autoreleasing NSError *err = [NSError errorWithDomain:@&quot;domain&quot; code:1 userInfo:nil];&#125; 这种看似不需要我们注意的点往往就是引起程序 Crash 的隐患： 12345678910 - (void)findProblems:(NSArray *)arr error:(NSError **)error &#123; [arr enumerateObjectsUsingBlock:^(id value, NSUInteger idx, BOOL *stop) &#123; if ([value isEqualToString:@&quot;problem&quot;]) &#123; if (error) &#123; *error = [NSError errorWithDomain:@&quot;domain&quot; code:1 userInfo:nil]; &#125; &#125; &#125;];&#125; 嘛~ 上述代码是会引起 Crash 的，你可以指出为什么吗？ Objective-C 在 ARC（Automatic Reference Counting）下会隐式使用 __autoreleasing 修饰 error，即 NSError *__autoreleasing*。而 -enumerateObjectsUsingBlock: 内部会在迭代 block 时使用 @autoreleasepool，在迭代逻辑中这样做有助于减少内存峰值。 于是 *error 在 -enumerateObjectsUsingBlock: 中被提前 release 掉了，这样在随后读取 *error 时会出现 crash。 Xcode 10 中会给出具有针对性的静态分析警告： 正确的书写方式应该是这样的： 1234567891011- (void)findProblems:(NSArray *)arr error:(NSError *__autoreleasing*)error &#123; __block NSError *localError; [arr enumerateObjectsUsingBlock:^(id value, NSUInteger idx, BOOL *stop) &#123; if ([value isEqualToString:@&quot;problem&quot;]) &#123; localError = [NSError errorWithDomain:@&quot;domain&quot; code:1 userInfo:nil]; &#125; &#125;]; if (error) &#123; *error = localError; &#125; &#125; Note: 其实早在去年的 WWDC17 Session 411 What’s New in LLVM 中 Xcode 9 就引入了一个需要显示书写 __autoreleasing 的警告。 性能和可视化报告的提升Xcode 10 中静态分析器可以以更高效的方式工作，在相同的分析时间内平均可以发现比之前增加 15% 的 Bug 数量。 不仅仅是性能的提升，Xcode 10 在报告的可视化方面也有所进步。在 Xcode 9 的静态分析器报告页面有着非必要且冗长的 Error Path： Xcode 10 中则对其进行了优化： 个人观点嘛~ 对于 Xcode 的静态分析，个人认为还是聊胜于无的。不过不建议每次构建项目时都去做静态分析，这样大大增加了构建项目的成本。 个人建议在开发流程中自测完毕提交代码给组内小伙伴们 Code Review 之前做静态分析，可以避免一些 issue 的出现，也可以发现一些代码隐患。有些问题是可以使用静态分析器在提交代码之前就暴露出来的，没必要消耗组内 Code Review 的宝贵人力资源。 还可以在 CI 设置每隔固定是时间间隔去跑一次静态分析，生成报表发到组内小群，根据问题指派责任人去检查是否需要修复（静态分析在比较复杂的代码结构下并不一定准确），这样定期维护从某种角度讲可以保持项目代码的健康状况。 增加安全性Stack ProtectorApple 工程师在介绍 Stack Protector 之前很贴心的带领着在场的开发者们复习了一遍栈 Stack 相关的基础知识： 如上图，其实就是简单的讲了一下 Stack 的工作方式，如栈帧结构以及函数调用时栈的展开等。每一级的方法调用，都对应了一张相关的活动记录，也被称为活动帧。函数的调用栈是由一张张帧结构组成的，所以也称之为栈帧。 我们可以看到，栈帧中包含着 Return Address，也就是当前活动记录执行结束后要返回的地址。 那么会有什么安全性问题呢？Apple 工程师接着介绍了通过不正当手段修改栈帧 Return Address 从而实现的一些权限提升。嘛~ 也就是历史悠久的 缓冲区溢出攻击。 当使用 C 语言中一些不太安全的函数时（比如上图的 strcpy()），就有可能造成缓冲区溢出。 Note: strcpy() 函数将源字符串复制到指定缓冲区中。但是丫没有指定要复制字符的具体数目！如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会造成缓冲区溢出！ 针对缓冲区溢出攻击，LLVM 引入了一块额外的区域（下图绿色区域）来作为栈帧 Return Address 的护城河，叫做 Stack Canary，已默认启用： Note: Canary 译为 “金丝雀”，Stack Canary 的命名源于早期煤矿工人下矿坑时会携带金丝雀来检测矿坑内一氧化碳是否达到危险值，从而判断是否需要逃生。 根据我们上面对缓冲区溢出攻击的原理分析，大家应该很容易发现 Stack Canary 的防御原理，即缓冲区溢出攻击旨在利用缓冲区溢出来篡改栈帧的 Return Address，加入了 Stack Canary 之后想要篡改 Return Address 就必然会经过 Stack Canary，在当前栈帧执行结束后要使用 Return Address 回溯时先检测 Stack Canary 是否有变动，如果有就调用 abort() 强制退出。 嘛~ 是不是和矿坑中的金丝雀很像呢？ 不过 Stack Canary 存在一些局限性： 可以在缓冲区溢出攻击时计算 Canary 的区域并伪装 Canary 区域的值，使得 Return Address 被篡改的同时 Canary 区域内容无变化，绕过检测。 再粗暴一点的话，可以通过双重 strcpy() 覆写任意不受内存保护的数据，通过构建合适的溢出字符串，可以达到修改 ELF（Executable and Linking Format）映射的 GOT（Global Offset Table），只要修改了 GOT 中的 _exit() 入口，即便 Canary 检测到了篡改，函数返回前调用 abort() 退出还是会走已经被篡改了的 _exit()。 Stack CheckingStack Protector 是 Xcode 既有的、且默认开启的特性，而 Stack Checking 是 Xcode 10 引入的新特性，主要针对的是 Stack Clash 问题。 Stack Clash 问题的产生源于 Stack 和 Heap，Stack 是从上向下增长的，Heap 则是自下而上增长的，两者相向扩展而内存又是有限的。 Stack Checking 的工作原理是在 Stack 区域规定合理的分界线（上图红线），在可变长度缓冲区的函数内部对将要分配的缓冲区大小做校验，如果缓冲区超出分界线则调用 abort() 强制退出。 Note: LLVM 团队在本次 WWDC18 加入 Stack Checking，大概率是因为去年年中 Qualys 公布的一份 关于 Stack Clash 的报告。 新指令集扩展 Emmmmm… 这一节的内容是针对于 iMac Pro 以及 iPhone X 使用的 指令集架构（ISA - Instruction set architecture） 所做的扩展。坦白说，我对这块并不是很感兴趣，也没有深入的研究，所以就不献丑了… 总结本文梳理了 WWDC18 Session 409 What’s New in LLVM 中的内容，并分享了我个人对这些内容的拙见，希望能够对各位因为种种原因还没有来得及看 WWDC18 Session 409 的同学有所帮助。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"Sony WH-H900N 开箱留念","comments":true,"permalink":"https://lision.me/sony_wh_h900n/","text":"前言嘛~ 又是一年高考季，每到这个时候我就知道我又长了一岁… Emmmmm… 最近似乎陷入了创作低谷，已经很久没有更新过博客了，原因嘛… 有很多： 一方面是入职之后需要适应新的环境，包括新的团队，新的流程… 从这一点来看人类果然是弱鸡动物，会受到外界环境的变化以及心情等内在因素的影响，至少机器人不会被这些东西困扰吧… 另一方面是不知道应该写什么，或者说自己在这段与新团队的磨合期中眼界提升了很多，很多之前计划去写的文章现在突然没有兴趣了，以前也有过类似的经历… 唯有告诫自己戒掉拖延症，不要错过当前这段时期自己想做的事情哈~ 另外一个最重要原因就是——真的没时间。 自己也想过为什么会这样，除去磨合期种种不熟悉导致的时效问题，还剩下一些客观存在的因素，其中就有办公环境的影响，现在的办公环境比较开放（装修风格和网吧类似 &gt;_&lt;），所以每天都会有 QA 小姐姐们测试订单的声音，PM 小哥哥们撕逼的声音，RD 小伙伴们敲击键盘的声音… 这几种声音在不同的音频攻击着我幼小的心脏和脆弱的神经，影响着我敲代码时的专注程度… 然后可能之前下班回到家后有和我女票抱怨过吧… 结果过生日就收到了这篇文章的主角—— Sony WH-H900N。 索引 Sony WH-H900N 入手渠道 开箱照 上头体验 总结 Sony WH-H900N Sony WH-H900N 全称 Sony | h.ear on 2 Wireless NC | WH-H900N，是大法旗下的 h.ear on 2 系列无线蓝牙降噪耳机。 关键词： 佩戴良好 隔音良好 听诊器效应轻微 做工优秀 降噪良好 杂食 由于我自己平时什么音乐都听一些，偏 ACG 和 Eason Chen 多一些，加上我自己本身是木耳（木头耳朵，指听不出不同耳机的音质区别）所以一直以来对耳机就只有无线和降噪两个硬性需求，然后自己没有出街听音乐的习惯（主要是觉得车来车往不太安全），所以想要一款头戴式的耳机（在办公室和家里听听就好），然后因为头戴式的耳机比较显眼，所以对颜值也有了一定的要求… 刚刚好，这些需求 Sony WH-H900N 统统满足了，再次感恩我的女票，想必花了不少心思吧（笑） 配色方面，这款耳机提供了五种配色可供选择： 暮光红（目光红，因为这个颜色真的特别少女，据说出街回头率超高） 月光蓝 薄荷绿 浅金 灰黑 这几种颜色都是偏哑光质感的，低调的同时满足了绝大多数消费者的个性化选择，我这款就是月光蓝配色的~ Note: 鉴于网上各种评测贴和买家秀的晒图中出现了各种颜色的月光蓝，所以我这篇文章的所有配图均无任何滤镜和后期处理，希望能够给想买月光蓝的同学提供一些参考和帮助。 补充，话说我还在大法的官方商城搜到了 WH-H900N FATE 特别版哟~ 开箱照 箱内物品如下： Sony WH-H900N 耳机本体 耳机线材（手感一般，随耳机本体颜色） 充电线（黑色） 收纳袋（手感不错的透气帆布材质收纳袋，内衬柔软材料，随耳机本体颜色） 收纳盒（随耳机本体颜色） 需要注意的是只有充电线是黑色的，这也就意味着如果你选择的是暮光红这种偏浅色系的配色，充电的时候会…非！常！丑！好在这款耳机有大法的快充黑科技加持（其实不如 Apple 的快充黑科技），在低电量时充电 10 分钟可以听 1 小时左右（说明书有写 &amp; 亲测），另外耳机充满电的续航时间为 28 小时（开启降噪），完全可以在家充好电再带去公司使用。 上头体验 Emmmmm… 自认木耳，又是理工男的渣渣文笔，就简单叙述一下自己的主观听感吧~ 音质音质方面个人认为还不错，这款耳机偏中低音，恰好 Eason Chen 的歌普遍都是中低音男声，所以表现很不错，人声清晰，不会感觉距离耳朵很远，又不会感觉靠的太近，可以说是恰到好处吧~ 另外 ACG 女声的表现也很不错，人声甜美，距离适中，声音有厚度。有的耳机人声表现就很单薄，该怎么形容呢？就是感觉人声是耳机从背景音乐中摘出来突兀的放到耳边的，清楚但是与背景音格格不入，像纸片一样突兀且单薄，一带而过的发声… 降噪首先，耳机的耳垫做工很不错，足够柔软舒适，扣在耳朵上已经可以降低 10%~20% 的环境噪音了，然后开机并开启降噪模式可以瞬间感觉到 &gt;= 80% 的环境噪音都被屏蔽了，剩下的一些声音基本都是附近的人声，且声音小了很多（开始听音乐时外面减弱过的人声就基本听不到了）~ 低频的杂音类似中央空调出风口的声音则完全被屏蔽，我是中午午休时拆箱第一次试戴的，当时正好没人说话，感觉瞬间沉入海底，整个世界都安静了~ Note: Sony WH-H900N 支持手势操控，用右手遮盖右耳机，则会降低正在播放的音乐音量，同时暂时关闭降噪，这样非常人性化的便捷设计可以让你很方便的与同事短暂沟通。 无线大法黑科技将蓝牙传输的速率提升很多，在无线状态下依然尽可能的争取音质体验，个人的感觉是比我之前 Beats solo 2 的音质还要稍好一些~ 做工这款耳机的头梁做工很厚实，保证了长时间佩戴的舒适度（不过耳垫处由于密封性等原因会比较容易出汗，好在公司和家里都有空调，问题不大），这一点和我之前的 Beats solo 2 形成强烈对比，Beats solo 2 的头梁就薄薄一层，拆开之后发现里面只有一层超薄海绵（日了狗了）。 耳机的触感和它偏哑光的颜色保持一致，形容起来大概就是介于磨砂和光面之间的感觉，耳垫柔软舒适有弹性，大爱 Sony 这种优秀扎实的做工品质！ 总结嘛~ 总得来说呢… Sony WH-H900N 这款耳机非常适合对无线 &amp; 降噪有硬性需求的同学，难能可贵的是其在无线 &amp; 降噪的基础上还保证了高颜值 &amp; 一定的音质（反正对于我这种木耳来讲足够了）。 补充，降噪耳机真的是提升工效的利器，从某种角度看甚至比键盘来的更加粗暴有效（毕竟不需要磨合期）。"},{"title":"Hackathon 5.0 小记","comments":true,"permalink":"https://lision.me/hackathon5-0/","text":"前言Emmmmm… 还记得上一次参加 Hackathon 是在 2017 年上海举办的，当时还在 ELSEWHERE 工作的我和公司的小伙伴们一起组团从北京到上海参赛，也是我人生中第一次参加 Hackathon，所以到现在都还印象深刻呢！ 这一晃，加入美团·点评也快满三个月了，早就知道美团·点评有公司内部举办 Hackathon 的传统，但没想到这么快就可以参与其中了，想想还有点小激动。其实之前就有看到过同事穿着往届内部 Hackathon 主题 T 恤来公司上班，自己也超想有一件！所以在公司内部发出这次 Hackathon 5.0 的宣传页以及报名表时就毫不犹豫的拉着组里的两位大佬一起报名了哈。 索引 Hackathon Hackathon 5.0 不同于往届的赛制 嗨 Kr 森 Somewhere 去年的 Hackathon 回忆 总结 HackathonHackathon 译为“黑客马拉松”，旨在用限定的时间做出可用的软件应用。 Hackathon 往往都有一个特定的焦点，其中可能包括使用的编程语言，操作系统，应用程序，API 等等。 不仅仅是程序猿，Hackathon 的参赛人员包含软件开发领域的所有职业，包括平面设计师，界面设计师，产品经理等等，大家在赛前根据计划组队，比赛过程中各司其职，发挥专长，力争为团队拿下好的成绩。 不过随着 Hackathon 的不断发展，现在的 Hackathon 已经不单单是场比赛了，我觉得它更像是让 Hacker 们齐聚一堂盛会和节日。 Hackathon 5.0Emmmmm… 为什么叫 Hackathon 5.0 呢？其实感觉这个就是公司内部为了区分每一届 Hackathon 的 Tag 而已。貌似在美团网与大众点评合并之前，两家公司就都有内部举办 Hackathon 的历史，合并之后自然而然的将这一传统延续了下来。 不同于往届的赛制往届 Hackathon 大致流程： 提前一两周给一个特定范围内的主题 大家根据主题找灵感 线下拉人组队 技术调研保证项目可行性以及确定技术方案 报名参赛 现场开始编码 在规定的时间内（24 小时）完成作品 在完成作品期间抽时间准备 PPT 模拟上台宣讲 评委对参赛队伍的作品初筛 入围的队伍上台决赛答辩 评委给出最终评分决出名次 上台领奖 &amp; 拍照留恋 不过这次 Hackathon 5.0 在赛制上为了保证参赛作品的质量，没有明确的限制主题，这就导致有些作品是在赛前做了很久的项目，这些项目不论从体量还是从质量上都跟 24 小时竭尽全力所能产出的作品有着悬殊的差距。 个人认为提前两周公布一个明确的主题范围，大家在两周内做技术调研之后提前在工作之余开始构建项目还是可以接受的，这样可以保证参赛作品的质量同时也可以省去大家通宵熬夜对身体的损耗。主办方出发点是好的，但是任何主题任何项目都可以参赛这点就决定了这场 Hackathon 注定是不太公平的同台竞技，不仅打压了部分第一次参加 Hackathon 的同学以后继续参加的积极性，还掀起了一个不好的势头 —— 以后参赛的作品可能都会是提前很久就开始构建的项目。 嘛~ 上面的个人观点可能有些酸吧… 因为我们战队就是按照老 Hackathon 的赛制准备的（事实上我并不知道美团·点评内部 Hackathon 什么时候举办，也不知道这次的赛制竟然没有限制主题）。 嗨 Kr 森嘛~ “嗨 Kr 森”是我们本次参加 Hackathon 5.0 的战队名哈！ 起这个名字无非就是觉得比较好玩，因为组里连我在内的三人中，有两位都没有参加过公司内部组织的 Hackathon，所以本次参赛的主要目的就是熟悉一下公司内部 Hackathon 的流程，还有混一件 Hackathon 5.0 主题 T 恤衫（笑）。 Somewhere Somewhere 译为“某处”，是我们战队这次拿来参赛的作品。它是一个将 AR 技术结合到地图的项目，旨在帮助用户发现值得消费时间去用心体验的地方。 Emmmmm… 其实关于 Somewhere 还有一个比较文艺的文案是我们当时在写参赛 PPT 时想到的。 我们一直以来都希望，打开手机，对准想要去的方向。相信总有一处地方，值得我们花些时间在那里。Somewhere，帮助你发现近在咫尺的美好。 Somewhere 参考了 ARKit-CoreLocation 的实现，在其基础上做了一些优化，例如对某一方向重叠在一起的 POI AR Annotations 做了收敛以防止多个 POI AR Annotations 重叠在一起的问题。 可惜的是 Somewhere 只拿到了入围奖（42 进 10），确实站在评委的角度看 Somewhere 在完成度上面对比获奖作品来说差的太多了… 去年的 Hackathon 回忆去年还在 ELSEWHERE 工作时，和公司的小伙伴一起去上海参加中信集团与宝马联合赞助举办的开放式 Hackathon，也是我第一次参加 Hackathon，所以很多细节都记得清清楚楚~ 那届 Hackathon 的主题是三选一，其中中信集团的主题之一是我们一直比较感兴趣的区块链相关主题，中信集团想要依靠区块链技术打造其集团下属业务之间的用户信用体系，确实利用区块链超级账本做信用相关的东西是个不错的出发点，从扩展性的角度看区块链技术可以让中信集团以后支持并入其他非集团旗下的外部业务。 最后我们的参赛作品“信信”非常幸运的入围，并且在决赛拿到了名次和奖品~ 总结 平日里有自己感兴趣的技术或者想做的事情，不妨抽空动手写一写 Demo，如果可行的话可以持续抽时间完善，说不定可以拿来作为作品参加下一届公司内部的 Hackathon。 PPT 和作品的核心代码一样重要，初赛宣讲和决赛答辩给出的时间不同，最好准备详略两份 PPT。 核心流程一定要跑通，尤其是涉及到网络，定位等不确定因素时，一定要在上台前确认好当前的状态是否会影响到作品演示。 最受欢迎奖会在第二日的决赛答辩之前给出一个投票页面，在队长群会周知要填写投票页面中关于自己战队的作品简介，一定要及时填写作品简介以免影响得票率。 嘛~ 目前准备看一下 WWDC 2018 有没有什么感兴趣的技术点，准备拿来结合生活中的场景做些有趣的东西出来，为 Hackathon 6.0 做准备~ Emmmmm… 最后还要感谢战队里面的两位大佬愿意把宣讲和答辩的机会让给我，第一次面对着评委和台下这么多优秀的同事（其中不乏技术大佬）讲话真的是非常紧张的说，果然在回答某些问题上不够巧妙… 不过好在对于项目的宣讲和描述还算比较完整，大佬们也没有责怪我的意思，还给我拍了一张答辩时的照片~"},{"title":"深入理解 iOS Rendering Process","comments":true,"permalink":"https://lision.me/ios-rendering-process/","text":"前言iOS 最早名为 iPhone OS，是 Apple 公司专门为其硬件设备开发的操作系统，最初于 2007 年随第一代 iPhone 推出，后扩展为支持 Apple 公司旗下的其他硬件设备，如 iPod、iPad 等。 作为一名 iOS Developer，相信大多数人都有写出过造成 iOS 设备卡顿的代码经历，相应的也有过想方设法优化卡顿代码的经验。 本文将从 OpenGL 的角度结合 Apple 官方给出的部分资料，介绍 iOS Rendering Process 的概念及其整个底层渲染管道的各个流程。 相信在理解了 iOS Rendering Process 的底层各个阶段之后，我们可以在平日的开发工作之中写出性能更高的代码，在解决帧率不足的显示卡顿问题时也可以多一些思路~ 索引 iOS Rendering Process 概念 iOS Rendering 技术框架 OpenGL 主要渲染步骤 OpenGL Render Pipeline Core Animation Pipeline Commit Transaction Animation 全文总结 扩展阅读 iOS Rendering Process 概念iOS Rendering Process 译为 iOS 渲染流程，本文特指 iOS 设备从设置将要显示的图元数据到最终在设备屏幕成像的整个过程。 在开始剖析 iOS Rendering Process 之前，我们需要对 iOS 的渲染概念有一个基本的认知： 基于平铺的渲染iOS 设备的屏幕分为 N * N 像素的图块，每个图块都适合于 SoC 缓存，几何体在图块内被大量拆分，只有在所有几何体全部提交之后才可以进行光栅化（Rasterization）。 Note: 这里的光栅化指将屏幕上面被大量拆分出来的几何体渲染为像素点的过程。 iOS Rendering 技术框架事实上 iOS 渲染相关的层级划分大概如下： UIKit嘛~ 作为一名 iOS Developer 来说，应该对 UIKit 都不陌生，我们日常开发中使用的用户交互组件都来自于 UIKit Framework，我们通过设置 UIKit 组件的 Layout 以及 BackgroundColor 等属性来完成日常的界面绘画工作。 其实 UIKit Framework 自身并不具备在屏幕成像的能力，它主要负责对用户操作事件的响应，事件响应的传递大体是经过逐层的视图树遍历实现的。 那么我们日常写的 UIKit 组件为什么可以呈现在 iOS 设备的屏幕上呢？ Core AnimationCore Animation 其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做 Layer Kit 这么一个不怎么和动画有关的名字演变而来的，所以做动画仅仅是 Core Animation 特性的冰山一角。 Core Animation 本质上可以理解为是一个复合引擎，旨在尽可能快的组合屏幕上不同的显示内容。这些显示内容被分解成独立的图层，即 CALayer，CALayer 才是你所能在屏幕上看见的一切的基础。 其实很多同学都应该知道 CALayer，UIKit 中需要在屏幕呈现的组件内部都有一个对应的 CALayer，也就是所谓的 Backing Layer。正是因为一一对应，所以 CALayer 也是树形结构的，我们称之为图层树。 视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。 但是为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级关系来处理所有事情呢？ 原因在于要做职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，而 Mac OS X 有 AppKit 和 NSView 的原因。他们功能上很相似，但是在实现上有着显著的区别。 Note: 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图树和图层树之外，还存在呈现树和渲染树。 OpenGL ES &amp; Core GraphicsOpenGL ESOpenGL ES 简称 GLES，即 OpenGL for Embedded Systems，是 OpenGL 的子集，通常面向图形硬件加速处理单元（GPU）渲染 2D 和 3D 计算机图形，例如视频游戏使用的计算机图形。 OpenGL ES 专为智能手机，平板电脑，视频游戏机和 PDA 等嵌入式系统而设计 。OpenGL ES 是“历史上应用最广泛的 3D 图形 API”。 Core GraphicsCore Graphics Framework 基于 Quartz 高级绘图引擎。它提供了具有无与伦比的输出保真度的低级别轻量级 2D 渲染。您可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。 Note: 在 Mac OS X 中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。 Graphics HardwareGraphics Hardware 译为图形硬件，iOS 设备中也有自己的图形硬件设备，也就是我们经常提及的 GPU。 图形处理单元（GPU）是一种专用电子电路，旨在快速操作和改变存储器，以加速在用于输出到显示设备的帧缓冲器中创建图像。GPU 被用于嵌入式系统，手机，个人电脑，工作站和游戏控制台。现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效。 OpenGL 主要渲染步骤OpenGL 全称 Open Graphics Library，译为开放图形库，是用于渲染 2D 和 3D 矢量图形的跨语言，跨平台的应用程序编程接口（API）。OpenGL 可以直接访问 GPU，以实现硬件加速渲染。 一个用来渲染图像的 OpenGL 程序主要可以大致分为以下几个步骤： 设置图元数据 着色器-shader 计算图元数据（位置·颜色·其他） 光栅化-rasterization 渲染为像素 fragment shader，决定最终成像 其他操作（显示·隐藏·融合） Note: 其实还有一些非必要的步骤，与本文主题不相关，这里点到为止。 我们日常开发时使用 UIKit 布局视图控件，设置透明度等等都属于设置图元数据这步，这也是我们日常开发中可以影响 OpenGL 渲染的主要步骤。 OpenGL Render Pipeline如果有同学看过 WWDC 的一些演讲稿或者接触过一些 OpenGL 知识，应该对 Render Pipeline 这个专业术语并不陌生。 不过 Render Pipeline 实在是一个初次见面不太容易理解的词，它译为渲染管道，也有译为渲染管线的… 其实 Render Pipeline 指的是从应用程序数据转换到最终渲染的图像之间的一系列数据处理过程。 好比我们上文中提到的 OpenGL 主要渲染步骤一样，我们开发应用程序时在设置图元数据这步为视图控件的设定布局，背景颜色，透明度以及阴影等等数据。 下面以 OpenGL 4.5 的 Render Pipeline 为例介绍一下： 这些图元数据流入 OpenGL 中，传入顶点着色器（vetex shader），然后顶点着色器对其进行着色器内部的处理后流出。之后可能进入细分着色阶段（tessellation shading stage），其中又有可能分为细分控制着色器和细分赋值着色器两部分处理，还可能会进入几何着色阶段（geometry shading stage），数据从中传递。最后都会走片元着色阶段（fragment shading stage）。 Note: 图元数据是以 copy 的形式流入 shader 的，shader 一般会以特殊的类似全局变量的形式接收数据。 OpenGL 在最终成像之前还会经历一个阶段名为计算着色阶段（compute shaing stage），这个阶段 OpenGL 会计算最终要在屏幕中成像的像素位置以及颜色，如果在之前提交代码时用到了 CALayer 会引起 blending 的显示效果（例如 Shadow）或者视图颜色或内容图片的 alpha 通道开启，都将会加大这个阶段 OpenGL 的工作量。 Core Animation Pipeline上文说到了 iOS 设备之所以可以成像不是因为 UIKit 而是因为 LayerKit，即 Core Animation。 Core Animation 图层，即 CALayer 中包含一个属性 contents，我们可以通过给这个属性赋值来控制 CALayer 成像的内容。这个属性的类型定义为 id，在程序编译时不论我们给 contents 赋予任何类型的值，都是可以编译通过的。但实践中，如果 contents 赋值类型不是 CGImage，那么你将会得到一个空白图层。 Note: 造成 contents 属性的奇怪表现的原因是 Mac OS X 的历史包袱，它之所以被定义为 id 类型是因为在 Mac OS X 中这个属性对 CGImage 和 NSImage 类型的值都起作用。但是在 iOS 中，如果你赋予一个 UIImage 属性的值，仅仅会得到一个空白图层。 说完 Core Animation 的 contents 属性，下面介绍一下 iOS 中 Core Animation Pipeline： 在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层 Core Animation 图层相关的数据提交到 iOS Render Server，即 OpenGL ES &amp; Core Graphics Render Server 将与 GPU 通信把数据经过处理之后传递给 GPU GPU 调用 iOS 当前设备渲染相关的图形设备 Display Note: 由于 iOS 设备目前的显示屏最大支持 60 FPS 的刷新率，所以每个处理间隔为 16.67 ms。 可以看到从 Commit Transaction 之后我们的图元数据就将会在下一次 RunLoop 时被 Application 发送给底层的 Render Server，底层 Render Server 直接面向 GPU 经过一系列的数据处理将处理完毕的数据传递给 GPU，然后 GPU 负责渲染工作，根据当前 iOS 设备的屏幕计算图像像素位置以及像素 alpha 通道混色计算等等最终在当前 iOS 设备的显示屏中呈现图像。 嘛~ 由于 Core Animation Pipeline 中 Render Server 包含 OpenGL ES &amp; Core Graphics，其中 OpenGL ES 的渲染可以参考上文 OpenGL Render Pipeline 理解。 Commit TransactionCore Animation Pipeline 的整个管线中 iOS 常规开发一般可以影响到的范围也就仅仅是在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层这一级，即 Commit Transaction 之前的一些操作。 那么在 Commit Transaction 之前我们一般要做的事情有哪些？ Layout，构建视图 Display，绘制视图 Prepare，额外的 Core Animation 工作 Commit，打包图层并将它们发送到 Render Server Layout在 Layout 阶段我们能做的是把 constraint 写的尽量高效，iOS 的 Layout Constraint 类似于 Android 的 Relative Layout。 Note: Emmmmm… 据观察 iOS 的 Layout Constraint 在书写时应该尽量少的依赖于视图树中同层级的兄弟视图节点，它会拖慢整个视图树的 Layout 计算过程。 这个阶段的 Layout 计算工作是在 CPU 完成的，包括 layoutSubviews 方法的重载，addSubview: 方法填充子视图等 Display其实这里的 Display 仅仅是我们设置 iOS 设备要最终成像的图元数据而已，重载视图 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制 bitmap。 Note: 重载 drawRect: 方法绘制 bitmap 过程使用 CPU 和 内存。 所以重载 drawRect: 使用不当会造成 CPU 负载过重，App 内存飙升等问题。 Prepare这个步骤属于附加步骤，一般处理图像的解码 &amp; 转换等操作。 CommitCommit 步骤指打包图层并将它们发送到 Render Server。 Note: Commit 操作会递归执行，由于图层和视图一样是以树形结构存在的，当图层树过于复杂时 Commit 操作的开销也会非常大。 CATransactionCATransaction 是 Core Animation 中用于将多个图层树操作分配到渲染树的原子更新中的机制，对图层树的每个修改都必须是事务的一部分。 CATransaction 类没有属性或者实例方法，并且也不能用 +alloc 和 -init 方法创建它，我们只能用类方法 +begin 和 +commit 分别来入栈或者出栈。 事实上任何可动画化的图层属性都会被添加到栈顶的事务，你可以通过 +setAnimationDuration: 方法设置当前事务的动画时间，或者通过 +animationDuration 方法来获取时长值（默认 0.25 秒）。 Core Animation 在每个 RunLoop 周期中自动开始一次新的事务，即使你不显式地使用 [CATransaction begin] 开始一次事务，在一个特定 RunLoop 循环中的任何属性的变化都会被收集起来，然后做一次 0.25 秒的动画（CALayer 隐式动画）。 Note: CATransaction 支持嵌套。 Animation对于 App 用户交互体验提升最明显的工作莫过于使用动画了，那么 iOS 是如何处理动画的渲染过程的呢？ 日常开发中如果不是特别复杂的动画我们一般会使用 UIView Animation 实现，iOS 将 UIView Animation 的处理过程分为以下三个阶段： 调用 animateWithDuration:animations: 方法 在 Animation Block 中进行 Layout，Display，Prepare，Commit Render Server 根据 Animation 逐帧渲染 Note: 原理是 animateWithDuration:animations: 内部使用了 CATransaction 来将整个 Animation Block 中的代码作为原子操作 commit 给了 RunLoop。 基于 CATransaction 实现链式动画事实上大多数的动画交互都是有动画执行顺序的，尽管 UIView Animation 很强大，但是在写一些顺序动画时使用 UIView Animation 只能在 + (void)animateWithDuration:delay:options:animations:completion: 方法的 completion block 中层级嵌套，写成一坨一坨 block 堆砌而成的代码，实在是难以阅读更别提后期维护了。 在得知 UIView Animation 使用了 CATransaction 时，我们不禁会想到这个 completion block 是不是也是基于 CATransaction 实现的呢？ Bingo！CATransaction 中有 +completionBlock 以及 +setCompletionBlock: 方法可以对应于 UIView Animation 的 completion block 的书写。 Note: 我的一个开源库 LSAnimator - 可多链式动画库 在动画顺序链接时也用到了 CATransaction。 全文总结结合上下文不难梳理出一个 iOS 最基本的完整渲染经过（Rendering pass）。 性能检测思路基于整篇文章的内容归纳一下我们在日常的开发工作中遇到性能问题时检测问题代码的思路： 问题 建议 检测工具 目标帧率 60 FPS Core Animation instrument CPU or GPU 降低使用率节约能耗 Time Profiler instrument 不必要的 CPU 渲染 GPU 渲染更理想，但要清楚 CPU 渲染在何时有意义 Time Profiler instrument 过多的 offscreen passes 越少越好 Core Animation instrument 过多的 blending 越少越好 Core Animation instrument 奇怪的图片格式或大小 避免实时转换或调整大小 Core Animation instrument 开销昂贵的视图或特效 理解当前方案的开销成本 Xcode View Debugger 想象不到的层次结构 了解实际的视图层次结构 Xcode View Debugger 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~ 扩展阅读 WWDC2014-Advanced Graphics and Animations for iOS Apps iOS 保持界面流畅的技巧"},{"title":"HHKB 开箱留念","comments":true,"permalink":"https://lision.me/hhkb-bt/","text":"前言Emmmmm… 这个清明节本来打算去青海湖骑行的，不过因为北京 4 月飞雪的天气骤变加上自己没注意添衣… 最终还是没能出了帝都 ╮(╯▽╰)╭ 不过这也省下了一些开销~ 于是用本来准备出去踏青的 💰 入了一把垂涎已久的键盘，也就是本文的主角 —— HHKB 酱！ 嘛~ 知道 HHKB 是在 2015 年，记得还是在某乎的一篇回答中看到的，答主是一个妹子，大意是这个妹子偷偷看到了程序猿男票的购物车中躺着一把 HHKB，然后这个对键盘一窍不通的妹子历尽波折将 HHKB 入手送给自己程序猿男票的暖心小故事。 当时的我刚刚毕业一年左右吧，也是正想买一把键盘来敲代码，提升自己的输出（事实证明，并没有太大帮助 ^_^||），见证自己的成长（这个打油的键帽们可以证明哟）。于是就搜到了这篇回答，看得我心里一暖，无比羡慕答主男票的同时自己默默的继续浏览其他关于键盘的东西… 最后在 Filco 和 HHKB 之间纠结挣扎了许久，选择了 Filco 87 青轴奶绿配色，不过想入一把 HHKB 的种子却埋在了心里… 有了大 F 的陪伴，HHKB 的艹长得依旧很快，每次在使用 ctrl maping command 键时心里的艹都会拔高一截，尤其是最近已经到了不能不拔的地步… 所以趁着这次机会，果断入手，写篇文章记录一下自己的开箱感受，说不定对某些同学有帮助呢~ Note: 前排提示，多图预警！ 索引 HHKB 入手渠道 开箱照 手感体验 键帽 总结 HHKBHHKB 全称 Happy Hacking Keyboard，于 1996 年 12 月 20 日诞生于日本，系 富士通 旗下子公司 PFU 生产的紧凑型键盘，以逼格甚高的键盘配列、优秀流畅的敲击手感、高昂的售价为外设发烧友和码农们所熟知，亦以被 Hackers 钟爱而闻名。 关于 HHKB 的评测贴很多，这里只挑一些我认为值得聊得点来写： HHKB 的键盘配列为何如此设计？ 什么是静电容轴？ 谁捧红了 HHKB？ 标志性配列HHKB 是由日本 Hacker 和田英一 和 PFU 研究所共同设计，从名字就可以看出此系列键盘的用户定位是 Hacker，这块键盘的配列从第一代设计至今未变，可以说是 HHKB 的标志性配列。 键盘非 67 键的普通主键区小键盘传统配列，为了 Hackers 可以更好的在 Emacs 和 Vim 下使用，键盘将高频键位 —— Ctrl 上移至 Cap 处，然后砍掉了 Cap… 并默认把 Esc 键下沉至低频键位 ~ 处，同时还把 Del 键下沉至 | 键处，甚至砍掉了 67 键配列中大多数人认为高频使用的方向键！ 静电容轴HHKB 既不是大多数人用的量产薄膜键盘，也不是近些年来逐渐火热的机械键盘，而是采用了 Topre 无接触式电容开关设计。 普通薄膜键盘的触发开关是在橡胶下黏一块导电薄膜，通过这个导电薄膜触发按键开关。 机械键盘在机械轴体内部加入铜片，按键时通过机械轴体轴心挤压铜片触发按键开关。 静电容键盘通过碗状橡胶触发开关，触发原理是在按键过程中电极间距改变产生电容值变化，进而触发键盘讯号。 Note: 很多同学对机械键盘有误解，其实机械键盘轴体内部也是有弹簧的，轴体回弹也是依靠这个弹簧实现。 钟爱 HHKB 的大神 Richard Stallman，GUN Emacs &amp; GCC 大佬。 Bjarne Stroustrup，C艹 之父。 入手渠道我入手的是 HHKB Professional BT (Bluetooth) 版本，主要是看中了无线的优势，毕竟对于 Mac 来说，一个键盘占用一个 USB 接口太过奢侈了… 截止至下单时，日亚的售价是 29700 日元，约合人民币 1750 元。 某猫有一家认证过的 HHKB 官方旗舰店，售价 2388 元人民币，店铺限时活动 -200 元，加上满 200 即减 20 的满减活动，最终下单价为 2088 元。 考虑到行货保修问题，以及海淘邮寄可能出现的一些状况果断选择了国行。 开箱照嘛~ 快递没什么好说的，店家包顺丰次日达，顺丰的服务一如既往的让人满意。 清明小长假第一天就到了，开箱签收之后洗手拍照留念（笑）。 Note: 再次提示，多图预警！ 嘛~ 吐槽一下，HHKB Pro BT 的这个电池仓略丑，好在宝宝敲键盘的时候看不到它… 手感体验买之前体验了同事的 HHKB Pro Type-S 和 HHKB Pro BT，对比发现手感上并无太大偏差，不过虽然 Type-S 缩短键程没有特别明显的手感体验差异，但是静音是真的差了一个梯度。BT 版本的声音并不吵，个人感觉应该比 Filco 红轴要略小，开放式办公应该问题不大。 不过讲真，HHKB 的手感并没有网上传的那么绵软流畅，质感也差了手边 Filco 青轴一段距离，也可能是我青轴用多了吧… 具体描述的话，HHKB 的手感略柔和，没有青轴按下按键触发开关时的清脆声，整体给我的感觉有点神似红轴，但是又不像红轴那样一触到底… HHKB 和 Filco 都是信仰之物，上面的比较也是在较为苛刻的程度上我个人主观感受而已，毕竟这个价位的东西了，使用体验都会让人感到很舒服~ 在蓝牙连接状态下敲代码，完全没有误敲，重复触发以及遗漏触发的情况，个人感觉还是十分满意哈~ 键帽Emmmmm… 一开始并没有入 HHKB 的官方彩色键帽套装，理由是贵… 而且怕自己用不惯的话不方便退货。 不过在连续敲了两天键盘之后，感觉手感真的是玄学啊~ 慢慢的竟然有点喜欢 HHKB 这种静电容轴的手感了，尽管目前仍然认为不及我的大 F 青轴，但是并不排斥~ 终于在网上看了很多搭配了 HHKB 官方彩色键帽的毒图之后，下单入手！ 嘛~ 头图就是搭配了彩色键帽之后的 HHKB (＾Ｕ＾)ノ~ＹＯ 总结 HHKB 键盘配列不太适合 Windows 用户，不过非常适合 Mac OS X 下使用，一但养成肌肉记忆将会非常方便。 HHKB 手感偏绵软，给我个人的感觉还算比较舒服，但是不及大 F 青轴的手感。 HHKB Pro BT 蓝牙连接使用体验极好，没有遗漏以及重复触发按键的情况出现。 彩色键帽真的是可以瞬间提升 HHKB 极具内敛的颜值。 最后放一下已经服役了将近 3 年的大 F 和新伙伴的合影。"},{"title":"巧用 Objective-C Class Properties 解耦","comments":true,"permalink":"https://lision.me/oc_class_properties/","text":"前言Emmmmm… Objective-C Class Properties 早在 WWDC 2016 中就已经公示，给 Objective-C 加入这个特性主要是为了与 Swift 类型属性相互操作。 官方是这么说明的： Interoperate with Swift type properties. 嘛~ 虽然是为了配合 Swift 加入的新特性，不过聊胜于无哈！ Note: 值得一提的是 Objective-C Class Properties 语法特性虽然是 WWDC 2016 加入的，不过由于是 Xcode 8 中 LLVM Compiler 的特性，因此也适用于 iOS 10 之前的部署版本哟~ 索引 LLVM Objective-C Class Properties 解耦 总结 LLVM LLVM 官网 对于 LLVM 的定义： Note: The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Emmmmm… 有趣的是，有的文章把 LLVM 强行展开为 “low level virtual machine” 译为 “低级别虚拟机”，不过在 LLVM 官网 可以看到官方明示 LLVM 与传统的虚拟机没有一毛钱关系，名称 “LLVM” 本身不是缩写，它仅仅是项目的名称而已~ 嘛~ 可能有的同学不能理解为何 LLVM 是一个编译器工具链集合？这就要从 Apple 的编译器历史讲起咯~ 很久很久以前… 算了，我感觉要跑题了（囧），这里简单列一下 Apple 采用过的编译方案吧： GCC LLVM &amp; GCC LLVM Compiler GCCGCC, the GNU Compiler Collection 是一套由 GNU 开发的编程语言编译器，最初作为 GNU 操作系统 的编译器使用，后面发展成为类 Unix 操作系统以及 Apple Mac OS X 操作系统的标准编译器。 原本 GCC 仅能处理 C 语言的编译，不过 GCC 很快扩展以支持 C++，之后的 GCC 越发全面，支持 Objective-C，Fortran，Ada，以及 Go 语言。 值得一提的是 GCC 是一套以 GPL 以及 LGPL 许可证锁发行的 100% 自由软件，这意味着用户可以自由地运行，拷贝，分发，学习，修改并改进该软件。 LLVM &amp; GCCLLVM 我们前面介绍过了，是模块化 &amp; 可重用性编译器以及工具链技术集合。 LLVM 能够进行程序语言的 编译期优化、链接优化、在线编译优化、代码生成。 LLVM Compiler前面介绍过 GCC 支持很多语言，系统架构庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中顺位（优先级）较低。此外，GCC 作为一个纯粹的编译系统，在与 IDE 配合方面的表现也很差。 So，Apple 决定从零开始写 C，C++，Objective-C 的编译器 Clang。 至此，Apple 彻底与 GCC 了断。 Objective-C Class Properties Objective-C Class Properties 作为 Objective-C 新语法特性在 WWDC2016 What’s New in LLVM 中公示，表示 Xcode 8 之后可以使用这一新语法特性。 使用方式很简单： Declared with class flag Accessed with dot syntax Never synthesized Use @dynamic to defer to runtime Declared with class flag123@interface MyType : NSObject@property (class) NSString *someString;@end Accessed with dot syntax1NSLog(@&quot;format string: %@&quot;, MyType.someString); Never synthesized12345@implementation MyTypestatic NSString *_someString = nil;+ (NSString *)someString &#123; return _someString; &#125;+ (void)setSomeString:(NSString *)newString &#123; _someString = newString; &#125;@end Use @dynamic to defer to runtime123456@implementation MyType@dynamic (class) someString;+ (BOOL)resolveClassMethod:(SEL) name &#123;...&#125;@end 解耦笔者在做项目组件下沉时，遇到一个问题，正好适用于 Objective-C Class Properties 发挥：将要下沉的组件库中某系统类 Categroy 引用了业务层某方法。 业务层应该依赖于将要下沉的组件，而组件既然要下沉就不应该再反过来依赖上层业务实现！ 按照常规思路，想要把上层业务中被依赖的部分一起随组件下沉，但是发现被依赖的部分虽然也属于一个较为基础的模块，不过此模块现阶段不做下沉… 后来经过组内大佬指点，使用 Objective-C Class Properties 解决了这个问题，即将上层业务被依赖的部分化作将要下沉组件依赖方系统类 Categroy 的 Class Properties。 Note: 在 Categroy 中写 Objective-C Class Properties 需要使用 Runtime 关联方法。 总结 介绍了 LLVM 顺便提到了 Apple 的编译系统发展简史。 使用官方 Demo 简单介绍了 Objective-C Class Properties 语法特性的书写方式。 提供了一种巧妙使用 Objective-C Class Properties 解耦的思路。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"嘛~ 又一年了啊...","comments":true,"permalink":"https://lision.me/2017_2018/","text":"前言Emmmmm… 不知不觉已经一个多月没有提笔写文章了。 年前的一段时间确实比较忙，一方面想要尽可能的站好最后一班岗，把公司交给自己的事情做好；另一方面也在寻找新的机会，幸运的是在这一过程中得到了很多牛人的赏识和认可，获得了一些帮助以及内推机会，真的很感恩。 这次看机会都是在比较知名的项目或大厂中寻找的，前前后后忙碌了一个多月的时间，分别面试了头条，知乎，美团·点评，新浪，阿里巴巴这 5 家公司。 比较遗憾的是由于面试头条的时间点在 1 月 初，清楚记得元旦时期自己的三天假期基本都投入到了个人开源项目 LSAnimator 的迭代中，准备不充分加上较长时间没有参加过正式面试导致最后没能通过，辜负了彬哥的内推（囧）。 值得庆幸的是后面几家公司都如愿拿到了 offer，尤其在拿到阿里巴巴口头 offer 之后的欣喜若狂仿佛就在昨天（笑），不过由于个人原因没能加入阿里巴巴，最后选择了美团·点评核心部门的 offer。 本来想趁着春招之际把自己年前的面试经历总结一下，写一篇面试攻略。转念一想自己的博客里面还是应该记录一些自己的想法，于是才有这一篇水文出来（笑）。 嘛~ 既然是水文，就不会有什么干货在后面粗线了。想了解上述公司面试流程以及面试题的同学可以就此打住，不用再往下看了，以免浪费时间哟~ 索引 迁徙 ELSEWHERE 未来 迁徙回顾 2017 年的大事，应该就是从深圳迁徙到北京了吧… 从 14 年毕业之后就去了深圳，这一待就是 3 年，不知不觉已经对那座年轻的城市有了一些感情，一下子回到北方竟还有些舍不得。 还记得刚毕业的那段日子，住在公司提供的应届生宿舍里，与其他小伙伴吃在一起，住在一起。随后从公司宿舍搬出来，拿着仅够维持在深圳生活的工资，过着紧张而迷茫的日子。拿出自己一年多攒下的钱买了人生中第一台 Mac 和 iPhone，开始自学 iOS 开发并且第一次跳槽。 后面又经历了许许多多的第一次，也包括这次迁徙。 嘛~ 毕竟是北方长大的孩子，初来北京的感觉就是亲切，这里的建筑，植物，小吃… 一切的一切都有着久违的亲切感。 ELSEWHERE 来北京的第一份工作是在皇城根儿旁边的胡同里，一如既往的创业公司（笑），貌似除了校招去的公司是比较大的上市公司之外，自从转了 iOS 开发之后的几次选择都选了创业公司… 当时清楚记得是 CTO 亲自面试，见面的第一印象就是很亲切和善，风度翩翩。聊了聊发现公司虽然是初创团队，但是每个人的素质和背景都很出众，尤其是研发团队的综合素质很高，我一个 211 垫底大学进去的时候不敢大声说话（笑）。 半年多的工作中，兢兢业业，生怕因为自己的失误拖了整个团队的后腿，好在一直没有出什么纰漏，上级对我的工作也比较满意，在里面与各位同事相处的也很愉快… 不过好事多磨，团队内部也发生过一些摩擦，带我一起去胡同里面小学打球的两个大哥先后离职，最后我也由于种种原因离开了… 虽然相处时间算不上长，但是在 ELSEWHERE 的这段时间成长很多，与大家相处的也很愉快，特别是研发部的小伙伴们，现在还一直有来往呢。也许，下次搬家会考虑在一起合租一套大房子呢~ 这里也被我命名为 ELSEWHERE，旨在纪念这段来北京后的第一份工作，也顺便祝福 ELSEWHERE 能杀出重围，越走越远吧… 未来想自己毕业三年有余，却一事无成… 说出来自己都想笑，一直选择创业公司是因为想要改变世界… 自己当初在大学里拿到奖牌后吹过的牛逼还历历在目… 以前一直不懂为什么社会是个大染缸，现在身上已经被沾染上一些社会的颜色之后才明白这个比喻是多么的贴切而又无可奈何。时间也确实是一把利器，这才三年多的光景，就把梦想越磨越小，小到不见… 对自己说，也许现在我还没有创业的资本，等日后多些积累定要卷土重来… 对自己说，也许去大厂并非只是做一颗螺丝钉，毕竟用户量大，自己做的事情即使再小再微不足道，都是可以对用户端有些许影响的，从某种意义上讲也实现了改变人们的生活，改变了世界… 以后的事，谁又能说的准呢？只希望自己可以变得越来越强…"},{"title":"从 Aspects 源码中我学到了什么？","comments":true,"permalink":"https://lision.me/aspects/","text":"前言AOP (Aspect-oriented programming) 译为 “面向切面编程”，是通过预编译方式和运行期动态代理实现程序功能统一维护的一种技术。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 Emmmmm…AOP 目前是较为热门的一个话题，尽管你也许没有听说过它，但是你的项目中可能已经渗入了它，例如：用户统计（不添加一行代码即实现对所有 ViewController 的跟踪日志）。 对于 iOS 开发者而言，无外乎 Swift 和 Objective-C 两种主流开发语言： Swift 受限于 ABI 尚未稳定，动态性依赖 dynamic 修饰符，在 Runtime 没有留给我们太多的发挥空间（前几日新增了 swift-5.0-branch 分支，写这篇文章时看了一眼 181 commits behind master 😂）。 Objective-C 在动态性上相对 Swift 具有无限大的优势，这几年 Objective-C Runtime 相关文章多如牛毛，相信现在的 iOSer 都具备一定的 Runtime 相关知识。 Aspects 作为 Objective-C 语言编写的 AOP 库，适用于 iOS 和 Mac OS X，使用体验简单愉快，已经在 GitHub 摘得 5k+ Star。Aspects 内部实现比较健全，考虑到了 Hook 安全方面可能发生的种种问题，非常值得我们学习。 Note: 本文内引用 Aspects 源码版本为 v1.4.2，要求读者具备一定的 Runtime 知识。 索引 AOP 简介 Aspects 简介 Aspects 结构剖析 Aspects 核心代码剖析 优秀 AOP 库应该具备的特质 总结 AOP 简介 在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。 AOP (Aspect-oriented programming)，即 “面向切面编程” 是一种编程范式，或者说是一种编程思想，它解决了 OOP (Object-oriented programming) 的延伸问题。 什么时候需要使用 AOP光是给个概念可能初次接触 AOP 的人还是无法 Get 到其中微秒，拿我们前言中举的例子🌰，假设随着我们所在的公司逐步发展，之前第三方的用户页面统计已经不能满足需求了，公司要求实现一个我们自己的用户页面统计。 嘛~ 我们来理一下 OOP 思想下该怎么办？ 一个熟悉 OOP 思想的程序猿会理所应当的想到要把用户页面统计这一任务放到 ViewController 中； 考虑到一个个的手动添加统计代码要死人（而且还会漏，以后新增 ViewController 也要手动加），于是想到了 OOP 思想中的继承； 不巧由于项目久远，所有的 ViewController 都是直接继承自系统类 UIViewController（笑），此时选择抽一个项目 RootViewController，替换所有 ViewController 继承 RootViewController； 然后在 RootViewController 的 viewWillAppear: 和 viewWillDisappear: 方法加入时间统计代码，记录 ViewController 以及 Router 传参。 你会想，明明 OOP 也能解决问题是不是？不要急，再假设你们公司有多个 App，你被抽调至基础技术组专门给这些 App 写通用组件，要把之前实现过的用户页面统计重新以通用的形式实现，提供给你们公司所有的 App 使用。 MMP，使用标准 OOP 思想貌似无解啊…这个时候就是 AOP 的用武之地了。 这里简单给个思路：Hook UIViewController 的 viewWillAppear: 和 viewWillDisappear: 方法，在原方法执行之后记录需要统计的信息上报即可。 Note: 简单通过 Method Swizzling 来 Hook 不是不可以，但是有很多安全隐患！ Aspects 简介 Aspects 是一个使用起来简单愉快的 AOP 库，使用 Objective-C 编写，适用于 iOS 与 Mac OS X。 Aspects 内部实现考虑到了很多 Hook 可能引发的问题，笔者在看源码的过程中抠的比较细，真的是受益匪浅。 Aspects 简单易用，作者通过在 NSObject (Aspects) 分类中暴露出的两个接口分别提供了对实例和 Class 的 Hook 实现： 12345678910111213@interface NSObject (Aspects)+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end Aspects 支持实例 Hook，相较其他 Objective-C AOP 库而言可操作粒度更小，适合的场景更加多样化。作为使用者无需进行更多的操作即可 Hook 指定实例或者 Class 的指定 SEL，AspectOptions 参数可以指定 Hook 的点，以及是否执行一次之后就撤销 Hook。 Aspects 结构剖析 Emmmmm…尽管 Aspects 只有不到千行的源码，但是其内部实现考虑到了很多 Hook 相关的安全问题和其他细节，对比其他 Objective-C AOP 开源项目来说 Aspects 更为健全，所以我自己在扒 Aspects 源码时也看的比较仔细。 Aspects 内部结构Aspects 内部定义了两个协议： AspectToken - 用于注销 Hook AspectInfo - 嵌入 Hook 中的 Block 首位参数 此外 Aspects 内部还定义了 4 个类： AspectInfo - 切面信息，遵循 AspectInfo 协议 AspectIdentifier - 切面 ID，应该遵循 AspectToken 协议（作者漏掉了，已提 PR） AspectsContainer - 切面容器 AspectTracker - 切面跟踪器 以及一个结构体： AspectBlockRef - 即 _AspectBlock，充当内部 Block 如果你扒一遍源码，还会发现两个内部静态全局变量： static NSMutableDictionary *swizzledClassesDict; static NSMutableSet *swizzledClasses; 现在你也许还不能理解为什么要定义这么多东西，别急~ 我们后面都会分析到。 Aspects 协议按照上面列出的顺序，先来介绍一些 Aspects 声明的协议。 AspectTokenAspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook，内部规定遵守此协议的对象须实现 remove 方法。 12345678/// 不透明的 Aspect Token，用于注销 Hook@protocol AspectToken &lt;NSObject&gt;/// 注销一个 aspect./// 返回 YES 表示注销成功，否则返回 NO- (BOOL)remove;@end AspectInfoAspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，我们在 Hook 时添加切面的 Block 第一个参数就遵守此协议。 12345678910111213/// AspectInfo 协议是我们块语法的第一个参数。@protocol AspectInfo &lt;NSObject&gt;/// 当前被 Hook 的实例- (id)instance;/// 被 Hook 方法的原始 invocation- (NSInvocation *)originalInvocation;/// 所有方法参数（装箱之后的）惰性执行- (NSArray *)arguments;@end Note: 装箱是一个开销昂贵操作，所以用到再去执行。 Aspects 内部类接着协议，我们下面详细介绍一下 Aspects 的内部类。 AspectInfo Note: AspectInfo 在这里是一个 Class，其遵守上文中讲到的 AspectInfo 协议，不要混淆。 AspectInfo 类定义： 123456789@interface AspectInfo : NSObject &lt;AspectInfo&gt;- (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;@property (nonatomic, unsafe_unretained, readonly) id instance;@property (nonatomic, strong, readonly) NSArray *arguments;@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;@end Note: 关于装箱，对于提供一个 NSInvocation 就可以拿到其 arguments 这一点上，ReactiveCocoa 团队提供了很大贡献（细节见 Aspects 内部 NSInvocation 分类）。 AspectInfo 比较简单，参考 ReactiveCocoa 团队提供的 NSInvocation 参数通用方法可将参数装箱为 NSValue，简单来说 AspectInfo 扮演了一个提供 Hook 信息的角色。 AspectIdentifierAspectIdentifier 类定义： 12345678910111213@interface AspectIdentifier : NSObject+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) id block;@property (nonatomic, strong) NSMethodSignature *blockSignature;@property (nonatomic, weak) id object;@property (nonatomic, assign) AspectOptions options;@end Note: AspectIdentifier 实际上是添加切面的 Block 的第一个参数，其应该遵循 AspectToken 协议，事实上也的确如此，其提供了 remove 方法的实现。 AspectIdentifier 内部需要注意的是由于使用 Block 来写 Hook 中我们加的料，这里生成了 blockSignature，在 AspectIdentifier 初始化的过程中会去判断 blockSignature 与入参 object 的 selector 得到的 methodSignature 的兼容性，兼容性判断成功才会顺利初始化。 AspectsContainerAspectsContainer 类定义： 1234567891011@interface AspectsContainer : NSObject- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;- (BOOL)removeAspect:(id)aspect;- (BOOL)hasAspects;@property (atomic, copy) NSArray *beforeAspects;@property (atomic, copy) NSArray *insteadAspects;@property (atomic, copy) NSArray *afterAspects;@end AspectsContainer 作为切面的容器类，关联指定对象的指定方法，内部有三个切面队列，分别容纳关联指定对象的指定方法中相对应 AspectOption 的 Hook： NSArray *beforeAspects; - AspectPositionBefore NSArray *insteadAspects; - AspectPositionInstead NSArray *afterAspects; - AspectPositionAfter 为什么要说关联呢？因为 AspectsContainer 是在 NSObject 分类中通过 AssociatedObject 方法与当前要 Hook 的目标关联在一起的。 Note: 关联目标是 Hook 之后的 Selector，即 aliasSelector（原始 SEL 名称加 aspects_ 前缀对应的 SEL）。 AspectTrackerAspectTracker 类定义： 123456789@interface AspectTracker : NSObject- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;@property (nonatomic, strong) Class trackedClass;@property (nonatomic, strong) NSMutableSet *selectorNames;@property (nonatomic, weak) AspectTracker *parentEntry;@end AspectTracker 作为切面追踪器，原理大致如下： 12345678910111213// Add the selector as being modified.currentClass = klass;AspectTracker *parentTracker = nil;do &#123; AspectTracker *tracker = swizzledClassesDict[currentClass]; if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker]; swizzledClassesDict[(id&lt;NSCopying&gt;)currentClass] = tracker; &#125; [tracker.selectorNames addObject:selectorName]; // All superclasses get marked as having a subclass that is modified. parentTracker = tracker;&#125;while ((currentClass = class_getSuperclass(currentClass))); Note: 聪明的你应该已经注意到了全局变量 swizzledClassesDict 中的 value 对应着 AspectTracker 指针。 嘛~ 就是说 AspectTracker 是从下而上追踪，最底层的 parentEntry 为 nil，父类的 parentEntry 为子类的 tracker。 Aspects 内部结构体AspectBlockRefAspectBlockRef，即 struct _AspectBlock，其定义如下： 1234567891011121314151617typedef struct _AspectBlock &#123; __unused Class isa; AspectBlockFlags flags; __unused int reserved; void (__unused *invoke)(struct _AspectBlock *block, ...); struct &#123; unsigned long int reserved; unsigned long int size; // requires AspectBlockFlagsHasCopyDisposeHelpers void (*copy)(void *dst, const void *src); void (*dispose)(const void *); // requires AspectBlockFlagsHasSignature const char *signature; const char *layout; &#125; *descriptor; // imported variables&#125; *AspectBlockRef; Emmmmm…没什么特别的，大家应该比较眼熟吧。 Note: __unused 宏定义实际上是 __attribute__((unused)) GCC 定语，旨在告诉编译器“如果我没有在后面使用到这个变量也别警告我”。 嘛~ 想起之前自己挖的坑还没有填，事实上自己也不知道什么时候填（笑）： 之前挖坑说要写一篇文章记录一些阅读源码时发现的代码书写技巧 之前挖坑说要封装一个 WKWebView 给群里的兄弟参考 不要急~ 你瞧伦家不是都记得嘛（至于什么时候填坑嘛就…咳咳） Aspects 静态全局变量static NSMutableDictionary *swizzledClassesDict;static NSMutableDictionary *swizzledClassesDict; 在 Aspects 中扮演着已混写类字典的角色，其内部结构应该是这样的： 1&lt;Class : AspectTracker *&gt; Aspects 内部提供了专门访问这个全局字典的方法： 12345678static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123; static NSMutableDictionary *swizzledClassesDict; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClassesDict = [NSMutableDictionary new]; &#125;); return swizzledClassesDict;&#125; 这个全局变量可以简单理解为记录整个 Hook 影响的 Class 包含其 SuperClass 的追踪记录的全局字典。 static NSMutableSet *swizzledClasses;static NSMutableSet *swizzledClasses; 在 Aspects 中担当记录已混写类的角色，其内部结构如下： 1&lt;NSStringFromClass(Class)&gt; Aspects 内部提供一个用于修改这个全局变量内容的方法： 12345678910static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) &#123; static NSMutableSet *swizzledClasses; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClasses = [NSMutableSet new]; &#125;); @synchronized(swizzledClasses) &#123; block(swizzledClasses); &#125;&#125; Note: 注意 @synchronized(swizzledClasses)。 这个全局变量记录了 forwardInvocation: 被混写的的类名称。 Note: 注意在用途上与 static NSMutableDictionary *swizzledClassesDict; 区分理解。 Aspects 核心代码剖析 嘛~ Aspects 的整体实现代码不超过一千行，而且考虑的情况也比较全面，非常值得大家花时间去读一下，这里我只准备给出自己对其核心代码的理解。 Hook Class &amp;&amp; Hook InstanceAspects 不光支持 Hook Class 还支持 Hook Instance，这提供了更小粒度的控制，配合 Hook 的撤销功能可以更加灵活精准的做我们想做的事~ Aspects 为了能区别 Class 和 Instance 的逻辑，实现了名为 aspect_hookClass 的方法，我认为其中的实现值得我用一部分篇幅来单独讲解，也觉得读者们有必要花点时间理解这里的实现逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static Class aspect_hookClass(NSObject *self, NSError **error) &#123; // 断言 self NSCParameterAssert(self); // class Class statedClass = self.class; // isa Class baseClass = object_getClass(self); NSString *className = NSStringFromClass(baseClass); // 已经子类化过了 if ([className hasSuffix:AspectsSubclassSuffix]) &#123; return baseClass; // 我们混写了一个 class 对象，而非一个单独的 object &#125;else if (class_isMetaClass(baseClass)) &#123; // baseClass 是元类，则 self 是 Class 或 MetaClass，混写 self return aspect_swizzleClassInPlace((Class)self); // 可能是一个 KVO&#x27;ed class。混写就位。也要混写 meta classes。 &#125;else if (statedClass != baseClass) &#123; // 当 .class 和 isa 指向不同的情况，混写 baseClass return aspect_swizzleClassInPlace(baseClass); &#125; // 默认情况下，动态创建子类 // 拼接子类后缀 AspectsSubclassSuffix const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; // 尝试用拼接后缀的名称获取 isa Class subclass = objc_getClass(subclassName); // 找不到 isa，代表还没有动态创建过这个子类 if (subclass == nil) &#123; // 创建一个 class pair，baseClass 作为新类的 superClass，类名为 subclassName subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) &#123; // 返回 nil，即创建失败 NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 混写 forwardInvocation: aspect_swizzleForwardInvocation(subclass); // subClass.class = statedClass aspect_hookedGetClass(subclass, statedClass); // subClass.isa.class = statedClass aspect_hookedGetClass(object_getClass(subclass), statedClass); // 注册新类 objc_registerClassPair(subclass); &#125; // 覆盖 isa object_setClass(self, subclass); return subclass;&#125; Note: 其实这里的难点就在于对 .class 和 object_getClass 的区分。 .class 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身 object_getClass 返回 isa 指针的指向 Note: 动态创建一个 Class 的完整步骤也是我们应该注意的。 objc_allocateClassPair class_addMethod class_addIvar objc_registerClassPair 嘛~ 难点和重点都讲完了，大家结合注释理解其中的逻辑应该没什么困难了，有什么问题可以找我一起交流~ Hook 的实现在上面 aspect_hookClass 方法中，不仅仅是返回一个要 Hook 的 Class，期间还做了一些细节操作，不论是 Class 还是 Instance，都会调用 aspect_swizzleForwardInvocation 方法，这个方法没什么难点，简单贴一下代码让大家有个印象： 123456789101112static void aspect_swizzleForwardInvocation(Class klass) &#123; // 断言 klass NSCParameterAssert(klass); // 如果没有 method，replace 实际上会像是 class_addMethod 一样 IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, &quot;v@:@&quot;); // 拿到 originalImplementation 证明是 replace 而不是 add，情况少见 if (originalImplementation) &#123; // 添加 AspectsForwardInvocationSelectorName 的方法，IMP 为原生 forwardInvocation: class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;); &#125; AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));&#125; 上面的方法就是把要 Hook 的目标 Class 的 forwardInvocation: 混写了，混写之后 forwardInvocation: 的具体实现在 __ASPECTS_ARE_BEING_CALLED__ 中，里面能看到 invoke 标识位的不同是如何实现的，还有一些其他的实现细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 宏定义，以便于我们有一个更明晰的 stack trace#define aspect_invoke(aspects, info) \\for (AspectIdentifier *aspect in aspects) &#123;\\ [aspect invokeWithInfo:info];\\ if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \\ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\ &#125; \\&#125;static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; // __unsafe_unretained NSObject *self 不解释了 // 断言 self, invocation NSCParameterAssert(self); NSCParameterAssert(invocation); // 从 invocation 可以拿到很多东西，比如 originalSelector SEL originalSelector = invocation.selector; // originalSelector 加前缀得到 aliasSelector SEL aliasSelector = aspect_aliasForSelector(invocation.selector); // 用 aliasSelector 替换 invocation.selector invocation.selector = aliasSelector; // Instance 的容器 AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); // Class 的容器 AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; // 如果有任何 insteadAspects 就直接替换了 aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; // 否则正常执行 // 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // 如果没有 hook，则执行原始实现（通常会抛出异常） if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); // 如果可以响应 originalForwardInvocationSEL，表示之前是 replace method 而非 add method if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // 移除 aspectsToRemove 队列中的 AspectIdentifier，执行 remove [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125;#undef aspect_invoke Note: aspect_invoke 宏定义的作用域。 代码实现对应了 Hook 的 AspectOptions 参数的 Before，Instead 和 After。 aspect_invoke 中 aspectsToRemove 是一个 NSArray，里面容纳着需要被销户的 Hook，即 AspectIdentifier（之后会调用 remove 移除）。 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke 实现代码。 Block HookAspects 让我们在指定 Class 或 Instance 的特定 Selector 执行时，根据 AspectOptions 插入我们自己的 Block 做 Hook，而这个 Block 内部有我们想要的有关于当前 Target 和 Selector 的信息，我们来看一下 Aspects 是怎么办到的： 123456789101112131415161718192021222324252627282930313233343536373839404142- (BOOL)invokeWithInfo:(id&lt;AspectInfo&gt;)info &#123; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // 偏执。我们已经在 hook 注册的时候检查过了，（不过这里我们还要检查）。 if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@&quot;Block has too many arguments. Not calling %@&quot;, info); return NO; &#125; // block 的 `self` 将会是 AspectInfo。可选的。 if (numberOfArguments &gt; 1) &#123; [blockInvocation setArgument:&amp;info atIndex:1]; &#125; // 简历参数分配内存 argBuf 然后从 originalInvocation 取 argument 赋值给 blockInvocation void *argBuf = NULL; for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx]; NSUInteger argSize; NSGetSizeAndAlignment(type, &amp;argSize, NULL); // reallocf 优点，如果创建内存失败会自动释放之前的内存，讲究 if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@&quot;Failed to allocate memory for block invocation.&quot;); return NO; &#125; [originalInvocation getArgument:argBuf atIndex:idx]; [blockInvocation setArgument:argBuf atIndex:idx]; &#125; // 执行 [blockInvocation invokeWithTarget:self.block]; // 释放 argBuf if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 考虑两个问题： [blockInvocation setArgument:&amp;info atIndex:1]; 为什么要在索引 1 处插入呢？ for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) 为什么要从索引 2 开始遍历参数呢？ 嘛~ 如果你对 Block 的 Runtime 结构以及执行过程下断点研究一下就全都明白了，感兴趣的同学有疑问可以联系我（与真正勤奋好学的人交流又有谁会不乐意呢？笑~） 优秀 AOP 库应该具备的特质 良好的使用体验 可控粒度小 使用 Block 做 Hook 支持撤销 Hook 安全性 良好的使用体验Aspects 使用 NSObject + Categroy 的方式提供接口，非常巧妙的涵盖了 Instance 和 Class。 Aspects 提供的接口保持高度一致（本着易用，简单，方便的原则设计接口和整个框架的实现会让你的开源项目更容易被人们接纳和使用）： 123456789+ (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; Note: 其实接口这里对于 block 的参数自动补全可以更进一步，不过 Aspects 当初是没有办法做到的，单从接口设计这块已经很优秀了。 可控粒度小Aspects 不仅支持大部分 AOP 框架应该做到的对于 Class 的 Hook，还支持粒度更小的 Instance Hook，而其在内部实现中为了支持 Instance Hook 所做的代码也非常值得我们参考和学习（已在上文 Aspects 核心代码剖析 处单独分析）。 为使用者提供更为自由的 Hook 方式以达到更加精准的控制是每个使用者乐于见到的事。 使用 Block 做 HookAspects 使用 Block 来做 Hook 应该考虑到了很多东西，支持使用者通过在 Block 中获取到相关的信息，书写自己额外的操作就可以实现 Hook 需求。 支持撤销 HookAspects 还支持撤销之前做的 Hook 以及已混写的 Method，为了实现这个功能 Aspects 设计了全局容器，把 Hook 和混写用全局容器做记录，让一切都可以复原，这不正是我们想要的吗？ 安全性嘛~ 我们在学习 Runtime 的时候，就应该看到过不少文章讲解 Method Swizzling 要注意的安全性问题，由于用到了大量 Runtime 方法，加上 AOP 是面向整个切面的，所以一单发现问题就会比较严重，涉及的面会比较广，而且难以调试。 Note: 我们不能因为容易造成问题就可以回避 Method Swizzling，就好比大学老师讲到递归时强调容易引起循环调用，很多人就在内心回避使用递归，甚至于非常适合使用递归来写的算法题（这里指递归来写会易读写、易维护）只会用复杂的方式来思考。 总结 文章简单介绍了 AOP 的概念，希望能给各位读者对 AOP 思想的理解提供微薄的帮助。 文章系统的剖析了 Aspects 开源库的内部结构，希望能让大家在浏览 Aspects 源码时快速定位代码位置，找到核心内容。 文章重点分析了 Aspects 的核心代码，提炼了一些笔者认为值得注意的点，但愿可以在大家扒源码时提供一些指引。 文章结尾总结了 Aspects 作为一个比较优秀的 AOP 所具备的一些特质。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"深入剖析 WebViewJavascriptBridge","comments":true,"permalink":"https://lision.me/webview_javascript_bridge/","text":"Emmmmm…这篇文章发布出来可能正逢圣诞节🎄，Merry Christmas! 前言Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而 JS 和 iOS Native 就好比两块没有交集的大陆，如果想要使它们相互通信就必须要建立一座“桥梁”。 思考一下，如果项目组让你去造这座“桥”，如何才能做到既优雅又实用？ 本文将结合 WebViewJavascriptBridge 源码逐步带大家找到答案。 WebViewJavascriptBridge 是盛名已久的 JSBridge 库，早在 2011 年就被作者 Marcus Westin 发布到 GitHub，直到现在作者还在积极维护中，目前该项目已收获近 1w star 咯，其源码非常值得我们学习。 WebViewJavascriptBridge 的代码逻辑清晰，风格良好，加上自身代码量比较小使得其源码阅读非常轻松（可能需要一些 JS 基础）。更加难能可贵的是它仅使用了少量代码就实现了对于 Mac OS X 的 WebView 以及 iOS 平台的 UIWebView 和 WKWebView 三种组件的完美支持。 我对 WebViewJavascriptBridge 的评价是小而美，这类小而美的源码非常利于我们对其实现思想的学习（本文分析 WebViewJavascriptBridge 源码版本为 v6.0.3）。 关于 iOS 与 JS 的原生交互知识，之前我有写过一篇文章《iOS 与 JS 交互开发知识总结》，文章除了介绍 JavaScriptCore 库以及 UIWebView 和 WKWebView 与 JS 原生交互的方法之外还捎带提到了 Hybrid 的发展简史，文末还提供了一个 JS 通过 Native 调用 iOS 设备摄像头的 Demo。 所以这篇文章不会再把重点放在 iOS 与 JS 的原生交互了，本文旨在介绍 WebViewJavascriptBridge 的设计思路和实现原理，对 iOS 与 JS 原生交互知识感兴趣的同学推荐去阅读上面提到的文章，应该会有点儿帮助（笑）。 索引 WebViewJavascriptBridge 简介 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究 WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析 WebViewJavascriptBridge_JS - Native 调用 JS 实现解读 WebViewJavascriptBridge 的“桥梁美学” 文章总结 WebViewJavascriptBridge 简介 WebViewJavascriptBridge 是用于在 WKWebView，UIWebView 和 WebView 中的 Obj-C 和 JavaScript 之间发送消息的 iOS / OSX 桥接器。 有许多不错的项目都有使用 WebViewJavascriptBridge，这里简单列一部分（笑）： Facebook Messenger Facebook Paper ELSEWHERE … &amp; many more! 关于 WebViewJavascriptBridge 的具体使用方法详见其 GitHub 页面。 在读完 WebViewJavascriptBridge 的源码之后我将其划分为三个层级： 层级 源文件 接口层 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 实现层 WebViewJavascriptBridgeBase JS 层 WebViewJavascriptBridge_JS 其中 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 作为接口层主要负责提供方便的接口，隐藏实现细节，其实现细节都是通过实现层 WebViewJavascriptBridgeBase 去做的，而 WebViewJavascriptBridge_JS 作为 JS 层其实存储了一段 JS 代码，在需要的时候注入到当前 WebView 组件中，最终实现 Native 与 JS 的交互。 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究 WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 作为接口层分别对应于 UIWebView 和 WKWebView 组件，我们来简单看一下这两个文件暴露出的信息： WebViewJavascriptBridge 暴露信息： 123456789101112131415@interface WebViewJavascriptBridge : WVJB_WEBVIEW_DELEGATE_INTERFACE+ (instancetype)bridgeForWebView:(id)webView; // 初始化+ (instancetype)bridge:(id)webView; // 初始化+ (void)enableLogging; // 开启日志+ (void)setLogMaxLength:(int)length; // 设置日志最大长度- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler; // 注册 handler (Native)- (void)removeHandler:(NSString*)handlerName; // 删除 handler (Native)- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback; // 调用 handler (JS)- (void)setWebViewDelegate:(id)webViewDelegate; // 设置 webViewDelegate- (void)disableJavscriptAlertBoxSafetyTimeout; // 禁用 JS AlertBox 的安全时长来加速消息传递，不推荐使用@end WKWebViewJavascriptBridge 暴露信息： 1234567891011121314// Emmmmm...这里应该不需要我注释了吧@interface WKWebViewJavascriptBridge : NSObject&lt;WKNavigationDelegate, WebViewJavascriptBridgeBaseDelegate&gt;+ (instancetype)bridgeForWebView:(WKWebView*)webView;+ (void)enableLogging;- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler;- (void)removeHandler:(NSString*)handlerName;- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;- (void)reset;- (void)setWebViewDelegate:(id)webViewDelegate;- (void)disableJavscriptAlertBoxSafetyTimeout;@end Note: disableJavscriptAlertBoxSafetyTimeout 方法是通过禁用 JS 端 AlertBox 的安全时长来加速网桥消息传递的。如果想使用那么需要和前端约定好，如果禁用之后前端 JS 代码仍有调用 AlertBox 相关代码（alert, confirm, 或 prompt）则程序将被挂起，所以这个方法是不安全的，如无特殊需求笔者不推荐使用。 可以看得出来这两个文件暴露出的接口几乎一致，其中 WebViewJavascriptBridge 中使用了宏定义 WVJB_WEBVIEW_DELEGATE_INTERFACE 来分别适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件需要实现的代理方法。 WebViewJavascriptBridge 中的宏定义其实 WebViewJavascriptBridge 中为了适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件使用了一系列的宏定义，其源码比较简单： 123456789101112#if defined __MAC_OS_X_VERSION_MAX_ALLOWED #define WVJB_PLATFORM_OSX #define WVJB_WEBVIEW_TYPE WebView #define WVJB_WEBVIEW_DELEGATE_TYPE NSObject&lt;WebViewJavascriptBridgeBaseDelegate&gt; #define WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject&lt;WebViewJavascriptBridgeBaseDelegate, WebPolicyDelegate&gt;#elif defined __IPHONE_OS_VERSION_MAX_ALLOWED #import &lt;UIKit/UIWebView.h&gt; #define WVJB_PLATFORM_IOS #define WVJB_WEBVIEW_TYPE UIWebView #define WVJB_WEBVIEW_DELEGATE_TYPE NSObject&lt;UIWebViewDelegate&gt; #define WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject&lt;UIWebViewDelegate, WebViewJavascriptBridgeBaseDelegate&gt;#endif 分别根据所在平台不同定义了 WVJB_WEBVIEW_TYPE，WVJB_WEBVIEW_DELEGATE_TYPE 以及刚才提到的 WVJB_WEBVIEW_DELEGATE_INTERFACE 宏定义，并且分别定义了 WVJB_PLATFORM_OSX 和 WVJB_PLATFORM_IOS 便于之后的实现源码区分当前平台时使用，下面的 supportsWKWebView 宏定义也是同样的道理： 123#if (__MAC_OS_X_VERSION_MAX_ALLOWED &gt; __MAC_10_9 || __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_7_1)#define supportsWKWebView#endif 在引入头文件的时候可以通过这个 supportsWKWebView 宏灵活引入所需的头文件： 123456789// WebViewJavascriptBridge.h#if defined supportsWKWebView#import &lt;WebKit/WebKit.h&gt;#endif// WebViewJavascriptBridge.m#if defined(supportsWKWebView)#import &quot;WKWebViewJavascriptBridge.h&quot;#endif WebViewJavascriptBridge 的实现分析我们接着看一下 WebViewJavascriptBridge 的实现部分，首先从内部变量信息看起： 123456789101112#if __has_feature(objc_arc_weak) #define WVJB_WEAK __weak#else #define WVJB_WEAK __unsafe_unretained#endif@implementation WebViewJavascriptBridge &#123; WVJB_WEAK WVJB_WEBVIEW_TYPE* _webView; // bridge 对应的 WebView 组件 WVJB_WEAK id _webViewDelegate; // 给 WebView 组件设置的代理（需要的话） long _uniqueId; // 唯一标识，Emmmmm...但是我发现没卵用，只有 _base 中的 _uniqueId 才有用 WebViewJavascriptBridgeBase *_base; // 上文说过，底层实现其实都是 WebViewJavascriptBridgeBase 在做&#125; 上文提到 WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 的 .h 文件暴露接口信息非常相似，那么我们要不要看看 WKWebViewJavascriptBridge 的内部变量信息呢？ 1234567// 注释参见 WebViewJavascriptBridge 就好@implementation WKWebViewJavascriptBridge &#123; __weak WKWebView* _webView; __weak id&lt;WKNavigationDelegate&gt; _webViewDelegate; long _uniqueId; WebViewJavascriptBridgeBase *_base;&#125; 嘛~ 这俩货简直是一个妈生的。其实这是作者故意为之，因为作者想对外提供一套接口，即 WebViewJavascriptBridge，我们只需要使用 WebViewJavascriptBridge 就可以自动根据绑定的 WebView 组件的不同生成与之对应的 JSBridge 实例。 123456789101112131415161718192021+ (instancetype)bridge:(id)webView &#123;// 如果支持 WKWebView#if defined supportsWKWebView // 需要先判断当前入参 webView 是否从属于 WKWebView if ([webView isKindOfClass:[WKWebView class]]) &#123; // 返回 WKWebViewJavascriptBridge 实例 return (WebViewJavascriptBridge*) [WKWebViewJavascriptBridge bridgeForWebView:webView]; &#125;#endif // 判断当前入参 webView 是否从属于 WebView（Mac OS X）或者 UIWebView（iOS） if ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE class]]) &#123; // 返回 WebViewJavascriptBridge 实例 WebViewJavascriptBridge* bridge = [[self alloc] init]; [bridge _platformSpecificSetup:webView]; return bridge; &#125; // 抛出 BadWebViewType 异常并返回 nil [NSException raise:@&quot;BadWebViewType&quot; format:@&quot;Unknown web view type.&quot;]; return nil;&#125; 我们可以看到上面的代码，实现并不复杂。如果支持 WKWebView 的话（#if defined supportsWKWebView）则去判断当前绑定的 WebView 组件是否从属于 WKWebView，这样可以返回 WKWebViewJavascriptBridge 实例，否则返回 WebViewJavascriptBridge 实例，最后如果入参 webView 的类型不满足判断条件则抛出 BadWebViewType 异常。 还有一个关于 _webViewDelegate 的小细节，本来不打算讲的，但是还是提一下吧（囧）。其实在 WebViewJavascriptBridge 以及 WKWebViewJavascriptBridge 的初始化实现过程中，会把当前 WebView 组件的代理绑定为自己： 123456789101112131415// WebViewJavascriptBridge- (void) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &#123; _webView = webView; _webView.delegate = self; _base = [[WebViewJavascriptBridgeBase alloc] init]; _base.delegate = self;&#125;// WKWebViewJavascriptBridge- (void) _setupInstance:(WKWebView*)webView &#123; _webView = webView; _webView.navigationDelegate = self; _base = [[WebViewJavascriptBridgeBase alloc] init]; _base.delegate = self;&#125; Note: 替换组件的代理将其代理绑定为 bridge 自己是因为 WebViewJavascriptBridge 的实现原理上是利用我之前的文章《iOS 与 JS 交互开发知识总结》中讲过的假 Request 方法实现的，所以需要监听 WebView 组件的代理方法获取加载之前的 Request.URL 并做处理。这也是为什么 WebViewJavascriptBridge 提供了一个接口 setWebViewDelegate: 存储了一个逻辑上的 _webViewDelegate，这个 _webViewDelegate 也需要遵循 WebView 组件的代理协议，这样在 WebViewJavascriptBridge 内部不同的代理方法中做完 bridge 要做的事情只有就会再去调用 _webViewDelegate 对应的代理方法，其实可以理解为 WebViewJavascriptBridge 对当前 WebView 组件的代理做了 hook。 对于 WebViewJavascriptBridge 中暴露的初始化以外的所有接口，其内部实现都是通过 WebViewJavascriptBridgeBase 来实现的。这样做的好处就是即使 WebViewJavascriptBridge 因为绑定了 WKWebView 返回了 WKWebViewJavascriptBridge 实例，只要接口一致，对 JSBridge 发送相同的消息，就会有相同的实现（都是由 WebViewJavascriptBridgeBase 类实现的）。 WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析 作为 WebViewJavascriptBridge 的实现层，WebViewJavascriptBridgeBase 的命名也可以体现出其是作为整座“桥梁”桥墩一般的存在，我们还是按照老规矩先看一下 WebViewJavascriptBridgeBase.h 暴露的信息，好对其有一个整体的印象： 12345678910111213141516171819202122232425262728293031typedef void (^WVJBResponseCallback)(id responseData); // 回调 blocktypedef void (^WVJBHandler)(id data, WVJBResponseCallback responseCallback); // 注册的 Handler blocktypedef NSDictionary WVJBMessage; // 消息类型 - 字典@protocol WebViewJavascriptBridgeBaseDelegate &lt;NSObject&gt;- (NSString*) _evaluateJavascript:(NSString*)javascriptCommand;@end@interface WebViewJavascriptBridgeBase : NSObject@property (weak, nonatomic) id &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate; // 代理，指向接口层类，用以给对应接口绑定的 WebView 组件发送执行 JS 消息@property (strong, nonatomic) NSMutableArray* startupMessageQueue; // 启动消息队列，可以理解为存放 WVJBMessage@property (strong, nonatomic) NSMutableDictionary* responseCallbacks; // 回调 blocks 字典，存放 WVJBResponseCallback 类型的 block@property (strong, nonatomic) NSMutableDictionary* messageHandlers; // 已注册的 handlers 字典，存放 WVJBHandler 类型的 block@property (strong, nonatomic) WVJBHandler messageHandler; // 没卵用+ (void)enableLogging; // 开启日志+ (void)setLogMaxLength:(int)length; // 设置日志最大长度- (void)reset; // 对应 WKJSBridge 的 reset 接口- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName; // 发送消息，入参依次是参数，回调 block，对应 JS 端注册的 HandlerName- (void)flushMessageQueue:(NSString *)messageQueueString; // 刷新消息队列，核心代码- (void)injectJavascriptFile; // 注入 JS- (BOOL)isWebViewJavascriptBridgeURL:(NSURL*)url; // 判定是否为 WebViewJavascriptBridgeURL- (BOOL)isQueueMessageURL:(NSURL*)urll; // 判定是否为队列消息 URL- (BOOL)isBridgeLoadedURL:(NSURL*)urll; // 判定是否为 bridge 载入 URL- (void)logUnkownMessage:(NSURL*)url; // 打印收到未知消息信息- (NSString *)webViewJavascriptCheckCommand; // JS bridge 检测命令- (NSString *)webViewJavascriptFetchQueyCommand; // JS bridge 获取查询命令- (void)disableJavscriptAlertBoxSafetyTimeout; // 禁用 JS AlertBox 安全时长以获取发送消息速度提升，不建议使用，理由见上文@end 嘛~ 从 .h 文件中我们可以看到整个 WebViewJavascriptBridgeBase 所暴露出来的信息，属性层面上需要对以下 4 个属性加深印象，之后分析实现的过程中会带入这些属性： id &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate 代理，可以通过代理让当前 bridge 绑定的 WebView 组件执行 JS 代码 NSMutableArray* startupMessageQueue; 启动消息队列，存放 Obj-C 发送给 JS 的消息（可以理解为存放 WVJBMessage 类型） NSMutableDictionary* responseCallbacks; 回调 blocks 字典，存放 WVJBResponseCallback 类型的 block NSMutableDictionary* messageHandlers; Obj-C 端已注册的 handlers 字典，存放 WVJBHandler 类型的 block Emmmmm…接口层面看一下注释就好了，后面分析实现的时候会捎带讲解一些接口，剩下一些跟实现无关的接口内容感兴趣的同学推荐自己扒源码哈。 我们在对 WebViewJavascriptBridgeBase 整体有了一个初始印象之后就可以自己写一个页面，简单的嵌入一些 JS 跑一遍流程，在中间下断点扒源码，这样我们对于 Native 与 JS 的交互流程就可以一清二楚了。 下面模拟一遍 JS 通过 WebViewJavascriptBridge 调用 Native 功能的流程分析 WebViewJavascriptBridgeBase 的相关实现（考虑现在的时间点决定以 WKWebView 为例讲解，即针对 WKWebViewJavascriptBridge 源码讲解）： 1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码上文说到 WebViewJavascriptBridge 的实现其实本质上是利用了我之前的文章《iOS 与 JS 交互开发知识总结》中讲过的假 Request 方法实现的，那么我们就从监听假 Request 开始讲起吧。 123456789101112131415161718192021222324252627282930// WKNavigationDelegate 协议方法，用于监听 Request 并决定是否允许导航- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; // webView 校验 if (webView != _webView) &#123; return; &#125; NSURL *url = navigationAction.request.URL; __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate; // 核心代码 if ([_base isWebViewJavascriptBridgeURL:url]) &#123; // 判定 WebViewJavascriptBridgeURL if ([_base isBridgeLoadedURL:url]) &#123; // 判定 BridgeLoadedURL // 注入 JS 代码 [_base injectJavascriptFile]; &#125; else if ([_base isQueueMessageURL:url]) &#123; // 判定 QueueMessageURL // 刷新消息队列 [self WKFlushMessageQueue]; &#125; else &#123; // 记录未知 bridge msg 日志 [_base logUnkownMessage:url]; &#125; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; // 调用 _webViewDelegate 对应的代理方法 if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) &#123; [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler]; &#125; else &#123; decisionHandler(WKNavigationActionPolicyAllow); &#125;&#125; Note: 之前说过 WebViewJavascriptBridge 会 hook 绑定的 WebView 的代理方法，这一点 WKWebViewJavascriptBridge 也一样，在加入自己的代码之后会判断是否有 _webViewDelegate 响应这个代理方法，如果有则调用。 我们还是把注意力放到注释中核心代码的位置，里面会先判断当前 url 是否为 bridge url： 12345// 相关宏定义#define kOldProtocolScheme @&quot;wvjbscheme&quot;#define kNewProtocolScheme @&quot;https&quot;#define kQueueHasMessage @&quot;__wvjb_queue_message__&quot;#define kBridgeLoaded @&quot;__bridge_loaded__&quot; WebViewJavascriptBridge GitHub 页面 的使用方法中第 4 步明确指出要复制粘贴 setupWebViewJavascriptBridge 方法到前段 JS 中，我们先来看一下这段 JS 方法源码： 1234567891011121314function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; // 创建一个 iframe var WVJBIframe = document.createElement(&#x27;iframe&#x27;); // 设置 iframe 为不显示 WVJBIframe.style.display = &#x27;none&#x27;; // 将 iframe 的 src 置为 &#x27;https://__bridge_loaded__&#x27; WVJBIframe.src = &#x27;https://__bridge_loaded__&#x27;; // 将 iframe 加入到 document.documentElement document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 上面的代码创建了一个不显示的 iframe 并将其 src 置为 https://__bridge_loaded__，与上文中 kBridgeLoaded 宏定义一致，即用于 isBridgeLoadedURL: 方法中判定当前 url 是否为 BridgeLoadedURL。 Note: 假 Request 的发起有两种方式，-1:location.href -2:iframe。通过 location.href 有个问题，就是如果 JS 多次调用原生的方法也就是 location.href 的值多次变化，Native 端只能接受到最后一次请求，前面的请求会被忽略掉，所以这里 WebViewJavascriptBridge 选择使用 iframe，后面不再解释。 因为加入了 src 为 https://__bridge_loaded__ 的 iframe 元素，我们上面截获 url 的代理方法就会拿到一个 https://__bridge_loaded__ 的 url，由于 https 满足判定 WebViewJavascriptBridgeURL，将会进入核心代码区域接着会被判定为 BridgeLoadedURL 执行注入 JS 代码的方法，即 [_base injectJavascriptFile];。 1234567891011121314- (void)injectJavascriptFile &#123; // 获取到 WebViewJavascriptBridge_JS 的代码 NSString *js = WebViewJavascriptBridge_js(); // 将获取到的 js 通过代理方法注入到当前绑定的 WebView 组件 [self _evaluateJavascript:js]; // 如果当前已有消息队列则遍历并分发消息，之后清空消息队列 if (self.startupMessageQueue) &#123; NSArray* queue = self.startupMessageQueue; self.startupMessageQueue = nil; for (id queuedMessage in queue) &#123; [self _dispatchMessage:queuedMessage]; &#125; &#125;&#125; 至此，第一步交互已完成。关于 WebViewJavascriptBridge_JS 内部的 JS 代码我们放到后面的章节解读，现在可以简单理解为 WebViewJavascriptBridge 在 JS 端的具体实现代码。 2.JS 端调用 callHandler 方法之后 Native 端究竟是如何响应的？WebViewJavascriptBridge GitHub 页面 中指出 JS 端的操作方式： 123456789101112setupWebViewJavascriptBridge(function(bridge) &#123; /* Initialize your app here */ bridge.registerHandler(&#x27;JS Echo&#x27;, function(data, responseCallback) &#123; console.log(&quot;JS Echo called with:&quot;, data) responseCallback(data) &#125;) bridge.callHandler(&#x27;ObjC Echo&#x27;, &#123;&#x27;key&#x27;:&#x27;value&#x27;&#125;, function responseCallback(responseData) &#123; console.log(&quot;JS received response:&quot;, responseData) &#125;)&#125;) 我们知道 JS 端调用 setupWebViewJavascriptBridge 方法会走我们刚才分析过的第一步，即监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码。那么当 JS 端调用 bridge.callHandler 时，Native 端究竟是如何做出响应的呢？这里我们需要先稍微解读一下之前注入的 WebViewJavascriptBridge_JS 中的 JS 代码： 123456789101112131415161718192021222324// 调用 iOS handler，参数校验之后调用 _doSend 函数function callHandler(handlerName, data, responseCallback) &#123; if (arguments.length == 2 &amp;&amp; typeof data == &#x27;function&#x27;) &#123; responseCallback = data; data = null; &#125; _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback);&#125;// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.srcfunction _doSend(message, responseCallback) &#123; if (responseCallback) &#123; var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message[&#x27;callbackId&#x27;] = callbackId; &#125; sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &#x27;://&#x27; + QUEUE_HAS_MESSAGE;&#125; // scheme 使用 https 之后通过 host 做匹配var CUSTOM_PROTOCOL_SCHEME = &#x27;https&#x27;;var QUEUE_HAS_MESSAGE = &#x27;__wvjb_queue_message__&#x27;; 可以看到 JS 端的代码中有 callHandler 函数的实现，其内部将入参 handlerName 以及 data 以字典形式作为参数调用 _doSend 方法，我们看一下 _doSend 方法的实现： _doSend 方法内部会先判断入参中是否有回调 如果有回调则根据规则生成 callbackId 并且将回调 block 保存到 responseCallbacks 字典（囧~ JS 不叫字典的，我是为了 iOS 读者看着方便），之后给消息也加入一个键值对保存刚才生成的 callbackId 之后给 sendMessageQueue 队列加入 message 将 messagingIframe.src 设置为 https://__wvjb_queue_message__ 好，点到为止，对于 WebViewJavascriptBridge_JS 内的 JS 端其他源码我们放着后面看。注意这里加入了一个 src 为 https://__wvjb_queue_message__ 的 messagingIframe，它也是一个不可见的 iframe。这样 Native 端会收到一个 url 为 https://__wvjb_queue_message__ 的 request，回到第 1 步中获取到假的 request 之后会进行各项判定，这次会满足 [_base isQueueMessageURL:url] 的判定调用 Native 的 WKFlushMessageQueue 方法。 1234567891011121314- (void)WKFlushMessageQueue &#123; // 执行 WebViewJavascriptBridge._fetchQueue(); 方法 [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(NSString* result, NSError* error) &#123; if (error != nil) &#123; NSLog(@&quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@&quot;, error); &#125; // 刷新消息列表 [_base flushMessageQueue:result]; &#125;];&#125;- (NSString *)webViewJavascriptFetchQueyCommand &#123; return @&quot;WebViewJavascriptBridge._fetchQueue();&quot;;&#125; 可见 Native 端会在刷新队列中调用 JS 端的 WebViewJavascriptBridge._fetchQueue(); 方法，我们来看一下 JS 端此方法的具体实现： 123456789// 获取队列，在 iOS 端刷新消息队列时会调用此函数function _fetchQueue() &#123; // 将 sendMessageQueue 转为 JSON 格式 var messageQueueString = JSON.stringify(sendMessageQueue); // 重置 sendMessageQueue sendMessageQueue = []; // 返回 JSON 格式的 return messageQueueString;&#125; 这个方法会把当前 JS 端 sendMessageQueue 消息队列以 JSON 的形式返回，而 Native 端会调用 [_base flushMessageQueue:result]; 将拿到的 JSON 形式消息队列作为参数调用 flushMessageQueue: 方法，这个方法是整个框架 Native 端的精华所在，就是稍微有点长（笑）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (void)flushMessageQueue:(NSString *)messageQueueString &#123; // 校验 messageQueueString if (messageQueueString == nil || messageQueueString.length == 0) &#123; NSLog(@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;); return; &#125; // 将 messageQueueString 通过 NSJSONSerialization 解为 messages 并遍历 id messages = [self _deserializeMessageJSON:messageQueueString]; for (WVJBMessage* message in messages) &#123; // 类型校验 if (![message isKindOfClass:[WVJBMessage class]]) &#123; NSLog(@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;, [message class], message); continue; &#125; [self _log:@&quot;RCVD&quot; json:message]; // 尝试取 responseId，如取到则表明是回调，从 _responseCallbacks 取匹配的回调 block 执行 NSString* responseId = message[@&quot;responseId&quot;]; if (responseId) &#123; // 取到 responseId WVJBResponseCallback responseCallback = _responseCallbacks[responseId]; responseCallback(message[@&quot;responseData&quot;]); [self.responseCallbacks removeObjectForKey:responseId]; &#125; else &#123; // 未取到 responseId，则表明是正常的 JS callHandler 调用 iOS WVJBResponseCallback responseCallback = NULL; // 尝试取 callbackId，示例 cb_1_1512035076293 // 对应 JS 代码 var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime(); NSString* callbackId = message[@&quot;callbackId&quot;]; if (callbackId) &#123; // 取到 callbackId，表示 js 端希望在调用 iOS native 代码后有回调 responseCallback = ^(id responseData) &#123; if (responseData == nil) &#123; responseData = [NSNull null]; &#125; // 将 callbackId 作为 msg 的 responseId 并设置 responseData，执行 _queueMessage WVJBMessage* msg = @&#123; @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData &#125;; // _queueMessage 函数主要是把 msg 转为 JSON 格式，内含 responseId = callbackId // JS 端调用 WebViewJavascriptBridge._handleMessageFromObjC(&#x27;msg_JSON&#x27;); 其中 &#x27;msg_JSON&#x27; 就是 JSON 格式的 msg [self _queueMessage:msg]; &#125;; &#125; else &#123; // 未取到 callbackId responseCallback = ^(id ignoreResponseData) &#123; // Do nothing &#125;; &#125; // 尝试以 handlerName 获取 iOS 端之前注册过的 handler WVJBHandler handler = self.messageHandlers[message[@&quot;handlerName&quot;]]; if (!handler) &#123; // 没注册过，则跳过此 msg NSLog(@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;, message); continue; &#125; // 调用对应的 handler，以 message[@&quot;data&quot;] 为入参，以 responseCallback 为回调 handler(message[@&quot;data&quot;], responseCallback); &#125; &#125;&#125; 嘛~ flushMessageQueue: 方法作为整个 Native 端的核心，有点长是可以理解的。我们简单理一下它的实现思路： 入参校验 将 JSON 形式的入参转换为 Native 对象，即消息队列，这里面消息类型是之前定义过的 WVJBMessage，即字典 如果消息中含有 “responseId” 则表明是之前 Native 调用的 JS 方法回调过来的消息（因为 JS 端和 Native 端实现逻辑是对等的，所以这个地方不明白的可以参考下面的分析） 如果消息中不含 “responseId” 则表明是 JS 端通过 callHandler 函数正常调用 Native 端过来的消息 尝试获取消息中的 “callbackId”，如果 JS 本次消息需要 Native 响应之后回调才会有这个键值，具体参见上文中 JS 端 _doSend 部分源码分析。如取到 “callbackId” 则需生成一个回调 block，回调 block 内部将 “callbackId” 作为 msg 的 “responseId” 执行 _queueMessage 将消息发送给 JS 端（JS 端处理消息逻辑与 Native 端一致，所以上面使用 “responseId” 判断当前消息是否为回调方法传递过来的消息是很容易理解的） 尝试以消息中的 “handlerName” 从 messageHandlers（上文提到过，是保存 Native 端注册过的 handler 的字典）取到对应的 handler block，如果取到则执行代码块，否则打印错误日志 Note: 这个消息处理的方法虽然长，但是逻辑清晰，而且有效的解决了 JS 与 Native 相互调用的过程中参数传递的问题（包括回调），此外 JS 端的消息处理逻辑与 Native 端保持一致，实现了逻辑对称，非常值得我们学习。 WebViewJavascriptBridge_JS - Native 调用 JS 实现解读 Emmmmm…这一章节主要讲 JS 端注入的代码，即 WebViewJavascriptBridge_JS 中的 JS 源码。由于我没做过前段，能力不足，水平有限，可能有谬误希望各位读者发现的话及时指正，感激不尽。预警，由于 JS 端和上文分析过的 Native 端逻辑对称且上文已经分析过部分 JS 端的函数，所以下面的 JS 源码没有另做拆分，为避免被大段 JS 代码糊脸不感兴趣的同学可以直接看代码后面的总结。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146;(function() &#123; // window.WebViewJavascriptBridge 校验，避免重复 if (window.WebViewJavascriptBridge) &#123; return; &#125; // 懒加载 window.onerror，用于打印 error 日志 if (!window.onerror) &#123; window.onerror = function(msg, url, line) &#123; console.log(&quot;WebViewJavascriptBridge: ERROR:&quot; + msg + &quot;@&quot; + url + &quot;:&quot; + line); &#125; &#125; // window.WebViewJavascriptBridge 声明 window.WebViewJavascriptBridge = &#123; registerHandler: registerHandler, callHandler: callHandler, disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout, _fetchQueue: _fetchQueue, _handleMessageFromObjC: _handleMessageFromObjC &#125;; // 变量声明 var messagingIframe; // 消息 iframe var sendMessageQueue = []; // 发送消息队列 var messageHandlers = &#123;&#125;; // JS 端注册的消息处理 handlers 字典（囧，JS 其实叫对象） // scheme 使用 https 之后通过 host 做匹配 var CUSTOM_PROTOCOL_SCHEME = &#x27;https&#x27;; var QUEUE_HAS_MESSAGE = &#x27;__wvjb_queue_message__&#x27;; var responseCallbacks = &#123;&#125;; // JS 端存放回调的字典 var uniqueId = 1; // 唯一标示，用于回调时生成 callbackId var dispatchMessagesWithTimeoutSafety = true; // 默认启用安全时长 // 通过禁用 AlertBoxSafetyTimeout 来提速网桥消息传递 function disableJavscriptAlertBoxSafetyTimeout() &#123; dispatchMessagesWithTimeoutSafety = false; &#125; // 同 iOS 逻辑，注册 handler 其实是往 messageHandlers 字典中插入对应 name 的 block function registerHandler(handlerName, handler) &#123; messageHandlers[handlerName] = handler; &#125; // 调用 iOS handler，参数校验之后调用 _doSend 函数 function callHandler(handlerName, data, responseCallback) &#123; // 如果参数只有两个且第二个参数类型为 function，则表示没有参数传递，即 data 为空 if (arguments.length == 2 &amp;&amp; typeof data == &#x27;function&#x27;) &#123; responseCallback = data; data = null; &#125; // 将 handlerName 和 data 作为 msg 对象参数调用 _doSend 函数 _doSend(&#123; handlerName:handlerName, data:data &#125;, responseCallback); &#125; // _doSend 向 Native 端发送消息 function _doSend(message, responseCallback) &#123; // 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId] if (responseCallback) &#123; var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime(); responseCallbacks[callbackId] = responseCallback; message[&#x27;callbackId&#x27;] = callbackId; &#125; // 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src sendMessageQueue.push(message); messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &#x27;://&#x27; + QUEUE_HAS_MESSAGE; &#125; // 获取队列，在 iOS 端刷新消息队列时会调用此函数 function _fetchQueue() &#123; // 内部将发送消息队列 sendMessageQueue 转为 JSON 格式并返回 var messageQueueString = JSON.stringify(sendMessageQueue); sendMessageQueue = []; return messageQueueString; &#125; // iOS 端 _dispatchMessage 函数会调用此函数 function _handleMessageFromObjC(messageJSON) &#123; // 调度从 Native 端获取到的消息 _dispatchMessageFromObjC(messageJSON); &#125; // 核心代码，调度从 Native 端获取到的消息，逻辑与 Native 端一致 function _dispatchMessageFromObjC(messageJSON) &#123; // 判断有没有禁用 AlertBoxSafetyTimeout，最终会调用 _doDispatchMessageFromObjC 函数 if (dispatchMessagesWithTimeoutSafety) &#123; setTimeout(_doDispatchMessageFromObjC); &#125; else &#123; _doDispatchMessageFromObjC(); &#125; // 解析 msgJSON 得到 msg function _doDispatchMessageFromObjC() &#123; var message = JSON.parse(messageJSON); var messageHandler; var responseCallback; // 如果有 responseId，则说明是回调，取对应的 responseCallback 执行，之后释放 if (message.responseId) &#123; responseCallback = responseCallbacks[message.responseId]; if (!responseCallback) &#123; return; &#125; responseCallback(message.responseData); delete responseCallbacks[message.responseId]; &#125; else &#123; // 没有 responseId，则表示正常的 iOS call handler 调用 js // 如 msg 包含 callbackId，说明 iOS 端需要回调，初始化对应的 responseCallback if (message.callbackId) &#123; var callbackResponseId = message.callbackId; responseCallback = function(responseData) &#123; _doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;); &#125;; &#125; // 从 messageHandlers 拿到对应的 handler 执行 var handler = messageHandlers[message.handlerName]; if (!handler) &#123; // 如未取到对应的 handler 则打印错误日志 console.log(&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;, message); &#125; else &#123; handler(message.data, responseCallback); &#125; &#125; &#125; &#125; // messagingIframe 的声明，类型 iframe，样式不可见，src 设置 messagingIframe = document.createElement(&#x27;iframe&#x27;); messagingIframe.style.display = &#x27;none&#x27;; messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &#x27;://&#x27; + QUEUE_HAS_MESSAGE; // messagingIframe 加入 document.documentElement 中 document.documentElement.appendChild(messagingIframe); // 注册 disableJavscriptAlertBoxSafetyTimeout handler，Native 可以通过禁用 AlertBox 的安全时长来加速桥接消息 registerHandler(&quot;_disableJavascriptAlertBoxSafetyTimeout&quot;, disableJavscriptAlertBoxSafetyTimeout); setTimeout(_callWVJBCallbacks, 0); function _callWVJBCallbacks() &#123; var callbacks = window.WVJBCallbacks; delete window.WVJBCallbacks; for (var i=0; i&lt;callbacks.length; i++) &#123; callbacks[i](WebViewJavascriptBridge); &#125; &#125;&#125; JS 端和 Native 端逻辑一致，上面的代码已经加入了详细的中文注释，上文在对于“WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析”章节的分析过程中为了走通整个调用的逻辑已经对部分 JS 端代码进行了分析，这里我们简单的梳理一下 JS 端核心代码 _doDispatchMessageFromObjC 函数的逻辑： 将 messageJSON 使用 JSON 解析出来 尝试取解析到的消息中的 responseId，如果有取到则说明是 Native 端响应 JS 端之后通过回调向 JS 端发出的消息，用 responseId 取 responseCallbacks 中对应的回调响应 block，找到后执行该 block 之后删除 如果没取到 responseId 则表示这条消息是 Native 端通过 callHandler:data:responseCallback: 正常调用 JS 注册的 handler 发送过来的消息（这里的正常是针对回调而言） 如果当前的消息有 callbackId 则表明 Native 端需要 JS 端响应本次消息之后回调反馈，生成一个 responseCallback 作为回调 block (JS 端是 function) ，其内部使用 _doSend 方法传递一个带有 responseId 的消息给 Native 端，表明此条消息是之前的回调消息 最后按照解析到的消息中 handlerName 从 messageHandlers，即 JS 端注册过的 handlers 中找到与名称对应的处理函数执行，如果没找到则打印附带相关信息的错误日志 嘛~ 对比一下 Native 端的核心代码 flushMessageQueue: 看一下，很容易发现两端的处理实现是逻辑对称的。 WebViewJavascriptBridge 的“桥梁美学” 在总结 WebViewJavascriptBridge 的“桥梁美学”之前请再回顾一下 WebViewJavascriptBridge 的工作流： JS 端加入 src 为 https://__bridge_loaded__ 的 iframe Native 端检测到 Request，检测如果是 __bridge_loaded__ 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码 注入代码成功之后会加入一个 messagingIframe，其 src 为 https://__wvjb_queue_message__ 之后不论是 Native 端还是 JS 端都可以通过 registerHandler 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 callHandler 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称） 嘛~ 所以我们很容易列举出 WebViewJavascriptBridge 所具有的“美学”： 隐性适配 接口对等 逻辑对称 我们结合本文展开来说一下上面的“美学”的具体实现。 隐性适配WebViewJavascriptBridge 主要是作为 Mac OS X 和 iOS 端（Native 端）与 JS 端相互通信，互相调用的桥梁。对于 Mac OS X 和 iOS 两种平台包含的三种 WebView 功能组件而言，WebViewJavascriptBridge 做了隐性适配，即仅用一套代码即可绑定不同平台的 WebView 组件实现同样功能的 JS 通信功能，这一点非常方便。 接口对等WebViewJavascriptBridge 对于 JS 端和 Native 端设计了对等的接口，不论是 JS 端还是 Native 端，注册本端的响应处理都是用 registerHandler 接口，调用另一端（给另一端发消息）都是用 callHandler 接口。 这样做是非常合理的，因为不论是 JS 端还是 Native 端，作为通信的双方就通信本身而言是处于对等的地位的。这就好比一座大桥连接两块陆地，两地用大桥相互运输货物并接收资源，两块陆地在大桥的运输使用过程中逻辑上也是地位对等的。 逻辑对称WebViewJavascriptBridge 在 JS 端和 Native 端对发送过来的消息有着相同逻辑的处理实现，如果考虑到收发双方的身份则可以把逻辑相同看做逻辑对称。 这种实现方式依旧非常合理，被桥连接的两块大陆在装货上桥和下桥卸货这两处逻辑上就应该是对称的。 嘛~ 说到这里就不得不祭出一个词来形容 WebViewJavascriptBridge 了，这个词就是优雅（笑）。当大家结合 WebViewJavascriptBridge 源码阅读本文之后不难发现其整个架构和设计思想跟现实桥梁设计中很多设计思想不谋而合，比如桥一般会分为左右桥幅，而左右幅桥一般只有一条线路中心线，即一个前进方向，用于桥上单一方向的资源传输，左右桥幅在功能上对等。 文章总结 文章系统分析了 WebViewJavascriptBridge 源码，希望各位读者能够在阅读本文之后对 WebViewJavascriptBridge 的架构有一个整体认识。 文章对 WebViewJavascriptBridge 在 JS 端和 Native 端的消息处理实现做了深入剖析，希望可以对各位读者这部分源码的理解提供一些微薄的帮助。 总结了 WebViewJavascriptBridge 作为一个 JSBridge 框架所具有的优势，即文中所指的“桥梁美学”，期望可以对大家以后自己封装一个 JSBridge 提供思路，抛砖引玉。 Emmmmm…不过需要注意的是 WebViewJavascriptBridge 仅仅是作为 JSBridge 层用于提供 JS 和 Native 之间相互传递消息的基础支持的。如果想要封装自己项目中的 WebView 组件还需要另外实现 HTTP cookie 注入，自定义 User-Agent，白名单或者权限校验等功能，更进一步还需要对 WebView 组件进行初始化速度，页面渲染速度以及页面缓存策略的优化。我之后也许可能大概应该会写一篇文章分享一下自己封装 WebView 组件时踩到的一些坑以及经验，因为自己水平有限…所以也可能不会写（笑）。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"YYImage 设计思路，实现细节剖析","comments":true,"permalink":"https://lision.me/yyimage/","text":"前言图片的历史早于文字，是最原始的信息传递方式。六书中的象形文构造思想就是用文字的线条或笔画，把要表达物体的外形特征，具体地勾画出来。 许慎《说文解字》云：“象形者，画成其物，随体诘诎，日、月是也。” 现代社会的信息传递中，图片仍然是不可或缺的一环，不论是报纸、杂志、漫画等实体刊物还是生活中超市地铁广告活动，都会有专门的配图抓人眼球。 在移动端 App 中，图片通常占据着重要的视觉空间，作为 iOS 开发来讲，所有的 App 都有精心设计的 AppIcon 陈列在 SpringBoard 中，打开任意一款主流 App 都少不了琳琅满目的图片搭配。 YYImage 是一款功能强大的 iOS 图像框架（该项目是 YYKit 组件之一），支持目前市场上所有主流的图片格式的显示与编/解码，并且提供高效的动态内存缓存管理，以保证高性能低内存的动画播放。 YYKit 的作者 @ibireme 对于 iOS 图片处理写有两篇非常不错的文章，推荐各位读者在阅读本文之前查阅。 移动端图片格式调研 iOS 处理图片的一些小 Tip 本文引用代码均为 YYImage v1.0.4 版本源码，文章旨在剖析 YYImage 的架构思想以及设计思路并对笔者在阅读源码过程中发现的有趣实现细节探究分享，不会逐行翻译源码，建议对源码实现感兴趣的同学结合 YYImage v1.0.4 版本源码食用本文~ 索引 YYImage 简介 YYImage, YYFrameImage, YYSpriteSheetImage YYAnimatedImageView YYImageCoder 总结 扩展阅读 YYImage 简介 YYImage 是一款功能强大的 iOS 图像框架，支持当前市场主流的静/动态图像编/解码与动态图像的动画播放显示，其具有以下特性： 支持以下类型动画图像的播放/编码/解码: WebP, APNG, GIF。 支持以下类型静态图像的显示/编码/解码: WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。 支持以下类型图片的渐进式/逐行扫描/隔行扫描解码: PNG, GIF, JPEG, BMP。 支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。 高效的动态内存缓存管理，以保证高性能低内存的动画播放。 完全兼容 UIImage 和 UIImageView，使用方便。 保留可扩展的接口，以支持自定义动画。 每个类和方法都有完善的文档注释。 YYImage 架构分析通过 YYImage 源码可以按照其与 UIKit 的对应关系划分为三个层级： 层级 UIKit YYImage 图像层 UIImage YYImage, YYFrameImage, YYSpriteSheetImage 视图层 UIImageView YYAnimatedImageView 编/解码层 ImageIO.framework YYImageCoder 图像层，把不同类型的图像信息封装成类并提供初始化和其他便捷接口。 视图层，负责图像层内容的显示（包含动态图像的动画播放）工作。 编/解码层，提供图像底层支持，使整个框架得以支持市场主流的图片格式。 Note: ImageIO.framework 是 iOS 底层实现的图片编/解码库，负责管理颜色和访问图像元数据。其内部的实现使用了第三方编/解码库（如 libpng 等）并对第三方库进行调整优化。除此之外，iOS 还专门针对 JPEG 的编/解码开发了 AppleJPEG.framework，实现了性能更高的硬编码和硬解码。 YYImage, YYFrameImage, YYSpriteSheetImage先来介绍 YYImage 库中图像层的三个类，它们分别是： YYImage YYFrameImage YYSpriteSheetImage YYImageYYImage 是一个显示动态图片数据的高级别类，其继承自 UIImage 并对 UIImage 做了扩展以支持 WebP，APNG 和 GIF 格式的图片解码。它还支持 NSCoding 协议可以对多帧图像数据进行 archive 和 unarchive 操作。 12345678910111213@interface YYImage : UIImage &lt;YYAnimatedImage&gt;+ (nullable YYImage *)imageNamed:(NSString *)name; // 不同于 UIImage，此方法无缓存+ (nullable YYImage *)imageWithContentsOfFile:(NSString *)path;+ (nullable YYImage *)imageWithData:(NSData *)data;+ (nullable YYImage *)imageWithData:(NSData *)data scale:(CGFloat)scale;@property (nonatomic, readonly) YYImageType animatedImageType; // 图像数据类型@property (nullable, nonatomic, readonly) NSData *animatedImageData; // 动态图像的元数据@property (nonatomic, readonly) NSUInteger animatedImageMemorySize; // 多帧图像内存占用量@property (nonatomic) BOOL preloadAllAnimatedImageFrames; // 预加载所有帧（到内存）@end YYImage 提供了类似 UIImage 的初始化方法，公开了一些属性便于我们检测和控制其内存使用。 值得一提的是 YYImage 的 imageNamed: 初始化方法并不支持缓存。因为其 imageNamed: 内部实现并不同于 UIImage 的 imageNamed: 方法，YYImage 中的实现流程如下： 推测出给定图像资源路径 拿到路径中的图像数据（NSData） 调用 YYImage 的 initWithData:scale: 方法初始化 YYImage 的私有变量部分也比较简单，相信大家可以根据上面暴露出的属性和接口猜得到哈。 123456@implementation YYImage &#123; YYImageDecoder *_decoder; // 解码器 NSArray *_preloadedFrames; // 预加载的图像帧 dispatch_semaphore_t _preloadedLock; // 预加载锁 NSUInteger _bytesPerFrame; // 内存占用量&#125; 其内部有一把锁 dispatch_semaphore_t，我们知道 dispatch_semaphore_t 当信号量为 1 时可以当做锁来使用，在不阻塞时其作为锁的效率非常高。这里使用 _preloadedLock 的主要目的是保证 _preloadedFrames 的读写，由于 _preloadedFrames 的读写过程是在内存中完成的，操作耗时不会太多，所以不会长时间阻塞，这种情况使用 dispatch_semaphore_t 非常合适。 嘛~ _preloadedFrames 对应 preloadAllAnimatedImageFrames 属性，开启预加载所有帧到内存的话，_preloadedFrames 作为一个数组会保存所有帧的图像。_bytesPerFrame 则对应 animatedImageMemorySize 属性，在初始化 YYImage 时，如果帧总数超过 1 则会计算 _bytesPerFrame 的大小。 12345if (decoder.frameCount &gt; 1) &#123; _decoder = decoder; _bytesPerFrame = CGImageGetBytesPerRow(image.CGImage) * CGImageGetHeight(image.CGImage); _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount;&#125; 其实 YYImage 中还有一些实现也比较有趣，比如 animatedImageDurationAtIndex: 的实现中如果取到 &lt;= 10 ms 的时长会替换为 100 ms，并在 注释 中解释了为什么（一定要点进去看啊，笑~）。 YYFrameImageYYFrameImage 是专门用来显示基于帧的动画图像类，其也是 UIImage 的子类。YYFrameImage 仅支持系统图片格式例如 png 和 jpeg。 Note: 使用 YYFrameImage 显示动画图像同样要基于 YYAnimatedImageView 播放。 12345678910111213141516@interface YYFrameImage : UIImage &lt;YYAnimatedImage&gt;- (nullable instancetype)initWithImagePaths:(NSArray&lt;NSString *&gt; *)paths oneFrameDuration:(NSTimeInterval)oneFrameDuration loopCount:(NSUInteger)loopCount;- (nullable instancetype)initWithImagePaths:(NSArray&lt;NSString *&gt; *)paths frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations loopCount:(NSUInteger)loopCount;- (nullable instancetype)initWithImageDataArray:(NSArray&lt;NSData *&gt; *)dataArray oneFrameDuration:(NSTimeInterval)oneFrameDuration loopCount:(NSUInteger)loopCount;- (nullable instancetype)initWithImageDataArray:(NSArray&lt;NSData *&gt; *)dataArray frameDurations:(NSArray *)frameDurations loopCount:(NSUInteger)loopCount;@end YYFrameImage 可以把静态图片类型如 png 和 jpeg 格式的静态图像用帧切换的方式以动态图片的形式显示，并且提供了 4 个常用的初始化方法方便我们使用。 YYFrameImage 内部有一些基本的变量分别对应于其暴露的 4 个常用初始化接口： 1234567@implementation YYFrameImage &#123; NSUInteger _loopCount; NSUInteger _oneFrameBytes; NSArray *_imagePaths; NSArray *_imageDatas; NSArray *_frameDurations;&#125; YYFrameImage 的实现代码非常简单，初始化方法大致可以分为以下步骤： 入参校验 根据入参取到首张图片 用首图初始化 _oneFrameBytes ，如入参初始化 _imageDatas ，_frameDurations 和 _loopCount 用 UIImage 的 initWithCGImage:scale:orientation: 初始化并返回初始化结果 YYSpriteSheetImage YYSpriteSheetImage 是用来做 Spritesheet 动画显示的图像类，它也是 UIImage 的子类。 关于 Spritesheet 可能做过游戏开发或者以前鼓捣过简单网页游戏 Demo 的同学会很熟悉，其动画原理是把一个动画过程分解为多个动画帧，按照顺序将这些动画帧排布在一张大的画布中，播放动画时只需要按照每一帧图像的尺寸大小以及对应索引去画布中提取对应的帧替换显示以达到人眼判定动画的效果，点击 An Introduction to Spritesheet Animation 或者 What is a sprite sheet? 了解更多关于 Spritesheet 动画的信息。 Note: 关于 SpriteSheet 素材的制作有一款工具 SpriteSheetMaker 推荐使用。 12345678910111213141516@interface YYSpriteSheetImage : UIImage &lt;YYAnimatedImage&gt;// 初始化方法，这个第一次接触 Spritesheet 的同学可能会觉得比较繁琐- (nullable instancetype)initWithSpriteSheetImage:(UIImage *)image contentRects:(NSArray&lt;NSValue *&gt; *)contentRects frameDurations:(NSArray&lt;NSNumber *&gt; *)frameDurations loopCount:(NSUInteger)loopCount;@property (nonatomic, readonly) NSArray&lt;NSValue *&gt; *contentRects; // 帧位置信息@property (nonatomic, readonly) NSArray&lt;NSValue *&gt; *frameDurations; // 帧持续时长@property (nonatomic, readonly) NSUInteger loopCount; // 循环数// 根据索引找到对应帧 CALayer 的位置- (CGRect)contentsRectForCALayerAtIndex:(NSUInteger)index;@end 其中初始化方法的入参为 SpriteSheet 画布（包含所有动画帧的大图）image，每一帧的位置 contentRects，每一帧对应的持续显示时间 frameDurations，循环次数 loopCount，初始化示例在 YYImage 源文件 YYSpriteSheetImage.h 注释中有写。 Note: 下文中要讲的 YYAnimatedImageView 中定义了 YYAnimatedImage 协议，这个协议中有一个可选方法 animatedImageContentsRectAtIndex: 就是为 YYSpriteSheetImage 量身打造的。 这里需要提一下 contentsRectForCALayerAtIndex: 接口会根据索引找到对应帧的 CALayer 位置，该接口返回一个由 0.0~1.0 之间的数值组成的图层定位 LayerRect，如果在查找位置过程中发现异常则返回 CGRectMake(0, 0, 1, 1)，其内部实现大体步骤： 校验入参索引是否超过 SpriteSheet 分割帧总数，超过返回 CGRectMake(0, 0, 1, 1) 没超过则通过 YYAnimatedImage 协议的 animatedImageContentsRectAtIndex: 方法找到对应索引的真实位置 RealRect 通过真实位置 RealRect 与 SpriteSheet 画布的比算错 0.0~1.0 之间的值，得到指定索引帧的逻辑定位 LogicRect 通过 CGRectIntersection 方法计算逻辑定位 LogicRect 与 CGRectMake(0, 0, 1, 1) 的交集，确保逻辑定位没有超出画布的部分 将处理后的逻辑定位 LogicRect 作为图层定位 LayerRect 返回 返回的 LayerRect 作为对应索引帧的画布内相对位置存在，结合画布就可以定位到对应帧图像的具体尺寸和位置。 YYAnimatedImageView 人眼中呈现的动画是由一幅幅内容连贯的图像以较短时间按顺序替换形成的，所以要显示动画只需要知道动画顺序中每一帧图像以及对应的显示时间等信息即可。YYImage 中对应于 UIImage 层级的内容（YYImage, YYFrameImage, YYSpriteSheetImage）在上文已经介绍过了，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。 YYAnimatedImageView 是 YYImage 的重要组成，它是 UIImageView 的子类，负责 YYImage 图像层中不同的图像类的视图显示（包含动态图像的动画播放），其内部包含 YYAnimatedImage 协议以及 YYAnimatedImageView 自身两部分。 YYAnimatedImage 协议上文提到不论是 YYImage, YYFrameImage, YYSpriteSheetImage 还是以后可能会扩展的图像类，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。 YYAnimatedImage 协议就是在不影响原来图像类的情况下把不同图像类之间的共性找出来（求同存异？笑），以统一化的接口将人眼动画呈现所需的基本信息输出给 YYAnimatedImageView 使用的协议。 Note: 作为图像类须遵循 YYAnimatedImage 协议以便可以使用 YYAnimatedImageView 播放动画。 12345678910111213141516171819@protocol YYAnimatedImage &lt;NSObject&gt;@required// 动画帧总数- (NSUInteger)animatedImageFrameCount;// 动画循环次数，0 表示无限循环- (NSUInteger)animatedImageLoopCount;// 每帧字节数（在内存中），可能用于优化内存缓冲区大小- (NSUInteger)animatedImageBytesPerFrame;// 返回给定特殊索引对应的帧图像，这个方法可能在异步线程中调用- (nullable UIImage *)animatedImageFrameAtIndex:(NSUInteger)index;// 返回给定特殊索引对应的帧图像对应的显示持续时长- (NSTimeInterval)animatedImageDurationAtIndex:(NSUInteger)index;@optional// 针对 Spritesheet 动画的方法，用于显示某一帧图像在 Spritesheet 画布中的位置- (CGRect)animatedImageContentsRectAtIndex:(NSUInteger)index;@end 上文提到过可选实现接口 animatedImageContentsRectAtIndex: 是专为 Spritesheet 动画设计的。 像这样规定一个协议，使不相关的类遵循此协议拥有统一的功能接口方便另一个类调用的设计思想我们在自己日常项目的开发过程中很多场景都可以用到，例如可以封装一个 TableView，设计一个 TableViewCell 协议，让所有 TableViewCell 都实现这个协议以拥有统一的功能接口，然后我们封装的 TableView 类就可以统一的使用这些 TableViewCell 显示数据啦，省去了反复写相同功能 UITableView 的劳动力（实际应用场景很多，这里只是简单举例，抛砖引玉）。 YYAnimatedImageView上文提到过 YYAnimatedImageView 作为 YYImage 框架中的图片视图层，上接图像层，下启编/解码底层，是枢纽一般的存在（承上启下啊有木有？），我们需要重点研究其内部实现： 1234567891011121314@interface YYAnimatedImageView : UIImageView// 如果 image 为多帧组成时，自动赋值为 YES，可以在显示和隐藏时自动播放和停止动画@property (nonatomic) BOOL autoPlayAnimatedImage;// 当前显示的帧（从 0 起始），设置新值后会立即显示对应帧，如果新值无效则此方法无效@property (nonatomic) NSUInteger currentAnimatedImageIndex;// 当前是否在播放动画@property (nonatomic, readonly) BOOL currentIsPlayingAnimation;// 动画定时器所在的 runloop mode，默认为 NSRunLoopCommonModes，关乎动画定时器的触发@property (nonatomic, copy) NSString *runloopMode;// 内部缓存区的最大值（in bytes），默认为 0（动态），如果有值将会把缓存区限制为值大小，当收到内存警告或者 App 进入后台时，缓存区将会立即释放并且在适时的时候回复原状@property (nonatomic) NSUInteger maxBufferSize;@end 额…出乎意料的简单呢~ 只有一些属性暴露出来以便我们在使用过程中实时查看动画的播放状态以及内存使用情况。笔者看源码总结出一条经验，即如果某个组件在库中占据重要地位，其 .h 文件中暴露的内容越是简单，其 .m 内部实现就越是复杂。 通过 runloopMode 属性大家用猜的也应该可以猜出 YYAnimatedImageView 内部实现动画的原理离不开 RunLoop，而且极有可能是用定时器 NSTimer 或者 CADisplayLink 实现的。下面我们来对 YYAnimatedImageView 的实现剖析，验证一下我们刚才的猜想。 YYAnimatedImageView 的实现剖析YYAnimatedImageView 内部实现源码很有趣，有很多值得分享的地方。不过为了不把文章写成 MarkDown 编辑器文（笑~）笔者不会逐行翻译源码。读者如果想要知道实现的细节建议结合文章去翻阅源码。相信有了文章梳理的思路源码看起来应该不会有太大的困难，文章还是重在传播实现思想和一些值得分享的技巧。 我们先简单看一下 YYAnimatedImageView 的内部结构，方便后面分析实现思路时大家脑中对 YYAnimatedImageView 的结构提前有一个大概的认识。 123456789101112131415161718192021222324252627282930@interface YYAnimatedImageView() &#123; @package UIImage &lt;YYAnimatedImage&gt; *_curAnimatedImage; ///&lt; 当前图像 dispatch_once_t _onceToken; ///&lt; 用于确保初始化代码只执行一次 dispatch_semaphore_t _lock; ///&lt; 信号量锁（用于 _buffer） NSOperationQueue *_requestQueue; ///&lt; 图片请求队列，串行 CADisplayLink *_link; ///&lt; 帧转换 NSTimeInterval _time; ///&lt; 上一帧之后的时间 UIImage *_curFrame; ///&lt; 当前帧 NSUInteger _curIndex; ///&lt; 当前帧索引 NSUInteger _totalFrameCount; ///&lt; 帧总数 BOOL _loopEnd; ///&lt; 是否在循环末尾 NSUInteger _curLoop; ///&lt; 当前循环次数 NSUInteger _totalLoop; ///&lt; 总循环次数, 0 表示无穷 NSMutableDictionary *_buffer; ///&lt; 帧缓冲区 BOOL _bufferMiss; ///&lt; 是否丢帧，在上面 _link 定时执行的 step 函数中从帧缓冲区读取下一帧图片时如果没读到，则视为丢帧 NSUInteger _maxBufferCount; ///&lt; 最大缓冲计数 NSInteger _incrBufferCount; ///&lt; 当前允许的缓存区计数（将逐步增加） CGRect _curContentsRect; ///&lt; 针对 YYSpriteSheetImage BOOL _curImageHasContentsRect; ///&lt; 图像类是否实现了 animatedImageContentsRectAtIndex: 接口&#125;@property (nonatomic, readwrite) BOOL currentIsPlayingAnimation;- (void)calcMaxBufferCount; // 动态调节缓冲区最大限制 _maxBufferCount@end 可以看到 YYAnimatedImageView 内部结构比 .h 中暴露的属性要复杂的多，而 CADisplayLink *_link 属性也证实了我们之前关于 .h 中 runloopMode 属性的猜想。 YYAnimatedImageView 内部的初始化没什么特别之处，初始化函数中会设置图片，当判定图片有更改时会依照下面 4 步去处理： 改变图片 重置动画 初始化动画参数 重绘 Note: 这样可以保证 YYAnimatedImageView 的图片更改时都会执行上面的步骤为新的图片初始化配套的新动画参数并且重绘，而重置动画实现中会使用到上面的 dispatch_once_t _onceToken; 以确保某些内部变量的创建以及对 App 内存警告和进入后台的通知观察代码只执行一次。 YYAnimatedImageView 使图片动起来是依靠 CADisplayLink *_link; 变量切换帧图像，其内部的实现逻辑可以简单理解为： 根据当前帧索引推出下一帧索引 使用下一帧索引去帧缓冲区尝试获取对应帧图像 如果找到对应帧图像则使用其重绘 如果没找到则根据条件向图片请求队列加入请求操作（向图片缓冲区录入之后的帧图像数据） 嘛~ 这里面有一些值得一提的实现细节哈！ YYAnimatedImageView 实现中当 _curIndex 即当前帧索引修改时在修改代码前后加入了 willChangeValueForKey: 与 didChangeValueForKey: 方法以支持 KVO 对帧缓冲区 _buffer 的操作都使用 _lock 上锁 通过将图片请求队列 _requestQueue 的 maxConcurrentOperationCount 设置为 1 使图片请求队列成为串行队列（最大并发数为 1） 图片请求队列中加入的操作均为 _YYAnimatedImageViewFetchOperation 为了避免使用 CADisplayLink 可能造成的循环引用设计了 _YYImageWeakProxy 先看一下 _YYAnimatedImageViewFetchOperation 的源码： 123456789@interface _YYAnimatedImageViewFetchOperation : NSOperation@property (nonatomic, weak) YYAnimatedImageView *view;@property (nonatomic, assign) NSUInteger nextIndex;@property (nonatomic, strong) UIImage &lt;YYAnimatedImage&gt; *curImage;@end@implementation _YYAnimatedImageViewFetchOperation- (void)main &#123;//...&#125;@end _YYAnimatedImageViewFetchOperation 继承自 NSOperation 类，是自定义操作类，作者将其操作内容实现写在了 main 中，代码太长而且我觉得贴出来不仅不会帮助读者理解反而会因为片面的源码实现影响读者对 YYAnimatedImageView 的整体实现思路理解（因为大量贴源码会使文章生涩很多，而且会把读者注意力转移到某一个实现），这里简单描述一下 main 函数内部实现逻辑： 判断帧缓冲区大小 扫描下一帧以及当前允许缓冲范围内之后的帧图片 如果发现丢失的帧则尝试重新获取帧图像并加入到帧缓冲 嘛~ 不贴源码归不贴源码，该注意的细节还是需要列出来的（笑）。 操作中对于 view 缓冲区的操作也都上了锁 操作由于是放入图片请求队列中进行的，内部有对 isCancelled 做判断，如果操作已经被取消（发生在更改图片、停止动画、手动更改当前帧、收到内存警告或 App 进入后台等）则需要及时跳出 对于新的线程优先级只在 main 方法范围内有效，所以推荐把操作的实现放在 main 中而非 start（如需覆盖 start 方法时，需要关注 isExecuting 和 isFinished 两个 key paths） YYAnimatedImageView 内部设计了 _YYImageWeakProxy 来避免使用 NSTimer 或者 CADisplayLink 可能造成的循环引用问题，_YYImageWeakProxy 内部实现也比较简单，继承自 NSProxy，关于 NSProxy 可以查看官方文档以了解更多。 1234567891011121314151617181920@interface _YYImageWeakProxy : NSProxy@property (nonatomic, weak, readonly) id target;- (instancetype)initWithTarget:(id)target;+ (instancetype)proxyWithTarget:(id)target;@end@implementation _YYImageWeakProxy// ...- (id)forwardingTargetForSelector:(SEL)selector &#123; return _target;&#125;- (void)forwardInvocation:(NSInvocation *)invocation &#123; void *null = NULL; [invocation setReturnValue:&amp;null];&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123; return [NSObject instanceMethodSignatureForSelector:@selector(init)];&#125;// ...@end 上面贴出的源码省略了比较基础的实现部分，_YYImageWeakProxy 内部弱引用一个对象 target，对于 _YYImageWeakProxy 的一些基本操作包含 hash 和 isEqual 这些统统都转到 target 上，并且使用 forwardingTargetForSelector: 消息重定向将不能响应的运行时消息也重定向给 target 来响应。 Emmmmm..那么问题来了，既然都消息重定向给 target 了还要消息转发干嘛？因为要避免循环引用问题所以对 target 使用弱引用，期间无法保证 target 一定存在，所以 forwardingTargetForSelector: 方法可能返回 nil，接着在 Runtime 消息转发中借用 init 消息返回空以“吞掉”异常。 Note: 消息转发产生的开销要比动态方法解析和消息重定向大。 YYImageCoder YYImageCoder 作为 YYImage 的编/解码器，对应于 iOS 中的 ImageIO.framework 图片编/解码库，正是因为有了 YYImageCoder 的存在，YYImage 才得以支持如此多的图片格式，所以说 YYImageCoder 是 YYImage 的底层核心。 YYImageCoder 内部定义了许多 YYImage 中用到的核心数据结构： YYImageType，所有的支持的图片格式做了枚举定义 YYImageDisposeMethod，指定在画布上渲染下一个帧之前如何处理当前帧所使用的区域方法 YYImageBlendOperation，指定当前帧的透明像素如何与前一个画布的透明像素混合操作 YYImageFrame，一帧图像数据 YYImageEncoder，图像编码器 YYImageDecoder，图像解码器 UIImage+YYImageCoder，UIImage 的分类，里面提供了一些方便使用的方法 其中 YYImageFrame 是对一帧图像数据的封装，便于在 YYImageCoder 编/解码过程中使用。 YYImageCoder 内部图像编码器 YYImageEncoder 和图像解码器 YYImageDecoder 其实是分开来的，我们下面分别对它们做分析。 YYImageEncoder先来讲一下 YYImageEncoder，其在 YYImageCoder 中担任编码器的角色。 1234567891011121314151617181920212223242526272829@interface YYImageEncoder : NSObject@property (nonatomic, readonly) YYImageType type; ///&lt; 图像类型@property (nonatomic) NSUInteger loopCount; ///&lt; 循环次数，0 无限循环，仅适用于 GIF/APNG/WebP 格式@property (nonatomic) BOOL lossless; ///&lt; 无损标记，仅适用于 WebP.@property (nonatomic) CGFloat quality; ///&lt; 压缩质量，0.0~1.0，仅适用于 JPG/JP2/WebP.// 禁止适用 init、new 初始化编码器（我没忘记我说过这些编码技巧会在之后统一写一篇文章汇总）- (instancetype)init UNAVAILABLE_ATTRIBUTE;+ (instancetype)new UNAVAILABLE_ATTRIBUTE;// 根据给定图片类型创建编码器- (nullable instancetype)initWithType:(YYImageType)type NS_DESIGNATED_INITIALIZER;// 添加图像- (void)addImage:(UIImage *)image duration:(NSTimeInterval)duration;// 添加图像数据- (void)addImageWithData:(NSData *)data duration:(NSTimeInterval)duration;// 添加文件路径- (void)addImageWithFile:(NSString *)path duration:(NSTimeInterval)duration;// 开始图像编码并尝试返回编码后的数据- (nullable NSData *)encode;// 编码并将得到的数据保存到给定路径文件中- (BOOL)encodeToFile:(NSString *)path;// 便捷方法，对一个单帧图像编码+ (nullable NSData *)encodeImage:(UIImage *)image type:(YYImageType)type quality:(CGFloat)quality;// 便捷方法，从解码器中编码图像数据+ (nullable NSData *)encodeImageWithDecoder:(YYImageDecoder *)decoder type:(YYImageType)type quality:(CGFloat)quality;@end 可以看到 YYImageEncoder 内部的一些属性和接口都比较基本，关于其内部实现我们需要先看一下私有变量： 1234@implementation YYImageEncoder &#123; NSMutableArray *_images; // 已添加到编码器的图片（数组） NSMutableArray *_durations; // 对应的图片帧显示持续时长（数组）&#125; YYImageEncoder 的实现思路YYImageEncoder 的初始化部分没有多复杂，根据图片的类型按照编码最优的参数做初始化而已。关于 YYImageEncoder 对于图片的编码工作，其实作者根据要支持的图片类型和对应图片类型的编码方式做了底层封装，再根据当前图片的类型选择对应的底层编码方法执行。 关于不同图片类型的图片编码格式可以查阅本文文末的扩展阅读章节，结合扩展阅读的内容查阅 YYImage 这部分源码可以理解作者对于底层图片格式信息的结构封装以及编/解码操作具体实现。 关于 YYImageEncoder 的一些简单使用示例可以查看 YYImageCoder.h 了解。 YYImageDecoderYYImageDecoder 在 YYImageCoder 中担任解码器的角色，其与上述 YYImageEncoder 对应，一个负责图像编码一个负责图像解码，不过 YYImageDecoder 的实现比 YYImageEncoder 更为复杂。 123456789101112131415161718192021222324252627@interface YYImageDecoder : NSObject@property (nullable, nonatomic, readonly) NSData *data; ///&lt; 图像数据@property (nonatomic, readonly) YYImageType type; ///&lt; 图像数据类型@property (nonatomic, readonly) CGFloat scale; ///&lt; 图像大小@property (nonatomic, readonly) NSUInteger frameCount; ///&lt; 图像帧数量@property (nonatomic, readonly) NSUInteger loopCount; ///&lt; 图像循环次数，0 无限循环@property (nonatomic, readonly) NSUInteger width; ///&lt; 图像画布宽度@property (nonatomic, readonly) NSUInteger height; ///&lt; 图像画布高度@property (nonatomic, readonly, getter=isFinalized) BOOL finalized;// 创建一个图像解码器- (instancetype)initWithScale:(CGFloat)scale NS_DESIGNATED_INITIALIZER;// 用新数据增量更新图像- (BOOL)updateData:(nullable NSData *)data final:(BOOL)final;// 方便用一个特殊的数据创建对应的解码器+ (nullable instancetype)decoderWithData:(NSData *)data scale:(CGFloat)scale;// 解码并返回给定索引对应的帧数据- (nullable YYImageFrame *)frameAtIndex:(NSUInteger)index decodeForDisplay:(BOOL)decodeForDisplay;// 返回给定索引对应的帧持续显示时长- (NSTimeInterval)frameDurationAtIndex:(NSUInteger)index;// 返回给定索引对应帧的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多- (nullable NSDictionary *)framePropertiesAtIndex:(NSUInteger)index;// 返回图片的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多- (nullable NSDictionary *)imageProperties;@end 可以看到 YYImageDecoder 暴露了一些关于解码图像的属性并提供了初始化解码器方法、图像解码方法以及访问图像帧信息的方法。不过上文也说过 YYImageDecoder 的实现比较复杂，我们接着看一下其内部变量结构： 1234567891011121314151617@implementation YYImageDecoder &#123; pthread_mutex_t _lock; // 递归锁 BOOL _sourceTypeDetected; // 是否推测图像源类型 CGImageSourceRef _source; // 图像源 yy_png_info *_apngSource; // 如果判定图像为 YYImageTypePNG 则会以 APNG 更新图像源#if YYIMAGE_WEBP_ENABLED WebPDemuxer *_webpSource; // 如果判定图像为 YYImageTypeWebP 则会议 WebP 更新图像源#endif UIImageOrientation _orientation; // 绘制方向 dispatch_semaphore_t _framesLock; // 针对于图像帧的锁 NSArray *_frames; ///&lt; Array&lt;_YYImageDecoderFrame *&gt;, without image BOOL _needBlend; // 是否需要混合 NSUInteger _blendFrameIndex; // 从帧索引混合到当前帧 CGContextRef _blendCanvas; // 混合画布&#125; _YYImageDecoderFrame 继承自 YYImageFrame 类作为 YYImageCoder 图像解码器 YYImageDecoder 使用的内部框架类存在，是对于一帧图像的数据封装提供了便于编/解码时需要访问的数据。 YYImageDecoder 内锁的选择可以看到作者在 YYImageDecoder 内部使用了两种锁： pthread_mutex_t _lock; dispatch_semaphore_t _framesLock; pthread_mutex_t 在解码器初始化过程中被以 PTHREAD_MUTEX_RECURSIVE 类型设置为了递归锁。 12345pthread_mutexattr_t attr;pthread_mutexattr_init (&amp;attr);pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);pthread_mutex_init (&amp;_lock, &amp;attr);pthread_mutexattr_destroy (&amp;attr); Note: 一般情况下一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 作者使用 dispatch_semaphore_t 作为图像帧数组的锁是因为 dispatch_semaphore_t 更加轻量且对于图像帧数组的临界操作比较快，不会造成长时间的阻塞，这种情况下 dispatch_semaphore_t 具有性能优势（Emmmmmm..老生常谈了，熟悉的同学不要抱怨，照顾一下后面的同学）。 YYImageDecoder 内的实现思路YYImageDecoder 内在初始化时会初始化锁并更新图像源数据，在更新图像源时调用 _updateSource 方法根据当前图像类型以作者对该类型封装好的底层数据结构和对应图像类型解码规则做解码，解码之后设置对应属性。 关于作者对不同格式的图像数据的底层封装源码感兴趣的读者可以参考本文文末的扩展阅读章节内容自行查阅。 关于 YYImageDecoder 的一些简单使用示例可以查看 YYImageCoder.h 了解。 总结 文章系统的分析了 YYImage 源码，希望各位读者在阅读本文之后可以对 YYImage 整体架构和设计思路有清晰的认识。 文章对 YYImage 的 Image 层级的三类图像（YYImage, YYFrameImage, YYSpriteSheetImage）分别解读，希望可以对各位读者关于这三类图像的组成原理和呈现动画的方式的理解有所帮助。 文章深入剖析了 YYAnimatedImageView 的内部实现，提炼出其设计思路以供读者探究。 笔者把自己在阅读源码中发现的值得分享的实现细节结合源码单独拎出来分析，希望各位读者可以在自己平时工作中遇到相似情况时能够多一些思路，封装项目组件时可以用到这些技巧。 文章写得比较用心（是我个人的原创文章，转载请注明出处 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。能力不足，水平有限，如果有任何问题欢迎在我的微博 @Lision 联系我，另外我的 GitHub 主页 里有很多有趣的小玩意哦~ 最后，希望我的文章可以为你带来价值~ 扩展阅读 libpng 官网关于 PNG 结构的官方说明 APNG 的维基百科 WebP 开发者文档"},{"title":"揭秘 YYModel 的魔法 0x02","comments":true,"permalink":"https://lision.me/yymodel0x02/","text":"前言在上文《揭秘 YYModel 的魔法（上）》 中主要剖析了 YYModel 的源码结构，并且分享了 YYClassInfo 与 NSObject+YYModel 内部有趣的实现细节。 紧接上篇，本文将解读 YYModel 关于 JSON 模型转换的源码，旨在揭秘 JSON 模型自动转换魔法。 索引 JSON 与 Model 相互转换 总结 JSON 与 Model 相互转换JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它易于人们阅读和编写，同时也易于机器解析和生成。它是基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使 JSON 成为理想的数据交换语言，点击 这里 了解更多关于 JSON 的信息。 Model 是 面向对象编程（Object Oriented Programming，简称 OOP）程序设计思想中的对象，OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。一般我们会根据业务需求来创建对象，在一些设计模式中（如 MVC 等）对象一般作为模型（Model），即对象建模。 JSON 与 Model 相互转换按转换方向分为两种： JSON to Model Model to JSON JSON to Model我们从 YYModel 的接口开始解读。 123456+ (instancetype)yy_modelWithJSON:(id)json &#123; // 将 json 转为字典 dic NSDictionary *dic = [self _yy_dictionaryWithJSON:json]; // 再通过 dic 得到 model 并返回 return [self yy_modelWithDictionary:dic];&#125; 上面接口把 JSON 转 Model 很简单的分为了两个子任务： JSON to NSDictionary NSDictionary to Model JSON to NSDictionary我们先看一下 _yy_dictionaryWithJSON 是怎么将 json 转为 NSDictionary 的。 12345678910111213141516171819202122232425262728+ (NSDictionary *)_yy_dictionaryWithJSON:(id)json &#123; // 入参判空 if (!json || json == (id)kCFNull) return nil; NSDictionary *dic = nil; NSData *jsonData = nil; // 根据 json 的类型对应操作 if ([json isKindOfClass:[NSDictionary class]]) &#123; // 如果是 NSDictionary 类则直接赋值 dic = json; &#125; else if ([json isKindOfClass:[NSString class]]) &#123; // 如果是 NSString 类则用 UTF-8 编码转 NSData jsonData = [(NSString *)json dataUsingEncoding : NSUTF8StringEncoding]; &#125; else if ([json isKindOfClass:[NSData class]]) &#123; // 如果是 NSData 则直接赋值给 jsonData jsonData = json; &#125; // jsonData 不为 nil，则表示上面的 2、3 情况中的一种 if (jsonData) &#123; // 利用 NSJSONSerialization 方法将 jsonData 转为 dic dic = [NSJSONSerialization JSONObjectWithData:jsonData options:kNilOptions error:NULL]; // 判断转换结果 if (![dic isKindOfClass:[NSDictionary class]]) dic = nil; &#125; return dic;&#125; 这个函数主要是根据入参的类型判断如何将其转为 NSDictionary 类型并返回。 其中 kCFNull 是 CoreFoundation 中 CFNull 的单例对象。如同 Foundation 框架中的 NSNull 一样，CFNull 是用来表示集合对象中的空值（不允许为 NULL）。CFNull 对象既不允许被创建也不允许被销毁，而是通过定义一个 CFNull 常量，即 kCFNull，在需要空值时使用。 官方文档：The CFNull opaque type defines a unique object used to represent null values in collection objects (which don’t allow NULL values). CFNull objects are neither created nor destroyed. Instead, a single CFNull constant object—kCFNull—is defined and is used wherever a null value is needed. NSJSONSerialization 是用于将 JSON 和等效的 Foundation 对象之间相互转换的对象。它在 iOS 7 以及 macOS 10.9（包含 iOS 7 和 macOS 10.9）之后是线程安全的。 代码中将 NSString 转为 NSData 用到了 NSUTF8StringEncoding，其中编码类型必须属于 JSON 规范中列出的 5 种支持的编码类型： UTF-8 UTF-16LE UTF-16BE UTF-32LE UTF-32BE 而用于解析的最高效的编码是 UTF-8 编码，所以作者这里使用 NSUTF8StringEncoding。 官方注释：The data must be in one of the 5 supported encodings listed in the JSON specification: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. The data may or may not have a BOM. The most efficient encoding to use for parsing is UTF-8, so if you have a choice in encoding the data passed to this method, use UTF-8. NSDictionary to Model现在我们要从 yy_modelWithJSON 接口中探究 yy_modelWithDictionary 是如何将 NSDictionary 转为 Model 的。 敲黑板！做好准备，这一小节介绍的代码是 YYModel 的精华哦~。 123456789101112131415161718192021+ (instancetype)yy_modelWithDictionary:(NSDictionary *)dictionary &#123; // 入参校验 if (!dictionary || dictionary == (id)kCFNull) return nil; if (![dictionary isKindOfClass:[NSDictionary class]]) return nil; // 使用当前类生成一个 _YYModelMeta 模型元类 Class cls = [self class]; _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls]; // 这里 _hasCustomClassFromDictionary 用于标识是否需要自定义返回类 // 属于模型转换附加功能，可以不用投入太多关注 if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123; cls = [cls modelCustomClassForDictionary:dictionary] ?: cls; &#125; // 调用 yy_modelSetWithDictionary 为新建的类实例 one 赋值，赋值成功则返回 one NSObject *one = [cls new]; // 所以这个函数中我们应该把注意力集中在 yy_modelSetWithDictionary if ([one yy_modelSetWithDictionary:dictionary]) return one; return nil;&#125; 代码中根据 _hasCustomClassFromDictionary 标识判断是否需要自定义返回模型的类型。这段代码属于 YYModel 的附加功能，为了不使大家分心，这里仅做简单介绍。 如果我们要在 JSON 转 Model 的过程中根据情况创建不同类型的实例，则可以在 Model 中实现接口： 1+ (nullable Class)modelCustomClassForDictionary:(NSDictionary *)dictionary; 来满足需求。当模型元初始化时会检测当前模型类是否可以响应上面的接口，如果可以响应则会把 _hasCustomClassFromDictionary 标识为 YES，所以上面才会出现这些代码： 123if (modelMeta-&gt;_hasCustomClassFromDictionary) &#123; cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;&#125; 嘛~ 我觉得这些附加的东西在阅读源码时很大程度上会分散我们的注意力，这次先详细的讲解一下，以后遇到类似的代码我们会略过，内部的实现大都与上述案例原理相同，感兴趣的同学可以自己研究哈。 我们应该把注意力集中在 yy_modelSetWithDictionary 上，这个函数（其实也是 NSObject+YYModel 暴露的接口）是根据字典初始化模型的实现方法。它的代码比较长，如果不想看可以跳过，在后面有解释。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364- (BOOL)yy_modelSetWithDictionary:(NSDictionary *)dic &#123; // 入参校验 if (!dic || dic == (id)kCFNull) return NO; if (![dic isKindOfClass:[NSDictionary class]]) return NO; // 根据自身类生成 _YYModelMeta 模型元类 _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(self)]; // 如果模型元类键值映射数量为 0 则 return NO，表示构建失败 if (modelMeta-&gt;_keyMappedCount == 0) return NO; // 忽略，该标识对应 modelCustomWillTransformFromDictionary 接口 if (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123; // 该接口类似 modelCustomTransformFromDictionary 接口，不过是在模型转换之前调用的 dic = [((id&lt;YYModel&gt;)self) modelCustomWillTransformFromDictionary:dic]; if (![dic isKindOfClass:[NSDictionary class]]) return NO; &#125; // 初始化模型设置上下文 ModelSetContext ModelSetContext context = &#123;0&#125;; context.modelMeta = (__bridge void *)(modelMeta); context.model = (__bridge void *)(self); context.dictionary = (__bridge void *)(dic); // 判断模型元键值映射数量与 JSON 所得字典的数量关系 if (modelMeta-&gt;_keyMappedCount &gt;= CFDictionaryGetCount((CFDictionaryRef)dic)) &#123; // 一般情况下他们的数量相等 // 特殊情况比如有的属性元会映射字典中的多个 key // 为字典中的每个键值对调用 ModelSetWithDictionaryFunction // 这句话是核心代码，一般情况下就是靠 ModelSetWithDictionaryFunction 通过字典设置模型 CFDictionaryApplyFunction((CFDictionaryRef)dic, ModelSetWithDictionaryFunction, &amp;context); // 判断模型中是否存在映射 keyPath 的属性元 if (modelMeta-&gt;_keyPathPropertyMetas) &#123; // 为每个映射 keyPath 的属性元执行 ModelSetWithPropertyMetaArrayFunction CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_keyPathPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; // 判断模型中是否存在映射多个 key 的属性元 if (modelMeta-&gt;_multiKeysPropertyMetas) &#123; // 为每个映射多个 key 的属性元执行 ModelSetWithPropertyMetaArrayFunction CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas, CFRangeMake(0, CFArrayGetCount((CFArrayRef)modelMeta-&gt;_multiKeysPropertyMetas)), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; &#125; else &#123; // 模型元键值映射数量少，则认为不存在映射多个 key 的属性元 // 直接为每个 modelMeta 属性元执行 ModelSetWithPropertyMetaArrayFunction CFArrayApplyFunction((CFArrayRef)modelMeta-&gt;_allPropertyMetas, CFRangeMake(0, modelMeta-&gt;_keyMappedCount), ModelSetWithPropertyMetaArrayFunction, &amp;context); &#125; // 忽略，该标识对应接口 modelCustomTransformFromDictionary if (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123; // 该接口用于当默认 JSON 转 Model 不适合模型对象时做额外的逻辑处理 // 我们也可以用这个接口来验证模型转换的结果 return [((id&lt;YYModel&gt;)self) modelCustomTransformFromDictionary:dic]; &#125; return YES;&#125; 代码已经注明必要中文注释，关于两处自定义扩展接口我们不再多说，由于代码比较长我们先来梳理一下 yy_modelSetWithDictionary 主要做了哪些事？ 入参校验 初始化模型元以及映射表校验 初始化模型设置上下文 ModelSetContext 为字典中的每个键值对调用 ModelSetWithDictionaryFunction 检验转换结果 模型设置上下文 ModelSetContext 其实就是一个包含模型元，模型实例以及待转换字典的结构体。 12345typedef struct &#123; void *modelMeta; ///&lt; 模型元 void *model; ///&lt; 模型实例，指向输出的模型 void *dictionary; ///&lt; 待转换字典&#125; ModelSetContext; 大家肯定都注意到了 ModelSetWithDictionaryFunction 函数，不论走哪条逻辑分支，最后都是调用这个函数把字典的 key（keypath）对应的 value 取出并赋值给 Model 的，那么我们就来看看这个函数的实现。 1234567891011121314151617181920// 字典键值对建模static void ModelSetWithDictionaryFunction(const void *_key, const void *_value, void *_context) &#123; // 拿到入参上下文 ModelSetContext *context = _context; // 取出上下文中模型元 __unsafe_unretained _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta); // 根据入参 _key 从模型元中取出映射表对应的属性元 __unsafe_unretained _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge id)(_key)]; // 拿到待赋值模型 __unsafe_unretained id model = (__bridge id)(context-&gt;model); // 遍历 propertyMeta，直到 propertyMeta-&gt;_next == nil while (propertyMeta) &#123; // 当前遍历的 propertyMeta 有 setter 方法，则调用 ModelSetValueForProperty 赋值 if (propertyMeta-&gt;_setter) &#123; // 核心方法，拎出来讲 ModelSetValueForProperty(model, (__bridge __unsafe_unretained id)_value, propertyMeta); &#125; propertyMeta = propertyMeta-&gt;_next; &#125;;&#125; ModelSetWithDictionaryFunction 函数的实现逻辑就是先通过模型设置上下文拿到带赋值模型，之后遍历当前的属性元（直到 propertyMeta-&gt;_next == nil），找到 setter 不为空的属性元通过 ModelSetValueForProperty 方法赋值。 ModelSetValueForProperty 函数是为模型中的属性赋值的实现方法，也是整个 YYModel 的核心代码。别紧张，这个函数写得很友好的，也就 300 多行而已 😜（无关紧要的内容我会尽量忽略掉），不过忽略的太多会影响代码阅读的连续性，如果嫌长可以不看，文章后面会总结一下这个函数的实现逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209static void ModelSetValueForProperty(__unsafe_unretained id model, __unsafe_unretained id value, __unsafe_unretained _YYModelPropertyMeta *meta) &#123; // 如果属性是一个 CNumber，即输入 int、uint…… if (meta-&gt;_isCNumber) &#123; // 转为 NSNumber 之后赋值 NSNumber *num = YYNSNumberCreateFromID(value); // 这里 ModelSetNumberToProperty 封装了给属性元赋值 NSNumber 的操作 ModelSetNumberToProperty(model, num, meta); if (num) [num class]; // hold the number &#125; else if (meta-&gt;_nsType) &#123; // 如果属性属于 nsType，即 NSString、NSNumber…… if (value == (id)kCFNull) &#123; // 为空，则赋值 nil（通过属性元 _setter 方法使用 objc_msgSend 将 nil 赋值） ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)nil); &#125; else &#123; // 不为空 switch (meta-&gt;_nsType) &#123; // NSString 或 NSMutableString case YYEncodingTypeNSString: case YYEncodingTypeNSMutableString: &#123; // 处理可能的 value 类型：NSString，NSNumber，NSData，NSURL，NSAttributedString // 对应的分支就是把 value 转为 NSString 或者 NSMutableString，之后调用 setter 赋值 ... &#125; break; // NSValue，NSNumber 或 NSDecimalNumber case YYEncodingTypeNSValue: case YYEncodingTypeNSNumber: case YYEncodingTypeNSDecimalNumber: &#123; // 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换） ... &#125; break; // NSData 或 NSMutableData case YYEncodingTypeNSData: case YYEncodingTypeNSMutableData: &#123; // 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换） ... &#125; break; // NSDate case YYEncodingTypeNSDate: &#123; // 考虑可能的 value 类型：NSDate 或 NSString // 转换为 NSDate 之后赋值 ... &#125; break; // NSURL case YYEncodingTypeNSURL: &#123; // 考虑可能的 value 类型：NSURL 或 NSString // 转换为 NSDate 之后赋值（这里对 NSString 的长度判断是否赋值 nil） ... &#125; break; // NSArray 或 NSMutableArray case YYEncodingTypeNSArray: case YYEncodingTypeNSMutableArray: &#123; // 对属性元的泛型判断 if (meta-&gt;_genericCls) &#123; // 如果存在泛型 NSArray *valueArr = nil; // value 所属 NSArray 则直接赋值，如果所属 NSSet 类则转为 NSArray if ([value isKindOfClass:[NSArray class]]) valueArr = value; else if ([value isKindOfClass:[NSSet class]]) valueArr = ((NSSet *)value).allObjects; // 遍历刚才通过 value 转换来的 valueArr if (valueArr) &#123; NSMutableArray *objectArr = [NSMutableArray new]; for (id one in valueArr) &#123; // 遇到 valueArr 中的元素属于泛型类，直接加入 objectArr if ([one isKindOfClass:meta-&gt;_genericCls]) &#123; [objectArr addObject:one]; &#125; else if ([one isKindOfClass:[NSDictionary class]]) &#123; // 遇到 valueArr 中的元素是字典类， Class cls = meta-&gt;_genericCls; // 忽略 if (meta-&gt;_hasCustomClassFromDictionary) &#123; cls = [cls modelCustomClassForDictionary:one]; if (!cls) cls = meta-&gt;_genericCls; // for xcode code coverage &#125; // 还记得我们直接的起点 yy_modelSetWithDictionary，将字典转模型 // 我觉得这应该算是一个间接递归调用 // 如果设计出的模型是无限递归（从前有座山，山上有座庙的故事），那么肯定会慢 NSObject *newOne = [cls new]; [newOne yy_modelSetWithDictionary:one]; // 转化成功机也加入 objectArr if (newOne) [objectArr addObject:newOne]; &#125; &#125; // 最后将得到的 objectArr 赋值给属性 ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, objectArr); &#125; &#125; else &#123; // 没有泛型，嘛~ 判断一下 value 的可能所属类型 NSArray 或 NSSet // 转换赋值（涉及 mutable） ... &#125; &#125; break; // NSDictionary 或 NSMutableDictionary case YYEncodingTypeNSDictionary: case YYEncodingTypeNSMutableDictionary: &#123; // 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理） ... &#125; break; // NSSet 或 NSMutableSet case YYEncodingTypeNSSet: case YYEncodingTypeNSMutableSet: &#123; // 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理） ... &#125; default: break; &#125; &#125; &#125; else &#123; // 属性元不属于 CNumber 和 nsType BOOL isNull = (value == (id)kCFNull); switch (meta-&gt;_type &amp; YYEncodingTypeMask) &#123; // id case YYEncodingTypeObject: &#123; if (isNull) &#123; // 空，赋值 nil ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)nil); &#125; else if ([value isKindOfClass:meta-&gt;_cls] || !meta-&gt;_cls) &#123; // 属性元与 value 从属于同一个类，则直接赋值 ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)value); &#125; else if ([value isKindOfClass:[NSDictionary class]]) &#123; // 嘛~ value 从属于 NSObject *one = nil; // 如果属性元有 getter 方法，则通过 getter 获取到实例 if (meta-&gt;_getter) &#123; one = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, meta-&gt;_getter); &#125; if (one) &#123; // 用 yy_modelSetWithDictionary 输出化属性实例对象 [one yy_modelSetWithDictionary:value]; &#125; else &#123; Class cls = meta-&gt;_cls; // 略过 if (meta-&gt;_hasCustomClassFromDictionary) &#123; cls = [cls modelCustomClassForDictionary:value]; if (!cls) cls = meta-&gt;_genericCls; // for xcode code coverage &#125; // 用 yy_modelSetWithDictionary 输出化属性实例对象，赋值 one = [cls new]; [one yy_modelSetWithDictionary:value]; ((void (*)(id, SEL, id))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (id)one); &#125; &#125; &#125; break; // Class case YYEncodingTypeClass: &#123; if (isNull) &#123; // 空，赋值(Class)NULL，由于 Class 其实是 C 语言定义的结构体，所以使用 NULL // 关于 nil，Nil，NULL，NSNull，kCFNull 的横向比较，我会单独拎出来在下面介绍 ((void (*)(id, SEL, Class))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (Class)NULL); &#125; else &#123; // 判断 value 可能的类型 NSString 或判断 class_isMetaClass(object_getClass(value)) // 如果满足条件则赋值 ... &#125; &#125; break; // SEL case YYEncodingTypeSEL: &#123; // 判空，赋值(SEL)NULL // 否则转换类型 SEL sel = NSSelectorFromString(value); 然后赋值 ... &#125; break; // block case YYEncodingTypeBlock: &#123; // 判空，赋值(void (^)())NULL // 否则判断类型 [value isKindOfClass:YYNSBlockClass()] 之后赋值 ... &#125; break; // struct、union、char[n]，关于 union 共同体感兴趣的同学可以自己 google，这里简单介绍一下 // union 共同体，类似 struct 的存在，但是 union 每个成员会用同一个存储空间，只能存储最后一个成员的信息 case YYEncodingTypeStruct: case YYEncodingTypeUnion: case YYEncodingTypeCArray: &#123; if ([value isKindOfClass:[NSValue class]]) &#123; // 涉及 Type Encodings const char *valueType = ((NSValue *)value).objCType; const char *metaType = meta-&gt;_info.typeEncoding.UTF8String; // 比较 valueType 与 metaType 是否相同，相同（strcmp(a, b) 返回 0）则赋值 if (valueType &amp;&amp; metaType &amp;&amp; strcmp(valueType, metaType) == 0) &#123; [model setValue:value forKey:meta-&gt;_name]; &#125; &#125; &#125; break; // void* 或 char* case YYEncodingTypePointer: case YYEncodingTypeCString: &#123; if (isNull) &#123; // 判空，赋值(void *)NULL ((void (*)(id, SEL, void *))(void *) objc_msgSend)((id)model, meta-&gt;_setter, (void *)NULL); &#125; else if ([value isKindOfClass:[NSValue class]]) &#123; // 涉及 Type Encodings NSValue *nsValue = value; if (nsValue.objCType &amp;&amp; strcmp(nsValue.objCType, &quot;^v&quot;) == 0) &#123; ((void (*)(id, SEL, void *))(void *) objc_msgSend)((id)model, meta-&gt;_setter, nsValue.pointerValue); &#125; &#125; &#125; default: break; &#125; &#125;&#125; 额 😓 我是真的已经忽略掉很多代码了，没办法还是有点长。其实代码逻辑还是很简单的，只是模型赋值涉及的编码类型等琐碎逻辑比较多导致代码量比较大，我们一起来总结一下核心代码的实现逻辑。 根据属性元类型划分代码逻辑 如果属性元是 CNumber 类型，即 int、uint 之类，则使用 ModelSetNumberToProperty 赋值 如果属性元属于 NSType 类型，即 NSString、NSNumber 之类，则根据类型转换中可能涉及到的对应类型做逻辑判断并赋值（可以去上面代码中查看具体实现逻辑） 如果属性元不属于 CNumber 和 NSType，则猜测为 id，Class，SEL，Block，struct、union、char[n]，void 或 char 类型并且做出相应的转换和赋值 嘛~ 其实上面的代码除了长以外逻辑还是很简单的，总结起来就是根据可能出现的类型去做出对应的逻辑操作，建议各位有时间还是去读下源码，尤其是自己项目中用到 YYModel 的同学。相信看完之后会对 YYModel 属性赋值一清二楚，这样在使用 YYModel 的日常中出现任何问题都可以心中有数，改起代码自然如有神助哈。 额…考虑到 NSDictionary to Model 的整个过程代码量不小，我花了一些时间将其逻辑总结归纳为一张图： 希望可以尽自己的努力让文章的表述变得更直白。 Model to JSON 相比于 JSON to Model 来说，Model to JSON 更简单一些。其中因为 NSJSONSerialization 在对 JSON 的转换时做了一些规定： 顶级对象是 NSArray 或者 NSDictionary 类型 所有的对象都是 NSString, NSNumber, NSArray, NSDictionary, 或 NSNull 的实例 所有字典中的 key 都是一个 NSString 实例 Numbers 是除去无穷大和 NaN 的其他表示 Note: 上文出自 NSJSONSerialization 官方文档。 知道了这一点后，我们就可以从 YYModel 的 Model to JSON 接口 yy_modelToJSONObject 处开始解读源码了。 12345678- (id)yy_modelToJSONObject &#123; // 递归转换模型到 JSON id jsonObject = ModelToJSONObjectRecursive(self); if ([jsonObject isKindOfClass:[NSArray class]]) return jsonObject; if ([jsonObject isKindOfClass:[NSDictionary class]]) return jsonObject; return nil;&#125; 嘛~ 一共 4 行代码，只需要关注一下第一行代码中的 ModelToJSONObjectRecursive 方法，Objective-C 的语言特性决定了从函数名称即可无需注释看懂代码，这个方法从名字上就可以 get 到它是通过递归方法使 Model 转换为 JSON 的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141// 递归转换模型到 JSON，如果转换异常则返回 nilstatic id ModelToJSONObjectRecursive(NSObject *model) &#123; // 判空或者可以直接返回的对象，则直接返回 if (!model || model == (id)kCFNull) return model; if ([model isKindOfClass:[NSString class]]) return model; if ([model isKindOfClass:[NSNumber class]]) return model; // 如果 model 从属于 NSDictionary if ([model isKindOfClass:[NSDictionary class]]) &#123; // 如果可以直接转换为 JSON 数据，则返回 if ([NSJSONSerialization isValidJSONObject:model]) return model; NSMutableDictionary *newDic = [NSMutableDictionary new]; // 遍历 model 的 key 和 value [((NSDictionary *)model) enumerateKeysAndObjectsUsingBlock:^(NSString *key, id obj, BOOL *stop) &#123; NSString *stringKey = [key isKindOfClass:[NSString class]] ? key : key.description; if (!stringKey) return; // 递归解析 value id jsonObj = ModelToJSONObjectRecursive(obj); if (!jsonObj) jsonObj = (id)kCFNull; newDic[stringKey] = jsonObj; &#125;]; return newDic; &#125; // 如果 model 从属于 NSSet if ([model isKindOfClass:[NSSet class]]) &#123; // 如果能够直接转换 JSON 对象，则直接返回 // 否则遍历，按需要递归解析 ... &#125; if ([model isKindOfClass:[NSArray class]]) &#123; // 如果能够直接转换 JSON 对象，则直接返回 // 否则遍历，按需要递归解析 ... &#125; // 对 NSURL, NSAttributedString, NSDate, NSData 做相应处理 if ([model isKindOfClass:[NSURL class]]) return ((NSURL *)model).absoluteString; if ([model isKindOfClass:[NSAttributedString class]]) return ((NSAttributedString *)model).string; if ([model isKindOfClass:[NSDate class]]) return [YYISODateFormatter() stringFromDate:(id)model]; if ([model isKindOfClass:[NSData class]]) return nil; // 用 [model class] 初始化一个模型元 _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model class]]; // 如果映射表为空，则不做解析直接返回 nil if (!modelMeta || modelMeta-&gt;_keyMappedCount == 0) return nil; // 性能优化细节，使用 __unsafe_unretained 来避免在下面遍历 block 中直接使用 result 指针造成的不必要 retain 与 release 开销 NSMutableDictionary *result = [[NSMutableDictionary alloc] initWithCapacity:64]; __unsafe_unretained NSMutableDictionary *dic = result; // 遍历模型元属性映射字典 [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(NSString *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, BOOL *stop) &#123; // 如果遍历当前属性元没有 getter 方法，跳过 if (!propertyMeta-&gt;_getter) return; id value = nil; // 如果属性元属于 CNumber，即其 type 是 int、float、double 之类的 if (propertyMeta-&gt;_isCNumber) &#123; // 从属性中利用 getter 方法得到对应的值 value = ModelCreateNumberFromProperty(model, propertyMeta); &#125; else if (propertyMeta-&gt;_nsType) &#123; // 属性元属于 nsType，即 NSString 之类 // 利用 getter 方法拿到 value id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); // 对拿到的 value 递归解析 value = ModelToJSONObjectRecursive(v); &#125; else &#123; // 根据属性元的 type 做相应处理 switch (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123; // id，需要递归解析，如果解析失败则返回 nil case YYEncodingTypeObject: &#123; id v = ((id (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = ModelToJSONObjectRecursive(v); if (value == (id)kCFNull) value = nil; &#125; break; // Class，转 NSString，返回 Class 名称 case YYEncodingTypeClass: &#123; Class v = ((Class (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromClass(v) : nil; &#125; break; // SEL，转 NSString，返回给定 SEL 的字符串表现形式 case YYEncodingTypeSEL: &#123; SEL v = ((SEL (*)(id, SEL))(void *) objc_msgSend)((id)model, propertyMeta-&gt;_getter); value = v ? NSStringFromSelector(v) : nil; &#125; break; default: break; &#125; &#125; // 如果 value 还是没能解析，则跳过 if (!value) return; // 当前属性元是 KeyPath 映射，即 a.b.c 之类 if (propertyMeta-&gt;_mappedToKeyPath) &#123; NSMutableDictionary *superDic = dic; NSMutableDictionary *subDic = nil; // _mappedToKeyPath 是 a.b.c 根据 &#x27;.&#x27; 拆分成的字符串数组，遍历 _mappedToKeyPath for (NSUInteger i = 0, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123; NSString *key = propertyMeta-&gt;_mappedToKeyPath[i]; // 遍历到结尾 if (i + 1 == max) &#123; // 如果结尾的 key 为 nil，则使用 value 赋值 if (!superDic[key]) superDic[key] = value; break; &#125; // 用 subDic 拿到当前 key 对应的值 subDic = superDic[key]; // 如果 subDic 存在 if (subDic) &#123; // 如果 subDic 从属于 NSDictionary if ([subDic isKindOfClass:[NSDictionary class]]) &#123; // 将 subDic 的 mutable 版本赋值给 superDic[key] subDic = subDic.mutableCopy; superDic[key] = subDic; &#125; else &#123; break; &#125; &#125; else &#123; // 将 NSMutableDictionary 赋值给 superDic[key] // 注意这里使用 subDic 间接赋值是有原因的，原因就在下面 subDic = [NSMutableDictionary new]; superDic[key] = subDic; &#125; // superDic 指向 subDic，这样在遍历 _mappedToKeyPath 时即可逐层解析 // 这就是上面先把 subDic 转为 NSMutableDictionary 的原因 superDic = subDic; subDic = nil; &#125; &#125; else &#123; // 如果不是 KeyPath 则检测 dic[propertyMeta-&gt;_mappedToKey]，如果为 nil 则赋值 value if (!dic[propertyMeta-&gt;_mappedToKey]) &#123; dic[propertyMeta-&gt;_mappedToKey] = value; &#125; &#125; &#125;]; // 忽略，对应 modelCustomTransformToDictionary 接口 if (modelMeta-&gt;_hasCustomTransformToDictionary) &#123; // 用于在默认的 Model 转 JSON 过程不适合当前 Model 类型时提供自定义额外过程 // 也可以用这个方法来验证转换结果 BOOL suc = [((id&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic]; if (!suc) return nil; &#125; return result;&#125; 额…代码还是有些长，不过相比于之前 JSON to Model 方向上由 yy_modelSetWithDictionary，ModelSetWithDictionaryFunction 和 ModelSetValueForProperty 三个方法构成的间接递归来说算是非常简单了，那么总结一下上面的代码逻辑。 判断入参，如果满足条件可以直接返回 如果 Model 从属于 NSType，则根据不同的类型做逻辑处理 如果上面条件不被满足，则用 Model 的 Class 初始化一个模型元 _YYModelMeta 判断模型元的映射关系，遍历映射表拿到对应键值对并存入字典中并返回 Note: 这里有一个性能优化的细节，用 __unsafe_unretained 修饰的 dic 指向我们最后要 return 的 NSMutableDictionary *result，看作者的注释：// avoid retain and release in block 是为了避免直接使用 result 在后面遍历映射表的代码块中不必要的 retain 和 release 操作以节省开销。 总结 文章紧接上文《揭秘 YYModel 的魔法（上）》中对 YYModel 代码结构的讲解后将重点放到了对 JSON 模型相互转换的实现逻辑上。 从 JSON 模型的转换方向上划分，将 YYModel 的 JSON 模型转换过程正反方向剖析揭秘，希望可以解开大家对 JSON 模型自动转换的疑惑。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"揭秘 YYModel 的魔法 0x01","comments":true,"permalink":"https://lision.me/yymodel0x01/","text":"前言iOS 开发中少不了各种各样的模型，不论是采用 MVC、MVP 还是 MVVM 设计模式都逃不过 Model。 那么大家在使用 Model 的时候肯定遇到过一个问题，即接口传递过来的数据（一般是 JSON 格式）需要转换为 iOS 内我们能直接使用的模型（类）。iOS 开发早期第三方框架没有那么多，大家可能会手写相关代码，但是随着业务的扩展，模型的增多，这些没什么技术含量的代码只是在重复的浪费我们的劳动力而已。 这时候就需要一种工具来帮助我们把劳动力从这些无意义的繁琐代码中解放出来，于是 GitHub 上出现了很多解决此类问题的第三方库，诸如 Mantle、JSONModel、MJExtension 以及 YYModel 等等。 这些库的神奇之处在于它们提供了模型与 JSON 数据的自动转换功能，仿佛具有魔法一般！本文将通过剖析 YYModel 源码一步一步破解这“神奇”的魔法。 YYModel 是一个高性能 iOS/OSX 模型转换框架（该项目是 YYKit 组件之一）。YYKit 在我之前的文章【从 YYCache 源码 Get 到如何设计一个优秀的缓存】中已经很详细的介绍过了，感兴趣的同学可以点进去了解一下。 YYModel 是一个非常轻量级的 JSON 模型自动转换库，代码风格良好且思路清晰，可以从源码中看到作者对 Runtime 深厚的理解。难能可贵的是 YYModel 在其轻量级的代码下还保留着自动类型转换，类型安全，无侵入等特性，并且具有接近手写解析代码的超高性能。 处理 GithubUser 数据 10000 次耗时统计 (iPhone 6): 索引 YYModel 简介 YYClassInfo 剖析 NSObject+YYModel 探究 JSON 与 Model 相互转换 总结 YYModel 简介 撸了一遍 YYModel 的源码，果然是非常轻量级的 JSON 模型自动转换库，加上 YYModel.h 一共也只有 5 个文件。 抛开 YYModel.h 来看，其实只有 YYClassInfo 和 NSObject+YYModel 两个模块。 YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用。 NSObject+YYModel 负责提供方便调用的接口以及实现具体的模型转换逻辑（借助 YYClassInfo 中的封装）。 YYClassInfo 剖析 前面说到 YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用，我觉得如果需要与 Runtime 层级的结构体做对比的话，没什么比表格来的更简单直观了： YYClassInfo Runtime YYClassIvarInfo objc_ivar YYClassMethodInfo objc_method YYClassPropertyInfo property_t YYClassInfo objc_class Note: 本次比较基于 Runtime 源码 723 版本。 安~ 既然是剖析肯定不会列个表格这样子哈。 YYClassIvarInfo &amp;&amp; objc_ivar我把 YYClassIvarInfo 看做是作者对 Runtime 层 objc_ivar 结构体的封装，objc_ivar 是 Runtime 中表示变量的结构体。 YYClassIvarInfo 123456789@interface YYClassIvarInfo : NSObject@property (nonatomic, assign, readonly) Ivar ivar; ///&lt; 变量，对应 objc_ivar@property (nonatomic, strong, readonly) NSString *name; ///&lt; 变量名称，对应 ivar_name@property (nonatomic, assign, readonly) ptrdiff_t offset; ///&lt; 变量偏移量，对应 ivar_offset@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; 变量类型编码，通过 ivar_getTypeEncoding 函数得到@property (nonatomic, assign, readonly) YYEncodingType type; ///&lt; 变量类型，通过 YYEncodingGetType 方法从类型编码中得到- (instancetype)initWithIvar:(Ivar)ivar;@end objc_ivar 12345678struct objc_ivar &#123; char * _Nullable ivar_name OBJC2_UNAVAILABLE; // 变量名称 char * _Nullable ivar_type OBJC2_UNAVAILABLE; // 变量类型 int ivar_offset OBJC2_UNAVAILABLE; // 变量偏移量#ifdef __LP64__ // 如果已定义 __LP64__ 则表示正在构建 64 位目标 int space OBJC2_UNAVAILABLE; // 变量空间#endif&#125; Note: 日常开发中 NSString 类型的属性我们都会用 copy 来修饰，而 YYClassIvarInfo 中的 name 和 typeEncoding 属性都用 strong 修饰。因为其内部是先通过 Runtime 方法拿到 const char * 之后通过 stringWithUTF8String 方法转为 NSString 的。所以即便是 NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。 囧~ 不知道讲的这么细会不会反而引起反感，如果对文章有什么建议可以联系我 @薛定谔的猹 。 Note: 类型编码，关于 YYClassIvarInfo 中的 YYEncodingType 类型属性 type 的解析代码篇幅很长，而且没有搬出来的必要，可以参考官方文档 Type Encodings 和 Declared Properties 阅读这部分源码。 YYClassMethodInfo &amp;&amp; objc_method相应的，YYClassMethodInfo 则是作者对 Runtime 中 objc_method 的封装，objc_method 在 Runtime 是用来定义方法的结构体。 YYClassMethodInfo 1234567891011@interface YYClassMethodInfo : NSObject@property (nonatomic, assign, readonly) Method method; ///&lt; 方法@property (nonatomic, strong, readonly) NSString *name; ///&lt; 方法名称@property (nonatomic, assign, readonly) SEL sel; ///&lt; 方法选择器@property (nonatomic, assign, readonly) IMP imp; ///&lt; 方法实现，指向实现方法函数的函数指针@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; 方法参数和返回类型编码@property (nonatomic, strong, readonly) NSString *returnTypeEncoding; ///&lt; 返回值类型编码@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *argumentTypeEncodings; ///&lt; 参数类型编码数组- (instancetype)initWithMethod:(Method)method;@end objc_method 12345struct objc_method &#123; SEL _Nonnull method_name OBJC2_UNAVAILABLE; // 方法名称 char * _Nullable method_types OBJC2_UNAVAILABLE; // 方法类型 IMP _Nonnull method_imp OBJC2_UNAVAILABLE; // 方法实现（函数指针）&#125; 可以看到基本也是一一对应的关系，除了类型编码的问题作者为了方便使用在封装时进行了扩展。 为了照顾对 Runtime 还没有一定了解的读者，我这里简单的解释一下 objc_method 结构体（都是我自己的认知，欢迎讨论）： SEL，selector 在 Runtime 中的表现形式，可以理解为方法选择器 1typedef struct objc_selector *SEL; IMP，函数指针，指向具体实现逻辑的函数 12345#if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ ); #elsetypedef id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...); #endif 关于更多 Runtime 相关的知识由于篇幅原因（真的写不完）就不在这篇文章介绍了，我推荐大家去鱼神的文章 Objective-C Runtime 学习（因为我最早接触 Runtime 就是通过这篇文章，笑~）。 有趣的是，鱼神的文章中对 SEL 的描述有一句“其实它就是个映射到方法的 C 字符串”，但是他在文章中没有介绍出处。本着对自己文章质量负责的原则，对于一切没有出处的表述都应该持有怀疑的态度，所以我下面讲一下自己的对于 SEL 的理解。 撸了几遍 Runtime 源码，发现不论是 objc-runtime-new 还是 objc-runtime-old 中都用 SEL 类型作为方法结构体的 name 属性类型，而且通过以下源码： 12345OBJC_EXPORT SEL _Nonnull sel_registerName(const char * _Nonnull str) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0);OBJC_EXPORT const char * _Nonnull sel_getName(SEL _Nonnull sel) OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0); 可以看到通过一个 const char * 类型的字符串即可在 Runtime 系统中注册并返回一个 SEL，方法的名称则会映射到这个 SEL。 官方注释：Registers a method with the Objective-C runtime system, maps the method name to a selector, and returns the selector value. 所以我觉得 SEL 和 char * 的的确确是有某种一一对应的映射关系，不过 SEL 的本质是否是 char * 就要打一个问号了。因为我在调试 SEL 阶段发现 SEL 内还有一个当前 SEL 的指针，与 char * 不同的是当 char * 赋值之后当前 char * 变量指针指向字符串首字符，而 SEL 则是 ，即我们无法直接看到它。 所以我做了一个无聊的测试，用相同的字符串初始化一个 char * 实例与一个 SEL 实例，之后尝试打印它们，有趣的是不论我使用 %s 还是 %c 都可以从两个实例中得到相同的打印输出，不知道鱼神是否做过相同的测试（笑~） 嘛~ 经过验证我们可以肯定 SEL 和 char * 存在某种映射关系，可以相互转换。同时猜测 SEL 本质上就是 char *，如果有哪位知道 SEL 与 char * 确切关系的可以留言讨论哟。 YYClassPropertyInfo &amp;&amp; property_tYYClassPropertyInfo 是作者对 property_t 的封装，property_t 在 Runtime 中是用来表示属性的结构体。 YYClassPropertyInfo 12345678910111213@interface YYClassPropertyInfo : NSObject@property (nonatomic, assign, readonly) objc_property_t property; ///&lt; 属性@property (nonatomic, strong, readonly) NSString *name; ///&lt; 属性名称@property (nonatomic, assign, readonly) YYEncodingType type; ///&lt; 属性类型@property (nonatomic, strong, readonly) NSString *typeEncoding; ///&lt; 属性类型编码@property (nonatomic, strong, readonly) NSString *ivarName; ///&lt; 变量名称@property (nullable, nonatomic, assign, readonly) Class cls; ///&lt; 类型@property (nullable, nonatomic, strong, readonly) NSArray&lt;NSString *&gt; *protocols; ///&lt; 属性相关协议@property (nonatomic, assign, readonly) SEL getter; ///&lt; getter 方法选择器@property (nonatomic, assign, readonly) SEL setter; ///&lt; setter 方法选择器- (instancetype)initWithProperty:(objc_property_t)property;@end property_t 1234struct property_t &#123; const char *name; // 名称 const char *attributes; // 修饰&#125;; 为什么说 YYClassPropertyInfo 是作者对 property_t 的封装呢？ 123456789101112131415// runtime.htypedef struct objc_property *objc_property_t;// objc-private.h#if __OBJC2__typedef struct property_t *objc_property_t;#elsetypedef struct old_property *objc_property_t;#endif// objc-runtime-new.hstruct property_t &#123; const char *name; const char *attributes;&#125;; 这里唯一值得注意的就是 getter 与 setter 方法了。 123456789101112131415161718192021// 先尝试获取属性的 getter 与 setter case &#x27;G&#x27;: &#123; type |= YYEncodingTypePropertyCustomGetter; if (attrs[i].value) &#123; _getter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]); &#125; &#125; break; case &#x27;S&#x27;: &#123; type |= YYEncodingTypePropertyCustomSetter; if (attrs[i].value) &#123; _setter = NSSelectorFromString([NSString stringWithUTF8String:attrs[i].value]); &#125; &#125; break; // 如果没有则按照标准规则自己造if (!_getter) &#123; _getter = NSSelectorFromString(_name);&#125;if (!_setter) &#123; _setter = NSSelectorFromString([NSString stringWithFormat:@&quot;set%@%@:&quot;, [_name substringToIndex:1].uppercaseString, [_name substringFromIndex:1]]);&#125; YYClassInfo &amp;&amp; objc_class最后作者用 YYClassInfo 封装了 objc_class，objc_class 在 Runtime 中表示一个 Objective-C 类。 YYClassInfo 123456789101112131415161718@interface YYClassInfo : NSObject@property (nonatomic, assign, readonly) Class cls; ///&lt; 类@property (nullable, nonatomic, assign, readonly) Class superCls; ///&lt; 超类@property (nullable, nonatomic, assign, readonly) Class metaCls; ///&lt; 元类@property (nonatomic, readonly) BOOL isMeta; ///&lt; 元类标识，自身是否为元类@property (nonatomic, strong, readonly) NSString *name; ///&lt; 类名称@property (nullable, nonatomic, strong, readonly) YYClassInfo *superClassInfo; ///&lt; 父类（超类）信息@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassIvarInfo *&gt; *ivarInfos; ///&lt; 变量信息@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassMethodInfo *&gt; *methodInfos; ///&lt; 方法信息@property (nullable, nonatomic, strong, readonly) NSDictionary&lt;NSString *, YYClassPropertyInfo *&gt; *propertyInfos; ///&lt; 属性信息- (void)setNeedUpdate;- (BOOL)needUpdate;+ (nullable instancetype)classInfoWithClass:(Class)cls;+ (nullable instancetype)classInfoWithClassName:(NSString *)className;@end objc_class 1234567891011121314151617181920// objc.htypedef struct objc_class *Class;// runtime.hstruct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY; // isa 指针#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; // 父类（超类）指针 const char * _Nonnull name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 版本 long info OBJC2_UNAVAILABLE; // 信息 long instance_size OBJC2_UNAVAILABLE; // 初始尺寸 struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; // 变量列表 struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; // 方法列表 struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; // 缓存 struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; // 协议列表#endif&#125; OBJC2_UNAVAILABLE; 额… 看来想完全避开 Runtime 的知识来讲 YYModel 源码是不现实的。这里简单介绍一下 Runtime 中关于 Class 的知识以便阅读，已经熟悉这方面知识的同学就当温习一下好了。 isa 指针，用于找到所属类，类对象的 isa 一般指向对应元类。 元类，由于 objc_class 继承于 objc_object，即类本身同时也是一个对象，所以 Runtime 库设计出元类用以表述类对象自身所具备的元数据。 cache，实际上当一个对象收到消息时并不会直接在 isa 指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了。为了优化方法调用的效率，加入了 cache，也就是说在收到消息时，会先去 cache 中查找，找不到才会去像上图所示遍历查找，相信苹果为了提升缓存命中率，应该也花了一些心思（笑~）。 version，我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。 关于 Version 的官方描述：Classes derived from the Foundation framework NSObject class can set the class-definition version number using the setVersion: class method, which is implemented using the class_setVersion function. YYClassInfo 的初始化细节关于 YYClassInfo 的初始化细节我觉得还是有必要分享出来的。 12345678910111213141516171819202122232425262728293031323334353637383940+ (instancetype)classInfoWithClass:(Class)cls &#123; // 判空入参 if (!cls) return nil; // 单例缓存 classCache 与 metaCache，对应缓存类和元类 static CFMutableDictionaryRef classCache; static CFMutableDictionaryRef metaCache; static dispatch_once_t onceToken; static dispatch_semaphore_t lock; dispatch_once(&amp;onceToken, ^&#123; classCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); metaCache = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); // 这里把 dispatch_semaphore 当做锁来使用（当信号量只有 1 时） lock = dispatch_semaphore_create(1); &#125;); // 初始化之前，首先会根据当前 YYClassInfo 是否为元类去对应的单例缓存中查找 // 这里使用了上面的 dispatch_semaphore 加锁，保证单例缓存的线程安全 dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); YYClassInfo *info = CFDictionaryGetValue(class_isMetaClass(cls) ? metaCache : classCache, (__bridge const void *)(cls)); // 如果找到了，且找到的信息需要更新的话则执行更新操作 if (info &amp;&amp; info-&gt;_needUpdate) &#123; [info _update]; &#125; dispatch_semaphore_signal(lock); // 如果没找到，才会去老实初始化 if (!info) &#123; info = [[YYClassInfo alloc] initWithClass:cls]; if (info) &#123; // 初始化成功 // 线程安全 dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER); // 根据初始化信息选择向对应的类/元类缓存注入信息，key = cls，value = info CFDictionarySetValue(info.isMeta ? metaCache : classCache, (__bridge const void *)(cls), (__bridge const void *)(info)); dispatch_semaphore_signal(lock); &#125; &#125; return info;&#125; 总结一下初始化的主要步骤： 创建单例缓存，类缓存和元类缓存 使用 dispatch_semaphore 作为锁保证缓存线程安全 初始化前先去缓存中查找是否已经向缓存中注册过当前要初始化的 YYClassInfo 如果查找到缓存对象，则判断缓存对象是否需要更新并执行相关操作 如果缓存中未找到缓存对象则初始化 初始化成功后向缓存中注册该 YYClassInfo 实例 其中，使用缓存可以有效减少我们在 JSON 模型转换时反复初始化 YYClassInfo 带来的开销，而 dispatch_semaphore 在信号量为 1 时是可以当做锁来使用的，虽然它在阻塞时效率超低，但是对于代码中的缓存阻塞这里属于低频事件，使用 dispatch_semaphore 在非阻塞状态下性能很高，这里锁的选择非常合适。 关于 YYClassInfo 的更新首先 YYClassInfo 是作者对应 objc_class 封装出来的类，所以理应在其对应的 objc_class 实例发生变化时更新。那么 objc_class 什么时候会发生变化呢？ 嘛~ 比如你使用了 class_addMethod 方法为你的模型类加入了一个方法等等。 YYClassInfo 有一个私有 BOOL 类型参数 _needUpdate 用以表示当前的 YYClassInfo 实例是否需要更新，并且提供了 - (void)setNeedUpdate; 接口方便我们在更改了自己的模型类时调用其将 _needUpdate 设置为 YES，当 _needUpdate 为 YES 时后面就不用我说了，相关的代码在上一节初始化中有哦。 123if (info &amp;&amp; info-&gt;_needUpdate) &#123; [info _update];&#125; 简单介绍一下 _update，它是 YYClassInfo 的私有方法，它的实现逻辑简单介绍就是清空当前 YYClassInfo 实例变量，方法以及属性，之后再重新初始化它们。由于 _update 实现源码并没有什么特别之处，我这里就不贴源码了。 嘛~ 对 YYClassInfo 的剖析到这里就差不多了。 NSObject+YYModel 探究 如果说 YYClassInfo 主要是作者对 Runtime 层在 JSON 模型转换中需要用到的结构体的封装，那么 NSObject+YYModel 在 YYModel 中担当的责任则是利用 YYClassInfo 层级封装好的类切实的执行 JSON 模型之间的转换逻辑，并且提供了无侵入性的接口。 第一次阅读 NSObject+YYModel.m 的源码可能会有些不适应，这很正常。因为其大量使用了 Runtime 函数与 CoreFoundation 库，加上各种类型编码和递归解析，代码量也有 1800 多行了。 我简单把 NSObject+YYModel.m 的源码做了一下划分，这样划分之后代码看起来一样很简单清晰： 类型编码解析 数据结构定义 递归模型转换 接口相关代码 类型编码解析类型编码解析代码主要集中在 NSObject+YYModel.m 的上面部分，涉及到 YYEncodingNSType 枚举的定义，配套 YYClassGetNSType 函数将 NS 类型转为 YYEncodingNSType 还有 YYEncodingTypeIsCNumber 函数判断类型是否可以直接转为 C 语言数值类型的函数。 此外还有将 id 指针转为对应 NSNumber 的函数 YYNSNumberCreateFromID，将 NSString 转为 NSDate 的 YYNSDateFromString 函数，这类函数主要是方便在模型转换时使用。 12345678910111213141516171819202122232425262728293031323334static force_inline NSDate *YYNSDateFromString(__unsafe_unretained NSString *string) &#123; typedef NSDate* (^YYNSDateParseBlock)(NSString *string); // YYNSDateFromString 支持解析的最长时间字符串 #define kParserNum 34 // 这里创建了一个单例时间解析代码块数组 // 为了避免重复创建这些 NSDateFormatter，它的初始化开销不小 static YYNSDateParseBlock blocks[kParserNum + 1] = &#123;0&#125;; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // 这里拿 `yyyy-MM-dd` 举例分析 &#123; /* 2014-01-20 // Google */ NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;en_US_POSIX&quot;]; formatter.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:0]; formatter.dateFormat = @&quot;yyyy-MM-dd&quot;; // 这里使用 blocks[10] 是因为 `yyyy-MM-dd` 的长度就是 10 blocks[10] = ^(NSString *string) &#123; return [formatter dateFromString:string]; &#125;; &#125; // 其他的格式都是一样类型的代码，省略 ... &#125;); if (!string) return nil; if (string.length &gt; kParserNum) return nil; // 根据入参的长度去刚才存满各种格式时间解析代码块的单例数组取出对应的代码块执行 YYNSDateParseBlock parser = blocks[string.length]; if (!parser) return nil; return parser(string); #undef kParserNum&#125; Note: 在 iOS 7 之前 NSDateFormatter 是非线程安全的。 除此之外还用 YYNSBlockClass 指向了 NSBlock 类，实现过程也比较巧妙。 12345678910111213static force_inline Class YYNSBlockClass() &#123; static Class cls; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; void (^block)(void) = ^&#123;&#125;; cls = ((NSObject *)block).class; // 轮询父类直到父类指向 NSObject 停止 while (class_getSuperclass(cls) != [NSObject class]) &#123; cls = class_getSuperclass(cls); &#125; &#125;); return cls; // 拿到的就是 &quot;NSBlock&quot;&#125; 关于 force_inline 这种代码技巧，我说过我在写完 YYModel 或者攒到足够多的时候会主动拿出来与大家分享这些代码技巧，不过这里大家通过字面也不难理解，就是强制内联。 嘛~ 关于内联函数应该不需要我多说（笑）。 数据结构定义NSObject+YYModel 中重新定义了两个类，通过它们来使用 YYClassInfo 中的封装。 NSObject+YYModel YYClassInfo _YYModelPropertyMeta YYClassPropertyInfo _YYModelMeta YYClassInfo _YYModelPropertyMeta_YYModelPropertyMeta 表示模型对象中的属性信息，它包含 YYClassPropertyInfo。 1234567891011121314151617181920212223242526@interface _YYModelPropertyMeta : NSObject &#123; @package NSString *_name; ///&lt; 属性名称 YYEncodingType _type; ///&lt; 属性类型 YYEncodingNSType _nsType; ///&lt; 属性在 Foundation 框架中的类型 BOOL _isCNumber; ///&lt; 是否为 CNumber Class _cls; ///&lt; 属性类 Class _genericCls; ///&lt; 属性包含的泛型类型，没有则为 nil SEL _getter; ///&lt; getter SEL _setter; ///&lt; setter BOOL _isKVCCompatible; ///&lt; 如果可以使用 KVC 则返回 YES BOOL _isStructAvailableForKeyedArchiver; ///&lt; 如果可以使用 archiver/unarchiver 归/解档则返回 YES BOOL _hasCustomClassFromDictionary; ///&lt; 类/泛型自定义类型，例如需要在数组中实现不同类型的转换需要用到 /* property-&gt;key: _mappedToKey:key _mappedToKeyPath:nil _mappedToKeyArray:nil property-&gt;keyPath: _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil property-&gt;keys: _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath _mappedToKeyArray:keys(array) */ NSString *_mappedToKey; ///&lt; 映射 key NSArray *_mappedToKeyPath; ///&lt; 映射 keyPath，如果没有映射到 keyPath 则返回 nil NSArray *_mappedToKeyArray; ///&lt; key 或者 keyPath 的数组，如果没有映射多个键的话则返回 nil YYClassPropertyInfo *_info; ///&lt; 属性信息，详见上文 YYClassPropertyInfo &amp;&amp; property_t 章节 _YYModelPropertyMeta *_next; ///&lt; 如果有多个属性映射到同一个 key 则指向下一个模型属性元&#125;@end _YYModelMeta_YYModelMeta 表示模型的类信息，它包含 YYClassInfo。 1234567891011121314151617181920@interface _YYModelMeta : NSObject &#123; @package YYClassInfo *_classInfo; /// Key:被映射的 key 与 keyPath, Value:_YYModelPropertyMeta. NSDictionary *_mapper; /// Array&lt;_YYModelPropertyMeta&gt;, 当前模型的所有 _YYModelPropertyMeta 数组 NSArray *_allPropertyMetas; /// Array&lt;_YYModelPropertyMeta&gt;, 被映射到 keyPath 的 _YYModelPropertyMeta 数组 NSArray *_keyPathPropertyMetas; /// Array&lt;_YYModelPropertyMeta&gt;, 被映射到多个 key 的 _YYModelPropertyMeta 数组 NSArray *_multiKeysPropertyMetas; /// 映射 key 与 keyPath 的数量，等同于 _mapper.count NSUInteger _keyMappedCount; /// 模型 class 类型 YYEncodingNSType _nsType; // 忽略 ...&#125;@end 递归模型转换NSObject+YYModel.m 内写了一些（间接）递归模型转换相关的函数，如 ModelToJSONObjectRecursive 之类的，由于涉及繁杂的模型编码解析以及代码量比较大等原因我不准备放在这里详细讲解。 我认为这种逻辑并不复杂但是牵扯较多的函数代码与结构/类型定义代码不同，后者更适合列出源码让读者对数据有全面清醒的认识，而前者结合功能实例讲更容易使读者对整条功能的流程有一个更透彻的理解。 所以我准备放到后面 JSON 与 Model 相互转换时一起讲。 接口相关代码嘛~ 理由同上。 半章总结 文章对 YYModel 源码进行了系统解读，有条理的介绍了 YYModel 的结构，相信会让各位对 YYModel 的代码结构有一个清晰的认识。 深入剖析了 YYClassInfo 的 4 个类，并详细讲解了它们与 Runtime 层级结构体的对应。 在剖析 YYClassInfo 章节中分享了一些我在阅读源码的过程中发现的并且觉得值得分享的处理细节，比如为什么作者选择用 strong 来修饰 NSString 等。顺便还对 SEL 与 char * 的关系做了实验得出了我的推论。 把 YYClassInfo 的初始化以及更新细节单独拎出来做了分析。 探究 NSObject+YYModel 源码（分享了一些实现细节）并对其实现代码做了划分，希望能够对读者阅读 YYModel 源码时提供一些小小的帮助。 嘛~ 上篇差不多就这样了。我写的上一篇 YYKit 源码系列文章【从 YYCache 源码 Get 到如何设计一个优秀的缓存】收到了不少的好评和支持（掘金里一位读者 @ios123456 的评论更是暖化了我），这些美好的东西让我更加坚定了继续用心创作文章的决心。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"从 YYCache 源码 Get 到如何设计一个优秀的缓存","comments":true,"permalink":"https://lision.me/yycache/","text":"前言iOS 开发中总会用到各种缓存，但是各位有没有考虑过什么样的缓存才能被叫做优秀的缓存，或者说优秀的缓存应该具备哪些特质？ 闭上眼睛，想一想如果面试官让你设计一个缓存你会怎么回答？ 本文将结合 YYCache 的源码逐步带大家找到答案。 YYCache 是一个线程安全的高性能键值缓存（该项目是 YYKit 组件之一）。YYKit 是在 2015 年发布到 Github 的，由于其代码质量很高，在短时间内就收获了大量的 Star（目前已经 1w+ Star 了），而且在 iOS 各大社区反响广泛，Google 一下也是漫天赞叹。 YYKit 作者是 @ibireme，原名郭曜源（猜测 YY 前缀来源于曜源？），是我个人非常喜欢的国人开发者（何止喜欢，简直是迷弟😘）。 YYCache 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加难能可贵的是它的性能还非常高。 我对它的评价是小而美，这种小而美的缓存源码对于我们今天的主题太合适不过了（本文中 YYCache 源码版本为 v1.0.4）。 索引 YYCache 简介 YYMemoryCache 细节剖析 YYDiskCache 细节剖析 优秀的缓存应该具备哪些特质 总结 YYCache 简介 简单把 YYCache 从头到尾撸了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了。 由于代码整体阅读难度不是非常大，本文不会去逐字逐句的解读源码，而是提炼 YYCache 作为一个小而美的缓存实现了哪些缓存该具备的特质，并且分析实现细节。 我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。 通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。 123456789101112@interface YYCache : NSObject@property (copy, readonly) NSString *name;@property (strong, readonly) YYMemoryCache *memoryCache;@property (strong, readonly) YYDiskCache *diskCache;- (BOOL)containsObjectForKey:(NSString *)key;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key;@end 上面的代码我做了简化，只保留了最基本的代码（我认为作者在最初设计 YYCache 雏形时很可能也只是提供了这些基本的接口），其他的接口只是通过调用基本的接口再附加对应处理代码而成。 Note: 其实源码中作者用了一些技巧性的宏，例如 NS_ASSUME_NONNULL_BEGIN 与 NS_ASSUME_NONNULL_END 来通过编译器层检测入参是否为空并给予警告，参见 Nullability and Objective-C。 类似上述的编码技巧还有很多，我并非不想与大家分享我 get 到的这些编码技巧，只是觉得它与本文的主题似乎不太相符。我准备在之后专门写一篇文章来与大家分享我在阅读各大源码库过程中 get 到的编码技巧（感兴趣的话可以 关注我）。 从代码中我们可以看到 YYCache 中持有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，类似于 iOS 原生的字典类接口（增删改查）。 YYMemoryCache 细节剖析 YYMemoryCache 是一个高速的内存缓存，用于存储键值对。它与 NSDictionary 相反，Key 被保留并且不复制。API 和性能类似于 NSCache，所有方法都是线程安全的。 YYMemoryCache 对象与 NSCache 的不同之处在于： YYMemoryCache 使用 LRU(least-recently-used) 算法来驱逐对象；NSCache 的驱逐方式是非确定性的。 YYMemoryCache 提供 age、cost、count 三种方式控制缓存；NSCache 的控制方式是不精确的。 YYMemoryCache 可以配置为在收到内存警告或者 App 进入后台时自动逐出对象。 Note: YYMemoryCache 中的 Access Methods 消耗时长通常是稳定的 (O(1))。 12345678910111213141516171819202122232425262728293031323334353637383940@interface YYMemoryCache : NSObject#pragma mark - Attribute@property (nullable, copy) NSString *name; // 缓存名称，默认为 nil@property (readonly) NSUInteger totalCount; // 缓存对象总数@property (readonly) NSUInteger totalCost; // 缓存对象总开销#pragma mark - Limit@property NSUInteger countLimit; // 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSUInteger costLimit; // 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSTimeInterval ageLimit; // 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSTimeInterval autoTrimInterval; // 缓存自动清理时间间隔，默认 5s@property BOOL shouldRemoveAllObjectsOnMemoryWarning; // 是否应该在收到内存警告时删除所有缓存内对象@property BOOL shouldRemoveAllObjectsWhenEnteringBackground; // 是否应该在 App 进入后台时删除所有缓存内对象@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache); // 我认为这是一个 hook，便于我们在收到内存警告时自定义处理缓存@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache); // 我认为这是一个 hook，便于我们在收到 App 进入后台时自定义处理缓存@property BOOL releaseOnMainThread; // 是否在主线程释放对象，默认 NO，有些对象（例如 UIView/CALayer）应该在主线程释放@property BOOL releaseAsynchronously; // 是否异步释放对象，默认 YES- (BOOL)containsObjectForKey:(id)key;- (nullable id)objectForKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key;- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;- (void)removeObjectForKey:(id)key;- (void)removeAllObjects;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count; // 用 LRU 算法删除对象，直到 totalCount &lt;= count- (void)trimToCost:(NSUInteger)cost; // 用 LRU 算法删除对象，直到 totalCost &lt;= cost- (void)trimToAge:(NSTimeInterval)age; // 用 LRU 算法删除对象，直到所有到期对象全部被删除@end YYMemoryCache 的定义代码比较简单~ 该有的注释我已经加到了上面，这里 LRU 算法的实现我准备单独拎出来放到后面和（_YYLinkedMapNode 与 _YYLinkedMap）一起讲。我们这里只需要再关注一下 YYMemoryCache 是如何做到线程安全的。 YYMemoryCache 是如何做到线程安全的12345@implementation YYMemoryCache &#123; pthread_mutex_t _lock; // 线程锁，旨在保证 YYMemoryCache 线程安全 _YYLinkedMap *_lru; // _YYLinkedMap，YYMemoryCache 通过它间接操作缓存对象 dispatch_queue_t _queue; // 串行队列，用于 YYMemoryCache 的 trim 操作&#125; 没错，这里 ibireme 选择使用 pthread_mutex 线程锁来确保 YYMemoryCache 的线程安全。 有趣的是，这里 ibireme 使用 pthread_mutex 是有一段小故事的。在最初 YYMemoryCache 这里使用的锁是 OSSpinLock 自旋锁（详见 YYCache 设计思路 备注-关于锁），后面有人在 Github 向作者提 issue 反馈 OSSpinLock 不安全，经过作者的确认（详见 不再安全的 OSSpinLock）最后选择用 pthread_mutex 替代 OSSpinLock。 上面是 ibireme 在确认 OSSpinLock 不再安全之后为了寻找替代方案做的简单性能测试，对比了一下几种能够替代 OSSpinLock 锁的性能。在 不再安全的 OSSpinLock 文末的评论中，我找到了作者使用 pthread_mutex 的原因。 ibireme: 苹果员工说 libobjc 里 spinlock 是用了一些私有方法 (mach_thread_switch)，贡献出了高线程的优先来避免优先级反转的问题，但是我翻了下 libdispatch 的源码倒是没发现相关逻辑，也可能是我忽略了什么。在我的一些测试中，OSSpinLock 和 dispatch_semaphore 都不会产生特别明显的死锁，所以我也无法确定用 dispatch_semaphore 代替 OSSpinLock 是否正确。能够肯定的是，用 pthread_mutex 是安全的。 _YYLinkedMapNode 与 _YYLinkedMap上文介绍了 YYMemoryCache，其实 YYMemoryCache 并不直接操作缓存对象，而是通过内部的 _YYLinkedMapNode 与 _YYLinkedMap 来间接的操作缓存对象。这两个类对于上文中提到的 LRU 缓存算法的理解至关重要，所以我把他们俩单独拎出来放在这里详细解读一下。 123456789101112131415161718192021222324252627282930313233343536373839404142/** _YYLinkedMap 中的一个节点。 通常情况下我们不应该使用这个类。 */@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用 __unsafe_unretained _YYLinkedMapNode *_next; // __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用 id _key; id _value; NSUInteger _cost; // 记录开销，对应 YYMemoryCache 提供的 cost 控制 NSTimeInterval _time; // 记录时间，对应 YYMemoryCache 提供的 age 控制&#125;@end/** YYMemoryCache 内的一个链表。 _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。 通常情况下我们不应该使用这个类。 */@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 不要直接设置该对象 NSUInteger _totalCost; NSUInteger _totalCount; _YYLinkedMapNode *_head; // MRU, 最常用节点，不要直接修改它 _YYLinkedMapNode *_tail; // LRU, 最少用节点，不要直接修改它 BOOL _releaseOnMainThread; // 对应 YYMemoryCache 的 releaseOnMainThread BOOL _releaseAsynchronously; // 对应 YYMemoryCache 的 releaseAsynchronously&#125;// 链表操作，看接口名称应该不需要注释吧~- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;- (void)bringNodeToHead:(_YYLinkedMapNode *)node;- (void)removeNode:(_YYLinkedMapNode *)node;- (_YYLinkedMapNode *)removeTailNode;- (void)removeAll;@end 为了方便大家阅读，我标注了必要的中文注释。其实对数据结构与算法不陌生的同学应该一眼就看的出来 _YYLinkedMapNode 与 _YYLinkedMap 这俩货的本质。没错，丫就是双向链表节点和双向链表。 _YYLinkedMapNode 作为双向链表节点，除了基本的 _prev、_next，还有键值缓存基本的 _key 与 _value，我们可以把 _YYLinkedMapNode 理解为 YYMemoryCache 中的一个缓存对象。 _YYLinkedMap 作为由 _YYLinkedMapNode 节点组成的双向链表，使用 CFMutableDictionaryRef _dic 字典存储 _YYLinkedMapNode。这样在确保 _YYLinkedMapNode 被强引用的同时，能够利用字典的 Hash 快速定位用户要访问的缓存对象，这样既符合了键值缓存的概念又省去了自己实现的麻烦（笑）。 嘛~ 总得来说 YYMemoryCache 是通过使用 _YYLinkedMap 双向链表来操作 _YYLinkedMapNode 缓存对象节点的。 LRU(least-recently-used) 算法的实现上文我们认清了 _YYLinkedMap 与 _YYLinkedMapNode 本质上就是双向链表和链表节点，这里我们简单讲一下 YYMemoryCache 是如何利用双向链表实现 LRU(least-recently-used) 算法的。 缓存替换策略首先 LRU 是缓存替换策略（Cache replacement policies）的一种，还有很多缓存替换策略诸如： First In First Out (FIFO) Last In First Out (LIFO) Time aware Least Recently Used (TLRU) Most Recently Used (MRU) Pseudo-LRU (PLRU) Random Replacement (RR) Segmented LRU (SLRU) Least-Frequently Used (LFU) Least Frequent Recently Used (LFRU) LFU with Dynamic Aging (LFUDA) Low Inter-reference Recency Set (LIRS) Adaptive Replacement Cache (ARC) Clock with Adaptive Replacement (CAR) Multi Queue (MQ) caching algorithm|Multi Queue (MQ) Pannier: Container-based caching algorithm for compound objects 是不是被唬到了？不要担心，我这里会表述的尽量易懂。 缓存命中率 为什么有这么多缓存替换策略，或者说搞这么多名堂究竟是为了什么呢？ 答案是提高缓存命中率，那么何谓缓存命中率呢？ Google 一下自然是有不少解释，不过很多都是 web 相关的，而且不说人话（很难理解），我个人非常讨厌各种不说人话的“高深”抽象概念。 这里抖了好几抖胆才敢谈一下我对于缓存命中率的理解（限于 YYCache 和 iOS 开发）。 缓存命中 = 用户要访问的缓存对象在高速缓存中，我们直接在高速缓存中通过 Hash 将其找到并返回给用户。 缓存命中率 = 用户要访问的缓存对象在高速缓存中被我们访问到的概率。 既然谈到了自己的理解，我索性说个够。 缓存丢失 = 由于高速缓存数量有限（占据内存等原因），所以用户要访问的缓存对象很有可能被我们从有限的高速缓存中淘汰掉了，我们可能会将其存储于低速的磁盘缓存中（如果磁盘缓存还有资源的话），那么就要从磁盘缓存中获取该缓存对象以返回给用户，这种情况我理解为（高速）缓存未命中，即缓存丢失（并不是真的被我们丢掉了，但肯定是被我们从高速缓存淘汰掉了）。 缓存命中是 cache-hit，那么如果你玩游戏，可以理解为这次 hit miss 了（笑，有人找我开黑吗）。 LRU首先来讲一下 LRU 的概念让大家有一个基本的认识。LRU(least-recently-used) 翻译过来是“最近最少使用”，顾名思义这种缓存替换策略是基于用户最近最少访问过的缓存对象而建立。 我认为 LRU 缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。 _YYLinkedMapNode 与 _YYLinkedMap 实现 LRUYYCache 作者通过 _YYLinkedMapNode 与 _YYLinkedMap 双向链表实现 LRU 缓存替换策略的思路其实很简捷清晰，我们一步一步来看。 双向链表中有头结点和尾节点： 头结点 = 链表中用户最近一次使用（访问）的缓存对象节点，MRU。 尾节点 = 链表中用户已经很久没有再次使用（访问）的缓存对象节点，LRU。 如何让头结点和尾节点指向我们想指向的缓存对象节点？我们结合代码来看： 在用户使用（访问）时更新缓存节点信息，并将其移动至双向链表头结点。 123456789101112131415- (id)objectForKey:(id)key &#123; // 判断入参 if (!key) return nil; pthread_mutex_lock(&amp;_lock); // 找到对应缓存节点 _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; // 更新缓存节点时间，并将其移动至双向链表头结点 node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); // 返回找到的缓存节点 value return node ? node-&gt;_value : nil;&#125; 在用户设置缓存对象时，判断入参 key 对应的缓存对象节点是否存在？存在则更新缓存对象节点并将节点移动至链表头结点；不存在则根据入参生成新的缓存对象节点并插入链表表头。 12345678910111213141516171819202122232425262728- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; // 判断入参，省略 ... pthread_mutex_lock(&amp;_lock); // 判断入参 key 对应的缓存对象节点是否存在 _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; // 存在则更新缓存对象节点并将节点移动至链表头结点 _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; [_lru bringNodeToHead:node]; &#125; else &#123; // 不存在则根据入参生成新的缓存对象节点并插入链表表头 node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; [_lru insertNodeAtHead:node]; &#125; // 判断插入、更新节点之后是否超过了限制 cost、count，如果超过则 trim，省略 ... pthread_mutex_unlock(&amp;_lock);&#125; 在资源不足时，从双线链表的尾节点（LRU）开始清理缓存，释放资源。 123456789101112131415161718192021222324252627282930313233// 这里拿 count 资源举例，cost、age 自己举一反三- (void)_trimToCount:(NSUInteger)countLimit &#123; // 判断 countLimit 为 0，则全部清空缓存，省略 // 判断 _lru-&gt;_totalCount &lt;= countLimit，没有超出资源限制则不作处理，省略 ... NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; // 从双线链表的尾节点（LRU）开始清理缓存，释放资源 _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; // 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程 // 对比 sleep 用 usleep 能更好的利用 CPU 时间 usleep(10 * 1000); //10 ms &#125; &#125; // 判断是否需要在主线程释放，采取释放缓存对象操作 if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; // 异步释放，我们单独拎出来讲 [holder count]; // release in queue &#125;); &#125;&#125; 嘛~ 是不是感觉敲简单？上面代码去掉了可能会分散大家注意力的代码，我们这里仅仅讨论 LRU 的实现，其余部分的具体实现源码也非常简单，我觉得没必要贴出来单独讲解，感兴趣的同学可以自己去 YYCache 下载源码查阅。 异步释放技巧关于上面的异步释放缓存对象的代码，我觉得还是有必要单独拎出来讲一下的： 12345dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();dispatch_async(queue, ^&#123; // 异步释放，我们单独拎出来讲 [holder count]; // release in queue&#125;); 这个技巧 ibireme 在他的另一篇文章 iOS 保持界面流畅的技巧 中有提及： Note: 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。 而上面代码中的 YYMemoryCacheGetReleaseQueue 这个队列源码为： 1234// 静态内联 dispatch_queue_tstatic inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125; 在源码中可以看到 YYMemoryCacheGetReleaseQueue 是一个低优先级 DISPATCH_QUEUE_PRIORITY_LOW 队列，猜测这样设计的原因是可以让 iOS 在系统相对空闲时再来异步释放缓存对象。 YYDiskCache 细节剖析 YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。 YYDiskCache 具有以下功能： 它使用 LRU(least-recently-used) 来删除对象。 支持按 cost，count 和 age 进行控制。 它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。 它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。 Note: 您可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@interface YYDiskCache : NSObject#pragma mark - Attribute@property (nullable, copy) NSString *name; // 缓存名称，默认为 nil@property (readonly) NSString *path; // 缓存路径@property (readonly) NSUInteger inlineThreshold; // 阈值，大于阈值则存储类型为 file；否则存储类型为 sqlite@property (nullable, copy) NSData *(^customArchiveBlock)(id object); // 用来替换 NSKeyedArchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象@property (nullable, copy) id (^customUnarchiveBlock)(NSData *data); // 用来替换 NSKeyedUnarchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象@property (nullable, copy) NSString *(^customFileNameBlock)(NSString *key); // 当一个对象将以 file 的形式保存时，该代码块用来生成指定文件名。如果为 nil，则默认使用 md5(key) 作为文件名#pragma mark - Limit@property NSUInteger countLimit; // 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSUInteger costLimit; // 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSTimeInterval ageLimit; // 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSUInteger freeDiskSpaceLimit; // 缓存应该保留的最小可用磁盘空间（以字节为单位），默认无限制，超过限制则会在后台逐出一些对象以满足限制@property NSTimeInterval autoTrimInterval; // 缓存自动清理时间间隔，默认 60s@property BOOL errorLogsEnabled; // 是否开启错误日志#pragma mark - Initializer- (nullable instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold NS_DESIGNATED_INITIALIZER;- (BOOL)containsObjectForKey:(NSString *)key;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key;- (void)removeAllObjects; - (NSInteger)totalCount;- (NSInteger)totalCost;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count;- (void)trimToCost:(NSUInteger)cost;- (void)trimToAge:(NSTimeInterval)age;#pragma mark - Extended Data+ (nullable NSData *)getExtendedDataFromObject:(id)object;+ (void)setExtendedData:(nullable NSData *)extendedData toObject:(id)object;@end YYDiskCache 结构与 YYMemoryCache 类似，由于很多接口都是基于基本的接口做了扩展所得，这里贴的代码省略了一些接口。代码还是一如既往的干净简洁，相信各位都能看懂。 YYDiskCache 是基于 sqlite 和 file 来做的磁盘缓存，我们的缓存对象可以自由的选择存储类型，下面简单对比一下： sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。 file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。 所以 YYDiskCache 使用两者配合，灵活的存储以提高性能。 NSMapTableNSMapTable 是类似于字典的集合，但具有更广泛的可用内存语义。NSMapTable 是 iOS6 之后引入的类，它基于 NSDictionary 建模，但是具有以下差异： 键/值可以选择 “weakly” 持有，以便于在回收其中一个对象时删除对应条目。 它可以包含任意指针（其内容不被约束为对象）。 您可以将 NSMapTable 实例配置为对任意指针进行操作，而不仅仅是对象。 Note: 配置映射表时，请注意，只有 NSMapTableOptions 中列出的选项才能保证其余的 API 能够正常工作，包括复制，归档和快速枚举。 虽然其他 NSPointerFunctions 选项用于某些配置，例如持有任意指针，但并不是所有选项的组合都有效。使用某些组合，NSMapTableOptions 可能无法正常工作，甚至可能无法正确初始化。 更多信息详见 NSMapTable 官方文档。 需要特殊说明的是，YYDiskCache 内部是基于一个单例 NSMapTable 管理的，这点有别于 YYMemoryCache。 123456789101112131415161718192021222324252627static NSMapTable *_globalInstances; // 引用管理所有的 YYDiskCache 实例static dispatch_semaphore_t _globalInstancesLock; // YYDiskCache 使用 dispatch_semaphore 保障 NSMapTable 线程安全static void _YYDiskCacheInitGlobal() &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _globalInstancesLock = dispatch_semaphore_create(1); _globalInstances = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0]; &#125;);&#125;static YYDiskCache *_YYDiskCacheGetGlobal(NSString *path) &#123; if (path.length == 0) return nil; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); id cache = [_globalInstances objectForKey:path]; dispatch_semaphore_signal(_globalInstancesLock); return cache;&#125;static void _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123; if (cache.path.length == 0) return; _YYDiskCacheInitGlobal(); dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER); [_globalInstances setObject:cache forKey:cache.path]; dispatch_semaphore_signal(_globalInstancesLock);&#125; 每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做也会提升不少性能。 1234567891011121314151617181920212223242526- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; // 判断是否可以成功初始化，省略 ... // 先从 NSMapTable 单例中根据 path 获取 YYDiskCache 实例，如果获取到就直接返回该实例 YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path); if (globalCache) return globalCache; // 没有获取到则初始化一个 YYDiskCache 实例 // 要想初始化一个 YYDiskCache 首先要初始化一个 YYKVStorage YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; // 根据刚才得到的 kv 和 path 入参初始化一个 YYDiskCache 实例，代码太长省略 ... // 开启递归清理，会根据 _autoTrimInterval 对 YYDiskCache trim [self _trimRecursively]; // 向 NSMapTable 单例注册新生成的 YYDiskCache 实例 _YYDiskCacheSetGlobal(self); // App 生命周期通知相关代码，省略 ... return self;&#125; 我在 YYCache 设计思路 中找到了作者使用 dispatch_semaphore 作为 YYDiskCache 锁的原因： dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。 YYKVStorageItem 与 YYKVStorage刚才在 YYDiskCache 的初始化源码中，我们不难发现一个类 YYKVStorage。与 YYMemoryCache 相对应的，YYDiskCache 也不会直接操作缓存对象（sqlite/file），而是通过 YYKVStorage 来间接的操作缓存对象。 从这一点上不难发现，YYKVStorage 等价于 YYMemoryCache 中的双向链表 _YYLinkedMap，而对应于 _YYLinkedMap 中的节点 _YYLinkedMapNode，YYKVStorage 中也有一个类 YYKVStorageItem 充当着与缓存对象一对一的角色。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// YYKVStorageItem 是 YYKVStorage 中用来存储键值对和元数据的类// 通常情况下，我们不应该直接使用这个类@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; ///&lt; key@property (nonatomic, strong) NSData *value; ///&lt; value@property (nullable, nonatomic, strong) NSString *filename; ///&lt; filename (nil if inline)@property (nonatomic) int size; ///&lt; value&#x27;s size in bytes@property (nonatomic) int modTime; ///&lt; modification unix timestamp@property (nonatomic) int accessTime; ///&lt; last access unix timestamp@property (nullable, nonatomic, strong) NSData *extendedData; ///&lt; extended data (nil if no extended data)@end/** YYKVStorage 是基于 sqlite 和文件系统的键值存储。 通常情况下，我们不应该直接使用这个类。 @warning 这个类的实例是 *非* 线程安全的，你需要确保 只有一个线程可以同时访问该实例。如果你真的 需要在多线程中处理大量的数据，应该分割数据 到多个 KVStorage 实例（分片）。 */@interface YYKVStorage : NSObject#pragma mark - Attribute@property (nonatomic, readonly) NSString *path; /// storage 路径@property (nonatomic, readonly) YYKVStorageType type; /// storage 类型@property (nonatomic) BOOL errorLogsEnabled; /// 是否开启错误日志#pragma mark - Initializer- (nullable instancetype)initWithPath:(NSString *)path type:(YYKVStorageType)type NS_DESIGNATED_INITIALIZER;#pragma mark - Save Items- (BOOL)saveItem:(YYKVStorageItem *)item;...#pragma mark - Remove Items- (BOOL)removeItemForKey:(NSString *)key;...#pragma mark - Get Items- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;...#pragma mark - Get Storage Status- (BOOL)itemExistsForKey:(NSString *)key;- (int)getItemsCount;- (int)getItemsSize;@end 代码美哭了有木有！？这种代码根本不需要翻译，我觉得相比于逐行的翻译，直接看代码更舒服。这里我们只需要看一下 YYKVStorageType 这个枚举，他决定着 YYKVStorage 的存储类型。 YYKVStorageType12345678910111213/** 存储类型，指示“YYKVStorageItem.value”存储在哪里。 @discussion 通常，将数据写入 sqlite 比外部文件更快，但是 读取性能取决于数据大小。在我的测试（环境 iPhone 6 64G）， 当数据较大（超过 20KB）时从外部文件读取数据比 sqlite 更快。 */typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; YYKVStorageTypeFile = 0, // value 以文件的形式存储于文件系统 YYKVStorageTypeSQLite = 1, // value 以二进制形式存储于 sqlite YYKVStorageTypeMixed = 2, // value 将根据你的选择基于上面两种形式混合存储&#125;; 在 YYKVStorageType 的注释中标记了作者写 YYCache 时做出的测试结论，大家也可以基于自己的环境去测试验证作者的说法（这一点是可以讨论的，我们可以根据自己的测试来设置 YYDiskCache 中的 inlineThreshold 阈值）。 如果想要了解更多的信息可以点击 Internal Versus External BLOBs in SQLite 查阅 SQLite 官方文档。 YYKVStorage 性能优化细节上文说到 YYKVStorage 可以基于 SQLite 和文件系统做磁盘存储，这里再提一些我阅读源码发现到的有趣细节： 12345@implementation YYKVStorage &#123; ... CFMutableDictionaryRef _dbStmtCache; // 焦点集中在这里 ...&#125; 可以看到 CFMutableDictionaryRef _dbStmtCache; 是 YYKVStorage 中的私有成员，它是一个可变字典充当着 sqlite3_stmt 缓存的角色。 12345678910111213141516171819- (sqlite3_stmt *)_dbPrepareStmt:(NSString *)sql &#123; if (![self _dbCheck] || sql.length == 0 || !_dbStmtCache) return NULL; // 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt sqlite3_stmt *stmt = (sqlite3_stmt *)CFDictionaryGetValue(_dbStmtCache, (__bridge const void *)(sql)); if (!stmt) &#123; // 如果没有缓存再从新生成一个 sqlite3_stmt int result = sqlite3_prepare_v2(_db, sql.UTF8String, -1, &amp;stmt, NULL); // 生成结果异常则根据错误日志开启标识打印日志 if (result != SQLITE_OK) &#123; if (_errorLogsEnabled) NSLog(@&quot;%s line:%d sqlite stmt prepare error (%d): %s&quot;, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); return NULL; &#125; // 生成成功则放入 _dbStmtCache 缓存 CFDictionarySetValue(_dbStmtCache, (__bridge const void *)(sql), stmt); &#125; else &#123; sqlite3_reset(stmt); &#125; return stmt;&#125; 这样就可以省去一些重复生成 sqlite3_stmt 的开销。 sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。 更多关于 SQLite 的信息请点击 SQLite 官方文档 查阅。 优秀的缓存应该具备哪些特质 嘛~ 我们回到文章最初提到的问题，优秀的缓存应该具备哪些特质？ 如果跟着文章一步步读到这里，相信很容易举出以下几点： 内存缓存和磁盘缓存 线程安全 缓存控制 缓存替换策略 缓存命中率 性能 我们简单的总结一下 YYCache 源码中是如何体现这些特质的。 内存缓存和磁盘缓存YYCache 是由内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。 在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。 线程安全如果说 YYCache 这个类是一个纯逻辑层的缓存类（指 YYCache 的接口实现全部是调用其他类完成），那么 YYMemoryCache 与 YYDiskCache 还是做了一些事情的（并没有 YYCache 当甩手掌柜那么轻松），其中最显而易见的就是 YYMemoryCache 与 YYDiskCache 为 YYCache 保证了线程安全。 YYMemoryCache 使用了 pthread_mutex 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 dispatch_semaphore，上文已经给出了作者选择这些锁的原因。 缓存控制YYCache 提供了三种控制维度，分别是：cost、count、age。这已经满足了绝大多数开发者的需求，我们在自己设计缓存时也可以根据自己的使用环境提供合适的控制方式。 缓存替换策略在上文解析 YYCache 源码的时候，介绍了缓存替换策略的概念并且列举了很多经典的策略。YYCache 使用了双向链表（_YYLinkedMapNode 与 _YYLinkedMap）实现了 LRU(least-recently-used) 策略，旨在提高 YYCache 的缓存命中率。 缓存命中率这一概念是在上文解析 _YYLinkedMapNode 与 _YYLinkedMap 小节介绍的，我们在自己设计缓存时不一定非要使用 LRU 策略，可以根据我们的实际使用环境选择最适合我们自己的缓存替换策略。 性能其实性能这个东西是隐而不见的，又是到处可见的（笑）。它从我们最开始设计一个缓存架构时就被带入，一直到我们具体的实现细节中慢慢成形，最后成为了我们设计出来的缓存优秀与否的决定性因素。 上文中剖析了太多 YYCache 中对于性能提升的实现细节： 异步释放缓存对象 锁的选择 使用 NSMapTable 单例管理的 YYDiskCache YYKVStorage 中的 _dbStmtCache 甚至使用 CoreFoundation 来换取微乎其微的性能提升 看到这里是不是恍然大悟，性能是怎么来的？就是这样对于每一个细节的极致追求一点一滴积少成多抠出来的。 总结 文章系统的解读了 YYCache 源码，相信可以让各位读者对 YYCache 的整体架构有一个清晰的认识。 文章结合作者 YYCache 设计思路 中的内容对 YYCache 具体功能点实现源码做了深入剖析，再用我自己的理解表述出来，希望可以对读者理解 YYCache 中具体功能的实现提供帮助。 根据我自己的源码理解，把我认为做的不错的提升性能的源码细节单独拎出来做出详细分析。 总结归纳出“一个优秀缓存需要具备哪些特质？”这一问题的答案，希望大家在面试中如果被问及“如何设计一个缓存”这类问题时可以游刃有余。额，至少可以为大家提供一些回答思路，抛砖引玉（笑）。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"},{"title":"iOS 与 JS 交互开发知识总结","comments":true,"permalink":"https://lision.me/ios_native_js/","text":"前言Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而说到 Native 与 JS 交互，就不得不提一嘴 Hybrid。 Hybrid 的翻译结果并不是很文明（擦汗，不知道为啥很多翻译软件会译为“杂种”，但我更喜欢将它翻译为“混合、混血”），Hybrid Mobile App 我对它的理解为通过 Web 网络技术（如 HTML，CSS 和 JavaScript）与 Native 相结合的混合移动应用程序。 那么我们来看一下 Hybrid 对比 Native 有哪些优劣： 因为 Hybrid 的灵活性（更改 Web 页面不必重新发版）以及通用性（一份 H5 玩遍所有平台）再加上门槛低（前端猿可以无痛上手开撸）的优势，所以在非核心功能模块使用 Web 通过 Hybrid 的方式来实现可能从各方面都会优于 Native。而 Native 则可以在核心功能和设备硬件的调用上为 JS 提供强有力的支持。 索引 Hybrid 的发展简史 JavaScriptCore 简介 iOS Native 与 JS 交互的方法 WKWebView 与 JS 交互的特有方法 JS 通过 Native 调用 iOS 设备摄像头的 Demo 总结 Hybrid 的发展简史下面简述一下 Hybrid 的发展史： 1.H5 发布 Html5 是在 2014 年 9 月份正式发布的，这一次的发布做了一个最大的改变就是“从以前的 XML 子集升级成为一个独立集合”。 2.H5 渗入 Mobile App 开发Native APP 开发中有一个 webview 的组件（Android 中是 webview，iOS 有 UIWebview和 WKWebview），这个组件可以加载 Html 文件。 在 H5 大行其道之前，webview 加载的 web 页面很单调（因为只能加载一些静态资源），自从 H5 火了之后，前端猿们开发的 H5 页面在 webview 中的表现不俗使得 H5 开发慢慢渗透到了 Mobile App 开发中来。 3.Hybrid 现状虽然目前已经出现了 RN 和 Weex 这些使用 JS 写 Native App 的技术，但是 Hybrid 仍然没有被淘汰，市面上大多数应用都不同程度的引入了 Web 页面。 JavaScriptCoreJavaScriptCore 这个库是 Apple 在 iOS 7 之后加入到标准库的，它对 iOS Native 与 JS 做交互调用产生了划时代的影响。 JavaScriptCore 大体是由 4 个类以及 1 个协议组成的： JSContext 是 JS 执行上下文，你可以把它理解为 JS 运行的环境。 JSValue 是对 JavaScript 值的引用，任何 JS 中的值都可以被包装为一个 JSValue。 JSManagedValue 是对 JSValue 的包装，加入了“conditional retain”。 JSVirtualMachine 表示 JavaScript 执行的独立环境。 还有 JSExport 协议： 实现将 Objective-C 类及其实例方法，类方法和属性导出为 JavaScript 代码的协议。 这里的 JSContext，JSValue，JSManagedValue 相对比较好理解，下面我们把 JSVirtualMachine 单拎出来说明一下： JSVirtualMachine 的用法和其与 JSContext 的关系 官方文档的介绍： JSVirtualMachine 实例表示用于 JavaScript 执行的独立环境。 您使用此类有两个主要目的：支持并发 JavaScript 执行，并管理 JavaScript 和 Objective-C 或 Swift 之间桥接的对象的内存。 关于 JSVirtualMachine 的使用，一般情况下我们不用手动去创建 JSVirtualMachine。因为当我们获取 JSContext 时，获取到的 JSContext 从属于一个 JSVirtualMachine。 每个 JavaScript 上下文（JSContext 对象）都属于一个 JSVirtualMachine。 每个 JSVirtualMachine 可以包含多个上下文，允许在上下文之间传递值（JSValue 对象）。 但是，每个 JSVirtualMachine 是不同的，即我们不能将一个 JSVirtualMachine 中创建的值传递到另一个 JSVirtualMachine 中的上下文。 JavaScriptCore API 是线程安全的 —— 例如，我们可以从任何线程创建 JSValue 对象或运行 JS 脚本 - 但是，尝试使用相同 JSVirtualMachine 的所有其他线程将被阻塞。 要在多个线程上同时（并发）运行 JavaScript 脚本，请为每个线程使用单独的 JSVirtualMachine 实例。 JSValue 与 JavaScript 的转换表 OBJECTIVE-C JAVASCRIPT JSVALUE CONVERT JSVALUE CONSTRUCTOR nil undefined valueWithUndefinedInContext NSNull null valueWithNullInContext: NSString string toString NSNumber number, boolean toNumbertoBooltoDoubletoInt32toUInt32 valueWithBool:inContext:valueWithDouble:inContext:valueWithInt32:inContext:valueWithUInt32:inContext: NSDictionary Object object toDictionary valueWithNewObjectInContext: NSArray Array object toArray valueWithNewArrayInContext: NSDate Date object toDate NSBlock Function object id Wrapper object toObjecttoObjectOfClass: valueWithObject:inContext: Class Constructor object iOS Native 与 JS 交互对于 iOS Native 与 JS 交互我们先从调用方向上分为两种情况来看： JS 调用 Native Native 调用 JS JS 调用 Native其实 JS 调用 iOS Native 也分为两种实现方式： 假 Request 方法 JavaScriptCore 方法 假 Request 方法原理：其实这种方式就是利用了 webview 的代理方法，在 webview 开始请求的时候截获请求，判断请求是否为约定好的假请求。如果是假请求则表示是 JS 想要按照约定调用我们的 Native 方法，按照约定去执行我们的 Native 代码就好。 UIWebViewUIWebView 代理有用于截获请求的函数，在里面做判断就好： 1234567- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123; NSURL *url = request.URL; // 与约定好的函数名作比较 if ([[url scheme] isEqualToString:@&quot;your_func_name&quot;]) &#123; // just do it &#125;&#125; WKWebViewWKWebView 有两个代理，一个是 WKNavigationDelegate，另一个是 WKUIDelegate。WKUIDelegate 我们在下面的章节会讲到，这里我们需要设置并实现它的 WKNavigationDelegate 方法： 1234567891011- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123; NSURL *url = navigationAction.request.URL; // 与约定好的函数名作比较 if ([[url scheme] isEqualToString:@&quot;your_func_name&quot;]) &#123; // just do it decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; Note: decisionHandler 是当你的应用程序决定是允许还是取消导航时，要调用的代码块。 该代码块使用单个参数，它必须是枚举类型 WKNavigationActionPolicy 的常量之一。如果不调用 decisionHandler 会引起 crash。 这里补充一下 JS 代码： 123function callNative() &#123; loadURL(&quot;your_func_name://xxx&quot;);&#125; 然后拿个 button 标签用一下就好了：1&lt;button type=&quot;button&quot; onclick=&quot;callNative()&quot;&gt;Call Native!&lt;/button&gt; JavaScriptCore 方法iOS 7 有了 JavaScriptCore 专门用来做 Native 与 JS 的交互。我们可以在 webview 完成加载之后获取 JSContext，然后利用 JSContext 将 JS 中的对象引用过来用 Native 代码对其作出解释或响应： 12345678910111213141516// 首先引入 JavaScriptCore 库#import &lt;JavaScriptCore/JavaScriptCore.h&gt;// 然后再 UIWebView 的完成加载的代理方法中- (void)webViewDidFinishLoad:(UIWebView *)webView &#123; // 获取 JS 上下文 jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; // 做引用，将 JS 内的元素引用过来解释，比如方法可以解释成 Block，对象也可以指向 OC 的 Native 对象哦 jsContext[@&quot;iosDelegate&quot;] = self; jsContext[@&quot;yourFuncName&quot;] = ^(id parameter)&#123; // 注意这里的线程默认是 web 处理的线程，如果涉及主线程操作需要手动转到主线程 dispatch_async(dispatch_get_main_queue(), ^&#123; // your code &#125;); &#125;&#125; 而 JS 这边代码更简单了，干脆声明一个不解释的函数（约定好名字的），用于给 Native 做引用： 12var parameter = xxx;yourFuncName(parameter); iOS Native 调用 JSiOS Native 调用 JS 的实现方法也被 JavaScriptCore 划分开来： webview 直接注入 JS 并执行 JavaScriptCore 方法 webview 直接注入 JS 并执行在 iOS 平台，webview 有注入并执行 JS 的 API。 UIWebViewUIWebView 有直接注入 JS 的方法： 12NSString *jsStr = [NSString stringWithFormat:@&quot;showAlert(&#x27;%@&#x27;)&quot;, @&quot;alert msg&quot;];[_webView stringByEvaluatingJavaScriptFromString:jsStr]; Note: 这个方法会返回运行 JS 的结果（nullable NSString *），它是一个同步方法，会阻塞当前线程！尽管此方法不被弃用，但最佳做法是使用 WKWebView 类的 evaluateJavaScript：completionHandler：method。 官方文档：The stringByEvaluatingJavaScriptFromString: method waits synchronously for JavaScript evaluation to complete. If you load web content whose JavaScript code you have not vetted, invoking this method could hang your app. Best practice is to adopt the WKWebView class and use its evaluateJavaScript:completionHandler: method instead. WKWebView不同于 UIWebView，WKWebView 注入并执行 JS 的方法不会阻塞当前线程。因为考虑到 webview 加载的 web content 内 JS 代码不一定经过验证，如果阻塞线程可能会挂起 App。 1234NSString *jsStr = [NSString stringWithFormat:@&quot;setLocation(&#x27;%@&#x27;)&quot;, @&quot;北京市东城区南锣鼓巷纳福胡同xx号&quot;];[_webview evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@----%@&quot;, result, error);&#125;]; Note: 方法不会阻塞线程，而且它的回调代码块总是在主线程中运行。 官方文档：Evaluates a JavaScript string.The method sends the result of the script evaluation (or an error) to the completion handler. The completion handler always runs on the main thread. JavaScriptCore 方法上面简单提到过 JavaScriptCore 库提供的 JSValue 类，这里再提供一下官方文档对 JSValue 的介绍翻译： JSValue 实例是对 JavaScript 值的引用。 您可以使用 JSValue 类来转换 JavaScript 和 Objective-C 或 Swift 之间的基本值（如数字和字符串），以便在本机代码和 JavaScript 代码之间传递数据。 不过你也看到了我贴在上面的 OC 和 JS 数据类型转换表，那里面根本没有限定为官方文档所说的基本值。如果你不熟悉 JS 的话，我这里解释一下为什么 JSValue 也可以指向 JS 中的对象和函数，因为 JS 语言不区分基本值和对象以及函数，在 JS 中“万物皆为对象”。 好了下面直接 show code： 12345678910// 首先引入 JavaScriptCore 库#import &lt;JavaScriptCore/JavaScriptCore.h&gt;// 先获取 JS 上下文self.jsContext = [webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];// 如果涉及 UI 操作，切回主线程调用 JS 代码中的 YourFuncName，通过数组@[parameter] 入参dispatch_async(dispatch_get_main_queue(), ^&#123; JSValue *jsValue = self.jsContext[@&quot;YourFuncName&quot;]; [jsValue callWithArguments:@[parameter]];&#125;); 上面的代码调用了 JS 代码中 YourFuncName 函数，并且给函数加了 @[parameter] 作为入参。为了方便阅读理解，这里再贴一下 JS 代码： 1234function YourFuncName(arguments)&#123; var result = arguments; // do what u want to do&#125; WKWebView 与 JS 交互的特有方法 关于 WKWebView 与 UIWebView 的区别就不在本文加以详细说明了，更多信息还请自行查阅。这里要讲的是 WKWebView 在与 JS 的交互时特有的方法： WKUIDelegate 方法 MessageHandler 方法 WKUIDelegate 方法对于 WKWebView 上文提到过，除了 WKNavigationDelegate，它还有一个 WKUIDelegate，这个 WKUIDelegate 是做什么用的呢？ WKUIDelegate 协议包含一些函数用来监听 web JS 想要显示 alert 或 confirm 时触发。我们如果在 WKWebView 中加载一个 web 并且想要 web JS 的 alert 或 confirm 正常弹出，就需要实现对应的代理方法。 Note: 如果没有实现对应的代理方法，则 webview 将会按照默认操作去做出行为。 Alert: If you do not implement this method, the web view will behave as if the user selected the OK button. Confirm: If you do not implement this method, the web view will behave as if the user selected the Cancel button. 我们这里就拿 alert 举例，相信各位读者可以自己举一反三。下面是在 WKUIDelegate 监听 web 要显示 alert 的代理方法中用 Native UIAlertController 替代 JS 中的 alert 显示的栗子 ： 12345678910- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123; // 用 Native 的 UIAlertController 弹窗显示 JS 将要提示的信息 UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; // 函数内必须调用 completionHandler completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; MessageHandler 方法MessageHandler 是继 Native 截获 JS 假请求后另一种 JS 调用 Native 的方法，该方法利用了 WKWebView 的新特性实现。对比截获假 Request 的方法来说，MessageHandler 传参数更加简单方便。 MessageHandler 指什么？WKUserContentController 类有一个方法:1- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;该方法用来添加一个脚本处理器，可以在处理器内对 JS 脚本调用的方法做出处理，从而达到 JS 调用 Native 的目的。 那么 WKUserContentController 类和 WKWebView 有毛关系呢？ 在 WKWebView 的初始化函数中有一个入参 configuration，它的类型是 WKWebViewConfiguration。WKWebViewConfiguration 中包含一个属性 userContentController，这个 userContentController 就是 WKUserContentController 类型的实例，我们可以用这个 userContentController 来添加不同名称的脚本处理器。 MessageHandler 的坑那么回到 - (void)addScriptMessageHandler:name: 方法上面，该方法添加一个脚本消息处理器（第一个入参 scriptMessageHandler），并且给这个处理器起一个名字（第二个入参 name）。不过这个函数在使用的时候有个坑：scriptMessageHandler 入参会被强引用，那么如果你把当前 WKWebView 所在的 UIViewController 作为第一个入参，这个 viewController 被他自己所持有的 webview.configuration. userContentController 所持有，就会造成循环引用。 我们可以通过 - (void)removeScriptMessageHandlerForName: 方法删掉 userContentController 对 viewController 的强引用。所以一般情况下我们的代码会在 viewWillAppear 和 viewWillDisappear 成对儿的添加和删除 MessageHandler： 123456789- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; [self.webview.configuration.userContentController addScriptMessageHandler:self name:@&quot;YourFuncName&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated &#123; [super viewWillDisappear:animated]; [self.webview.configuration.userContentController removeScriptMessageHandlerForName:@&quot;YourFuncName&quot;];&#125; WKScriptMessageHandler 协议WKScriptMessageHandler 是脚本信息处理器协议，如果想让一个对象具有脚本信息处理能力（比如上文中 webview 的所属 viewController 也就是上面代码的 self）就必须使其遵循该协议。 WKScriptMessageHandler 协议内部非常简单，只有一个方法，我们必须要实现该方法（@required）： 123456789// WKScriptMessageHandler 协议方法，在接收到脚本信息时触发- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message &#123; // message 有两个属性：name 和 body // message.name 可以用于区别要做的处理 if ([message.name isEqualToString:@&quot;YourFuncName&quot;]) &#123; // message.body 相当于 JS 传递过来的参数 NSLog(@&quot;JS call native success %@&quot;, message.body); &#125;&#125; 补充 JS 的代码： 12// &lt;name&gt; 换 YourFuncName，&lt;messageBody&gt; 换你要的入参即可window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 搞定收工！ JS 通过 Native 调用 iOS 设备摄像头的 Demo徒手撸了一个 Demo，实现了 JS 与 Native 代码的交互，达到用 JS 在 webview 内调用 iOS 设备摄像头的功能。Demo 内含权限申请，用户拒绝授权等细节（技术上就是 JS 和 Native 相互传值调用），还请各位大佬指教。 向各位基佬低头，献上我的膝盖~（Demo 地址） 总结 这篇文章简单的介绍了一下 Hybrid Mobile App（其中还包括 Hybrid 的发展简史）。 介绍了 JavaScriptCore 的组成，并且把 JSVirtualMachine 与 JSContext 和 JSValue 之间的关系用图片的形式表述出来（JSVirtualMachine 包含 JSContext 包含 JSValue，都是 1 对 n 的关系，且由于同一个 JSVirtualMachine 下的代码会相互阻塞，所以如果想异步执行交互需要在不同的线程声明 JSVirtualMachine 并发执行）。 从调用方向的角度把 JS 与 iOS Native 相互调用的方式方法分别用代码示例讲解了一遍。 介绍了 WKWebView 与 JS 交互特有的方法：WKUIDelegate 和 MessageHandler。 提供了一个 JS 通过 Native 调用 iOS 设备摄像头的 Demo。 文章写得比较用心（是我个人的原创文章，转载请注明 https://lision.me/），如果发现错误会优先在我的 个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~ 希望我的文章可以为你带来价值~"}]}