<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: llvm | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/tags/llvm/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	<section class="page-header tag">
    <h1>- <span>llvm</span> -</h1>
  </section>






<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/wwdc18_llvm/">
      WWDC18 What’s New in LLVM
    </a>
  </h2>
  
  <time>
    6月 24, 2018
  </time>
  <section class="content">
	  <img src="/wwdc18_llvm/wwdc18.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM</a> 作为 Apple 御用的编译基础设施其重要性不言而喻，Apple 从未停止对 LLVM 的维护和更新，并且几乎在每年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/">WWDC</a> 中都有专门的 Session 来针对 LLVM 的新特性做介绍和讲解，刚刚过去的 WWDC18 也不例外。</p>
<p>WWDC18 Session 409 What’s New in LLVM 中 Apple 的工程师们又为我们介绍了 LLVM 最新的特性，这篇文章将会结合 WWDC18 Session 409 给出的 <a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/409t8zw7rumablsh/409/409_whats_new_in_llvm.pdf?dl=1">官方演示文稿</a> 分享一下 LLVM 的新特性并谈谈笔者自己个人对这些特性的拙见。</p>
<blockquote>
<p>Note: 本文不会对官方演示文稿做逐字逐句的翻译工作，亦不会去过多介绍 LLVM 的基本常识。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>ARC 更新</li>
<li>Xcode 10 新增诊断</li>
<li>Clang 静态分析</li>
<li>增加安全性</li>
<li>新指令集扩展</li>
<li>总结</li>
</ul>
<h2 id="ARC-更新"><a href="#ARC-更新" class="headerlink" title="ARC 更新"></a>ARC 更新</h2><p>本次 ARC 更新的亮点在于 C struct 中允许使用 ARC Objective-C 对象。</p>
<p>在之前版本的 Xcode 中尝试在 C struct 的定义中使用 Obj—C 对象，编译器会抛出 <strong>Error: ARC forbids Objective-C objects in struct</strong>，如下图所示：</p>
<img src="/wwdc18_llvm/arc_00.png" class="">
<p>嘛~ 这是因为之前 LLVM 不支持，如果在 Xcode 10 中书写同样的代码则不会有任何 Warning 与 Error：</p>
<img src="/wwdc18_llvm/arc_01.png" class="">
<p>那么直接在 C struct 中使用 Objective-C 对象的话难道就没有内存上的问题吗？Objective-C 所占用的内存空间是何时被销毁的呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC Object Pointers in C Structs!</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> orderFreeFood(<span class="built_in">NSString</span> *name) &#123;	MenuItem item = &#123;		name,		[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>]	&#125;;	<span class="comment">// [item.name retain];</span>	<span class="comment">// [item.price retain];</span>	orderMenuItem(item);	<span class="comment">// [item.name release]; </span></span><br><span class="line">	<span class="comment">// [item.price release];</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，编译器会在 C struct <code>MenuItem</code> 创建后 <code>retain</code> 其中的 ARC Objective-C 对象，并在 <code>orderMenuItem(item);</code> 语句之后，即其他使用 <code>MenuItem item</code> 的函数调用结束之后 <code>release</code> 掉相关 ARC Objective-C 对象。</p>
<p>思考，在<strong>动态内存管理</strong>时，ARC Objective-C 对象的内存管理会有什么不同呢？ </p>
<blockquote>
<p>Note: 动态内存管理（Dynamic Memory Management），指非 <code>int a[100];</code> 或 <code>MenuItem item = &#123;name, [NSNumber numberWithInt:0]&#125;;</code> 这种在决定了使用哪一存储结构之后，就自动决定了作用域和存储时期的代码，这种代码必须服从预先制定的内存管理规则。</p>
</blockquote>
<p>我们知道 C 语言中如果想要灵活的创建一个动态大小的数组需要自己手动开辟、管理、释放相关的内存，示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="type">double</span> *ptd;</span><br><span class="line">	    </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;What is the maximum number of type double entries?&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">	ptd = <span class="built_in">malloc</span>(max * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="keyword">if</span> (ptd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// memory allocation failed</span></span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// some logic</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(ptd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 C struct 中 ARC Objective-C 的动态内存管理是否应该这么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = malloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>答案是<strong>否定</strong>的！</p>
<img src="/wwdc18_llvm/arc_02.png" class="">
<p>可以看到通过 <code>malloc</code> 开辟内存初始化带有 ARC Objective-C 的 C struct 中 ARC Objective-C 指针不会 <code>zero-initialized</code>。</p>
<p>嘛~ 这个时候自然而然的会想起使用 <code>calloc</code> ^_^ </p>
<blockquote>
<p>Note: <code>calloc</code> 和 <code>malloc</code> 均可完成内存分配，不同之处在于 <code>calloc</code> 会将分配过来的内存块中全部位置都置 0（然而要注意，在某些硬件系统中，浮点值 0 不是全部位为 0 来表示的）。</p>
</blockquote>
<p>另一个问题就是 <code>free(items);</code> 语句执行之前，ARC Objective-C 并没有被清理。</p>
<p>Emmmmm… 官方推荐的写法是在 <code>free(items);</code> 之前将 <code>items</code> 内的所有 struct 中使用到的 ARC Objective-C 指针手动职位 <code>nil</code> …</p>
<p>所以在<strong>动态内存管理</strong>时，上面的代码应该这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = calloc(<span class="number">10</span>, <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	<span class="comment">// ARC Object Pointer Fields Must be Cleared Before Deallocation</span>	<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;		items[i].name = <span class="literal">nil</span>;		items[i].price = <span class="literal">nil</span>;	&#125;	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间有种<strong>日了狗</strong>的感觉有木有？</p>
<h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 在 C struct 中增加对 ARC Objective-C 对象字段的支持意味着我们<strong>今后 Objective-C 可以构建跨语言模式的交互操作</strong>。</p>
<blockquote>
<p>Note: 官方声明为了统一 ARC 与 manual retain/release (MRR) 下部分 function 按值传递、返回 struct 对 Objective-C++ ABI 做出了些许调整。 </p>
</blockquote>
<p>值得一提的是 Swift <strong>并不支持</strong>这一特性（2333~ 谁说 Objective-C 的更新都是为了迎合 Swift 的变化）。</p>
<h2 id="Xcode-10-新增诊断"><a href="#Xcode-10-新增诊断" class="headerlink" title="Xcode 10 新增诊断"></a>Xcode 10 新增诊断</h2><h3 id="Swift-与-Objective-C-互通性"><a href="#Swift-与-Objective-C-互通性" class="headerlink" title="Swift 与 Objective-C 互通性"></a>Swift 与 Objective-C 互通性</h3><p>我们都知道 Swift 与 Objective-C 具有一定程度的互通性，即 Swift 与 Objective-C 可以混编，在混编时 Xcode 生成一个头文件将 Swift 可以转化为 Objective-C 的部分接口暴露出来。</p>
<p>不过由于 Swift 与 Objective-C 的兼容性导致用 Swift 实现的部分代码无法转换给 Objective-C 使用。</p>
<p>近些年来 LLVM 一致都在尝试让这两种语言可以更好的互通（这也就是上文中提到 Objective-C 的更新都是为了迎合 Swift 说法的由来），本次 LLVM 支持<strong>将 Swift 中的闭包（Closures）导入 Objective-C</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">performOperation</span>(<span class="params">handler</span>: () -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import “Executor-Swift.h”</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)performOperation:(<span class="type">void</span> (^)(<span class="type">void</span>))handler; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 Swift 中闭包默认都是非逃逸闭包（non-escaping closures），即闭包不应该在函数返回之后执行。</p>
</blockquote>
<p>Objective-C 中与 Swift 闭包对应的就是 Block 了，但是 Objective-C 中的 Block 并没有诸如 Swift 中逃逸与否的限制，那么我们这样将 Swift 的非逃逸闭包转为 Objective-C 中无限制的 Block 岂不是会有问题？</p>
<img src="/wwdc18_llvm/interoperability.png" class="">
<p>别担心，转换过来的闭包（非逃逸）会有 Warnning 提示，而且我们说过一般这种情况下 Apple 的工程师都会在 LLVM 为 Objective-C 加一个宏来迎合 Swift…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning for Missing Noescape Annotations for Method Overrides</span><span class="meta">#import “Executor-Swift.h”</span><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler;<span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">DispatchExecutor</span></span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler &#123;&#125;</span><br><span class="line"><span class="comment">// Programmer must ensure that handler is not called after performOperation returns</span><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="个人观点-1"><a href="#个人观点-1" class="headerlink" title="个人观点"></a>个人观点</h4><p>如果 Swift 5 真的可以做到 ABI 稳定，那么 Swift 与 Objective-C 混编的 App 包大小也应该回归正常，相信很多公司的项目都会慢慢从 Objective-C 转向 Swift。在 Swift 中闭包（Closures）作为一等公民的存在奠定了 Swift 作为函数式语言的根基，本次 LLVM 提供了将 Swift 中的 Closures 与 Objective-C 中的 Block 互通转换的支持无疑是很有必要的。</p>
<h3 id="使用-pragma-pack-打包-Struct-成员"><a href="#使用-pragma-pack-打包-Struct-成员" class="headerlink" title="使用 #pragma pack 打包 Struct 成员"></a>使用 <code>#pragma pack</code> 打包 Struct 成员</h3><p>Emmmmm… 老实说这一节的内容更底层，所以可能会比较晦涩，希望自己可以表述清楚吧。在 C 语言中 struct 有 <strong>内存布局（memory layout）</strong> 的概念，C 语言允许编译器为每个基本类型指定一些<strong>对齐方式</strong>，通常情况下是以类型的大小为标准对齐，但是它是<strong>特定于实现</strong>的。</p>
<p>嘛~ 还是举个例子吧，就拿 WWDC18 官方演示文稿中的吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> &#123;</span> </span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="comment">// 2 byte padding </span></span><br><span class="line">	<span class="type">uint32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，编译器为了对齐内存布局不得不在 <code>Struct</code> 的第二字段与第三字段之间插入 2 个 byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p><strong>这样本该占用 6 byte 的 struct 就占用了 8 byte，尽管其中只有 6 byte 的数据。</strong></p>
<p>C 语言允许每个远程现代编译器实现 <code>#pragma pack</code>，它允许程序猿对填充进行控制来依从 ABI。</p>
<blockquote>
<p>From C99 §6.7.2.1: </p>
<p>12 Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type.</p>
<p>13 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
</blockquote>
<p>实际上关于 <code>#pragma pack</code> 的相关信息可以在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/preprocessor/pack">MSDN page</a> 中找到。</p>
<p>LLVM 本次也加入了对 <code>#pragma pack</code> 的支持，使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (push, 1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PackedStruct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="type">uint32_t</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (pop)</span></span><br></pre></td></tr></table></figure>
<p>经过 <code>#pragma pack</code> 之后我们的 struct 对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   1   |</span><br><span class="line">|   a   | </span><br><span class="line">|   b   |</span><br><span class="line">|  c(1) |</span><br><span class="line">|  c(2) |</span><br><span class="line">|  c(3) |</span><br><span class="line">|  c(4) |</span><br></pre></td></tr></table></figure>
<p>其实 <code>#pragma pack (push, 1)</code> 中的 <code>1</code> 就是对齐字节数，如果设置为 <code>4</code> 那么对齐方式又会变回到最初的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p>值得一提的是，如果你使用了 <code>#pragma pack (push, n)</code> 之后忘记写 <code>#pragma pack (pop)</code> 的话，Xcode 10 会抛出 warning：</p>
<img src="/wwdc18_llvm/pack.png" class="">
<h4 id="个人观点-2"><a href="#个人观点-2" class="headerlink" title="个人观点"></a>个人观点</h4><p>嘛~ 当在网络层面传输 struct 时，通过 <code>#pragma pack</code> 自定义内存布局的对齐方式可以为用户节约更多流量。</p>
<h2 id="Clang-静态分析"><a href="#Clang-静态分析" class="headerlink" title="Clang 静态分析"></a>Clang 静态分析</h2><p>Xcode 一直都提供静态分析器（Static Analyzer），使用 Clang Static Analyzer 可以帮助我们找出边界情况以及难以发觉的 Bug。</p>
<img src="/wwdc18_llvm/static_analyzer_00.jpg" class="">
<p>点击 Product -&gt; Analyze 或者使用快捷键 Shift+Command+B 就可以静态分析当前构建的项目了，当然也可以在项目的 Build Settings 中设置构建项目时自动执行静态分析（个人不推荐）：</p>
<img src="/wwdc18_llvm/static_analyzer_01.jpg" class="">
<p>本地静态分析器有以下提升：</p>
<ul>
<li>GCD 性能反模式</li>
<li>自动释放变量超出自动释放池</li>
<li>性能和可视化报告的提升</li>
</ul>
<h3 id="GCD-性能反模式"><a href="#GCD-性能反模式" class="headerlink" title="GCD 性能反模式"></a>GCD 性能反模式</h3><p>在之前某些迫不得已的情况下，我们可能需要使用 GCD 信号（<code>dispatch_semaphore_t</code>）来阻塞某些异步操作，并将阻塞后得到的最终的结果同步返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task;</span><br><span class="line">	dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这样写有什么问题呢？</p>
<p>上述代码存在通过使用异步线程执行任务来阻塞当前线程，而 Task 队列通常优先级较低，所以会导致<strong>优先级反转</strong>。</p>
<p>那么 Xcode 10 之后我们应该怎么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line"><span class="type">id</span> remoteObjectProxy = [<span class="keyword">self</span>.connection synchronousRemoteObjectProxyWithErrorHandler:</span><br><span class="line">	^(<span class="built_in">NSError</span> *error) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %@&quot;</span>, error); &#125;];</span><br><span class="line">[remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>如果可能的话，尽量使用 <code>synchronous</code> 版本的 API。或者，使用 <code>asynchronous</code> 方式的 API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123; </span><br><span class="line">	completionHandler(task);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可以在 build settings 下启用 GCD 性能反模式的静态分析检查：</p>
<img src="/wwdc18_llvm/static_analyzer_gcd_00.png" class="">
<h3 id="自动释放变量超出自动释放池"><a href="#自动释放变量超出自动释放池" class="headerlink" title="自动释放变量超出自动释放池"></a>自动释放变量超出自动释放池</h3><p>众所周知，使用 <code>__autoreleasing</code> 修饰符修饰的变量会在自动释放池离开时被释放（release）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	__autoreleasing <span class="built_in">NSError</span> *err = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种看似不需要我们注意的点往往就是引起程序 Crash 的隐患：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123; </span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				*error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嘛~ 上述代码是会引起 Crash 的，你可以指出为什么吗？</p>
<p>Objective-C 在 ARC（Automatic Reference Counting）下会隐式使用 <code>__autoreleasing</code> 修饰 <code>error</code>，即 <code>NSError *__autoreleasing*</code>。而 <code>-enumerateObjectsUsingBlock:</code> 内部会在迭代 <code>block</code> 时使用 <code>@autoreleasepool</code>，在迭代逻辑中这样做有助于减少内存峰值。</p>
<p>于是 <code>*error</code> 在 <code>-enumerateObjectsUsingBlock:</code> 中被提前 release 掉了，这样在随后读取 <code>*error</code> 时会出现 crash。</p>
<p>Xcode 10 中会给出具有针对性的静态分析警告：</p>
<img src="/wwdc18_llvm/static_analyzer_autoreleasing_00.png" class="">
<p>正确的书写方式应该是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> *__autoreleasing*)error &#123; </span><br><span class="line">	__block <span class="built_in">NSError</span> *localError;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123;</span><br><span class="line">			localError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;];</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		*error = localError;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实早在去年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/411/">WWDC17 Session 411 What’s New in LLVM</a> 中 Xcode 9 就引入了一个需要显示书写 <code>__autoreleasing</code> 的警告。</p>
</blockquote>
<h3 id="性能和可视化报告的提升"><a href="#性能和可视化报告的提升" class="headerlink" title="性能和可视化报告的提升"></a>性能和可视化报告的提升</h3><p>Xcode 10 中静态分析器可以以更高效的方式工作，在相同的分析时间内平均可以发现比之前增加 15% 的 Bug 数量。</p>
<p>不仅仅是性能的提升，Xcode 10 在报告的可视化方面也有所进步。在 Xcode 9 的静态分析器报告页面有着非必要且冗长的 Error Path：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_9.jpg" class="">
<p>Xcode 10 中则对其进行了优化：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_10.jpg" class="">
<h3 id="个人观点-3"><a href="#个人观点-3" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 对于 Xcode 的静态分析，个人认为还是聊胜于无的。不过不建议每次构建项目时都去做静态分析，这样大大增加了构建项目的成本。</p>
<p>个人建议在开发流程中自测完毕提交代码给组内小伙伴们 Code Review 之前做静态分析，可以避免一些 issue 的出现，也可以发现一些代码隐患。有些问题是可以使用静态分析器在提交代码之前就暴露出来的，没必要消耗组内 Code Review 的宝贵人力资源。</p>
<p>还可以在 CI 设置每隔固定是时间间隔去跑一次静态分析，生成报表发到组内小群，根据问题指派责任人去检查是否需要修复（静态分析在比较复杂的代码结构下并不一定准确），这样定期维护从某种角度讲可以保持项目代码的健康状况。</p>
<h2 id="增加安全性"><a href="#增加安全性" class="headerlink" title="增加安全性"></a>增加安全性</h2><h3 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h3><p>Apple 工程师在介绍 Stack Protector 之前很贴心的带领着在场的开发者们复习了一遍栈 Stack 相关的基础知识：</p>
<img src="/wwdc18_llvm/stack_protector_00.png" class="">
<p>如上图，其实就是简单的讲了一下 Stack 的工作方式，如栈帧结构以及函数调用时栈的展开等。每一级的方法调用，都对应了一张相关的活动记录，也被称为<strong>活动帧</strong>。函数的调用栈是由一张张帧结构组成的，所以也称之为<strong>栈帧</strong>。</p>
<p>我们可以看到，栈帧中包含着 <strong>Return Address</strong>，也就是当前活动记录执行结束后要返回的地址。</p>
<p>那么会有什么安全性问题呢？Apple 工程师接着介绍了通过不正当手段修改栈帧 Return Address 从而实现的一些权限提升。嘛~ 也就是历史悠久的 <a target="_blank" rel="noopener" href="http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf">缓冲区溢出攻击</a>。</p>
<img src="/wwdc18_llvm/stack_protector_01.png" class="">
<p>当使用 C 语言中一些不太安全的函数时（比如上图的 <code>strcpy()</code>），就有可能造成缓冲区溢出。</p>
<blockquote>
<p>Note: <code>strcpy()</code> 函数将源字符串复制到指定缓冲区中。但是丫没有指定要复制字符的具体数目！如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会造成<strong>缓冲区溢出</strong>！</p>
</blockquote>
<p>针对缓冲区溢出攻击，LLVM 引入了一块额外的区域（下图绿色区域）来作为栈帧 Return Address 的<strong>护城河</strong>，叫做 Stack Canary，已默认启用：</p>
<img src="/wwdc18_llvm/stack_protector_02.png" class="">
<blockquote>
<p>Note: Canary 译为 “金丝雀”，Stack Canary 的命名源于早期煤矿工人下矿坑时会携带金丝雀来检测矿坑内一氧化碳是否达到危险值，从而判断是否需要逃生。</p>
</blockquote>
<p>根据我们上面对缓冲区溢出攻击的原理分析，大家应该很容易发现 Stack Canary 的防御原理，即缓冲区溢出攻击旨在利用缓冲区溢出来篡改栈帧的 Return Address，加入了 Stack Canary 之后想要篡改 Return Address 就必然会经过 Stack Canary，在当前栈帧执行结束后要使用 Return Address 回溯时先检测 Stack Canary 是否有变动，如果有就调用 <code>abort()</code> 强制退出。</p>
<p>嘛~ 是不是和矿坑中的金丝雀很像呢？</p>
<p>不过 Stack Canary 存在一些局限性：</p>
<ul>
<li>可以在缓冲区溢出攻击时计算 Canary 的区域并伪装 Canary 区域的值，使得 Return Address 被篡改的同时 Canary 区域内容无变化，绕过检测。</li>
<li>再粗暴一点的话，可以通过双重 <code>strcpy()</code> 覆写任意不受内存保护的数据，通过构建合适的溢出字符串，可以达到修改 ELF（Executable and Linking Format）映射的 GOT（Global Offset Table），只要修改了 GOT 中的 <code>_exit()</code> 入口，即便 Canary 检测到了篡改，函数返回前调用 <code>abort()</code> 退出还是会走已经被篡改了的 <code>_exit()</code>。</li>
</ul>
<h3 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h3><p>Stack Protector 是 Xcode 既有的、且默认开启的特性，而 Stack Checking 是 Xcode 10 引入的新特性，主要针对的是 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">Stack Clash</a> 问题。</p>
<img src="/wwdc18_llvm/stack_checking_00.png" class="">
<p>Stack Clash 问题的产生源于 Stack 和 Heap，Stack 是<strong>从上向下</strong>增长的，Heap 则是<strong>自下而上</strong>增长的，两者相向扩展而内存又是有限的。</p>
<p>Stack Checking 的工作原理是在 Stack 区域规定合理的分界线（上图红线），在可变长度缓冲区的函数内部对将要分配的缓冲区大小做校验，如果缓冲区超出分界线则调用 <code>abort()</code> 强制退出。</p>
<blockquote>
<p>Note: LLVM 团队在本次 WWDC18 加入 Stack Checking，大概率是因为去年年中 <a target="_blank" rel="noopener" href="https://www.qualys.com/">Qualys</a> 公布的一份 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">关于 Stack Clash 的报告</a>。</p>
</blockquote>
<h2 id="新指令集扩展"><a href="#新指令集扩展" class="headerlink" title="新指令集扩展"></a>新指令集扩展</h2><img src="/wwdc18_llvm/new_instruction_set_extensions.png" class="">
<p>Emmmmm… 这一节的内容是针对于 iMac Pro 以及 iPhone X 使用的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instruction_set_architecture">指令集架构（ISA - Instruction set architecture）</a> 所做的扩展。坦白说，我对这块并不是很感兴趣，也没有深入的研究，所以就不献丑了…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 WWDC18 Session 409 What’s New in LLVM 中的内容，并分享了我个人对这些内容的拙见，希望能够对各位因为种种原因还没有来得及看 WWDC18 Session 409 的同学有所帮助。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/oc_class_properties/">
      巧用 Objective-C Class Properties 解耦
    </a>
  </h2>
  
  <time>
    3月 25, 2018
  </time>
  <section class="content">
	  <img src="/oc_class_properties/oc_class_properties.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Emmmmm… Objective-C Class Properties 早在 WWDC 2016 中就已经公示，给 Objective-C 加入这个特性主要是为了与 Swift 类型属性相互操作。</p>
<p>官方是这么说明的：</p>
<blockquote>
<p>Interoperate with Swift type properties.</p>
</blockquote>
<p>嘛~ 虽然是为了配合 Swift 加入的新特性，不过聊胜于无哈！</p>
<blockquote>
<p>Note: 值得一提的是 Objective-C Class Properties 语法特性虽然是 WWDC 2016 加入的，不过由于是 Xcode 8 中 LLVM Compiler 的特性，因此也适用于 iOS 10 之前的部署版本哟~</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>LLVM</li>
<li>Objective-C Class Properties</li>
<li>解耦</li>
<li>总结</li>
</ul>
<h2 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h2><img src="/oc_class_properties/llvm.jpg" class="">
<p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM 官网</a> 对于 LLVM 的定义：</p>
<blockquote>
<p>Note: The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. </p>
</blockquote>
<p>Emmmmm… 有趣的是，有的文章把 LLVM 强行展开为 “low level virtual machine” 译为 “低级别虚拟机”，不过在 <a target="_blank" rel="noopener" href="https://llvm.org/">LLVM 官网</a> 可以看到官方明示 LLVM 与传统的虚拟机<strong>没有一毛钱关系</strong>，名称 “LLVM” 本身<strong>不是缩写</strong>，它仅仅是项目的名称而已~</p>
<p>嘛~ 可能有的同学不能理解为何 LLVM 是一个编译器工具链集合？这就要从 Apple 的编译器历史讲起咯~ </p>
<p>很久很久以前… 算了，我感觉要跑题了（囧），这里简单列一下 Apple 采用过的编译方案吧：</p>
<ul>
<li>GCC</li>
<li>LLVM &amp; GCC</li>
<li>LLVM Compiler</li>
</ul>
<h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p><a target="_blank" rel="noopener" href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a> 是一套由 GNU 开发的编程语言编译器，最初作为 <a target="_blank" rel="noopener" href="http://www.gnu.org/gnu/thegnuproject.html">GNU 操作系统</a> 的编译器使用，后面发展成为类 Unix 操作系统以及 Apple Mac OS X 操作系统的标准编译器。</p>
<p>原本 GCC 仅能处理 C 语言的编译，不过 GCC 很快扩展以支持 C++，之后的 GCC 越发全面，支持 Objective-C，Fortran，Ada，以及 Go 语言。</p>
<p>值得一提的是 GCC 是一套以 GPL 以及 LGPL 许可证锁发行的 100% 自由软件，这意味着<strong>用户可以自由地运行，拷贝，分发，学习，修改并改进该软件</strong>。</p>
<h3 id="LLVM-amp-GCC"><a href="#LLVM-amp-GCC" class="headerlink" title="LLVM &amp; GCC"></a>LLVM &amp; GCC</h3><p>LLVM 我们前面介绍过了，是模块化 &amp; 可重用性编译器以及工具链技术集合。</p>
<p>LLVM 能够进行程序语言的 <strong>编译期优化、链接优化、在线编译优化、代码生成</strong>。</p>
<h3 id="LLVM-Compiler"><a href="#LLVM-Compiler" class="headerlink" title="LLVM Compiler"></a>LLVM Compiler</h3><p>前面介绍过 GCC 支持很多语言，系统架构庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中顺位（优先级）较低。此外，GCC 作为一个纯粹的编译系统，在与 IDE 配合方面的表现也很差。</p>
<p>So，Apple 决定从零开始写 C，C++，Objective-C 的编译器 Clang。</p>
<p>至此，Apple 彻底与 GCC 了断。</p>
<h2 id="Objective-C-Class-Properties"><a href="#Objective-C-Class-Properties" class="headerlink" title="Objective-C Class Properties"></a>Objective-C Class Properties</h2><img src="/oc_class_properties/oc_feature.jpg" class="">
<p>Objective-C Class Properties 作为 Objective-C 新语法特性在 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2016/405/">WWDC2016 What’s New in LLVM</a> 中公示，表示 Xcode 8 之后可以使用这一新语法特性。</p>
<p>使用方式很简单：</p>
<ul>
<li>Declared with <code>class</code> flag </li>
<li>Accessed with dot syntax</li>
<li>Never synthesized</li>
<li>Use <code>@dynamic</code> to defer to runtime</li>
</ul>
<h3 id="Declared-with-class-flag"><a href="#Declared-with-class-flag" class="headerlink" title="Declared with class flag"></a>Declared with <code>class</code> flag</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyType</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">class</span>) <span class="built_in">NSString</span> *someString;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Accessed-with-dot-syntax"><a href="#Accessed-with-dot-syntax" class="headerlink" title="Accessed with dot syntax"></a>Accessed with dot syntax</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;format string: %@&quot;</span>, MyType.someString);</span><br></pre></td></tr></table></figure>
<h3 id="Never-synthesized"><a href="#Never-synthesized" class="headerlink" title="Never synthesized"></a>Never synthesized</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyType</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *_someString = <span class="literal">nil</span>;</span><br><span class="line">+ (<span class="built_in">NSString</span> *)someString &#123; <span class="keyword">return</span> _someString; &#125;</span><br><span class="line">+ (<span class="type">void</span>)setSomeString:(<span class="built_in">NSString</span> *)newString &#123; _someString = newString; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="Use-dynamic-to-defer-to-runtime"><a href="#Use-dynamic-to-defer-to-runtime" class="headerlink" title="Use @dynamic to defer to runtime"></a>Use <code>@dynamic</code> to defer to runtime</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyType</span></span></span><br><span class="line"><span class="keyword">@dynamic</span> (<span class="keyword">class</span>) someString;</span><br><span class="line">+ (<span class="type">BOOL</span>)resolveClassMethod:(SEL) name &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>笔者在做项目组件下沉时，遇到一个问题，正好适用于 Objective-C Class Properties 发挥：将要下沉的组件库中某系统类 Categroy 引用了业务层某方法。</p>
<img src="/oc_class_properties/before_decoupling.png" class="">
<p>业务层应该依赖于将要下沉的组件，而组件既然要下沉就不应该再反过来依赖上层业务实现！</p>
<p>按照常规思路，想要把上层业务中被依赖的部分一起随组件下沉，但是发现被依赖的部分虽然也属于一个较为基础的模块，不过此模块现阶段不做下沉…</p>
<p>后来经过组内大佬指点，使用 Objective-C Class Properties 解决了这个问题，即将上层业务被依赖的部分化作将要下沉组件依赖方系统类 Categroy 的 Class Properties。</p>
<blockquote>
<p>Note: 在 Categroy 中写 Objective-C Class Properties 需要使用 Runtime 关联方法。</p>
</blockquote>
<img src="/oc_class_properties/after_decoupling.png" class="">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>介绍了 LLVM 顺便提到了 Apple 的编译系统发展简史。</li>
<li>使用官方 Demo 简单介绍了 Objective-C Class Properties 语法特性的书写方式。</li>
<li>提供了一种巧妙使用 Objective-C Class Properties 解耦的思路。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a>
	  </div>
    

  </section>
</article>
  
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
