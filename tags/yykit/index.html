<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: yykit | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/tags/yykit/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	<section class="page-header tag">
    <h1>- <span>yykit</span> -</h1>
  </section>






<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/yyimage/">
      YYImage 设计思路，实现细节剖析
    </a>
  </h2>
  
  <time>
    12月 10, 2017
  </time>
  <section class="content">
	  <img src="/yyimage/yyimage_h.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>图片的历史早于文字，是最原始的信息传递方式。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%AD%E6%9B%B8">六书</a>中的象形文构造思想就是用文字的线条或笔画，把要表达物体的外形特征，具体地勾画出来。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%B1%E6%85%8E">许慎</a>《<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AF%B4%E6%96%87%E8%A7%A3%E5%AD%97">说文解字</a>》云：“象形者，画成其物，随体诘诎，日、月是也。”</p>
</blockquote>
<p>现代社会的信息传递中，图片仍然是不可或缺的一环，不论是报纸、杂志、漫画等实体刊物还是生活中超市地铁广告活动，都会有专门的配图抓人眼球。</p>
<p>在移动端 App 中，图片通常占据着重要的视觉空间，作为 iOS 开发来讲，所有的 App 都有精心设计的 AppIcon 陈列在 SpringBoard 中，打开任意一款主流 App 都少不了琳琅满目的图片搭配。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage">YYImage</a> 是一款功能强大的 iOS 图像框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一），支持目前市场上所有主流的图片格式的显示与编/解码，并且提供高效的动态内存缓存管理，以保证高性能低内存的动画播放。</p>
<p>YYKit 的作者 <a target="_blank" rel="noopener" href="https://weibo.com/239801242">@ibireme</a> 对于 iOS 图片处理写有两篇非常不错的文章，推荐各位读者在阅读本文之前查阅。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/">移动端图片格式调研</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/02/ios_image_tips/">iOS 处理图片的一些小 Tip</a></li>
</ul>
<p>本文引用代码均为 YYImage v1.0.4 版本源码，文章旨在剖析 YYImage 的架构思想以及设计思路并对笔者在阅读源码过程中发现的有趣实现细节探究分享，不会逐行翻译源码，建议对源码实现感兴趣的同学结合 YYImage v1.0.4 版本源码食用本文~</p>
<img src="/yyimage/xiaomai.gif" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYImage 简介</li>
<li>YYImage, YYFrameImage, YYSpriteSheetImage</li>
<li>YYAnimatedImageView</li>
<li>YYImageCoder</li>
<li>总结</li>
<li>扩展阅读</li>
</ul>
<h2 id="YYImage-简介"><a href="#YYImage-简介" class="headerlink" title="YYImage 简介"></a>YYImage 简介</h2><img src="/yyimage/yyimage.jpg" class="">
<p>YYImage 是一款功能强大的 iOS 图像框架，支持当前市场主流的静/动态图像编/解码与动态图像的动画播放显示，其具有以下特性：</p>
<ul>
<li>支持以下类型动画图像的播放/编码/解码: WebP, APNG, GIF。</li>
<li>支持以下类型静态图像的显示/编码/解码: WebP, PNG, GIF, JPEG, JP2, TIFF, BMP, ICO, ICNS。</li>
<li>支持以下类型图片的渐进式/逐行扫描/隔行扫描解码: PNG, GIF, JPEG, BMP。</li>
<li>支持多张图片构成的帧动画播放，支持单张图片的 sprite sheet 动画。</li>
<li>高效的动态内存缓存管理，以保证高性能低内存的动画播放。</li>
<li>完全兼容 UIImage 和 UIImageView，使用方便。</li>
<li>保留可扩展的接口，以支持自定义动画。</li>
<li>每个类和方法都有完善的文档注释。</li>
</ul>
<h3 id="YYImage-架构分析"><a href="#YYImage-架构分析" class="headerlink" title="YYImage 架构分析"></a>YYImage 架构分析</h3><p>通过 YYImage 源码可以按照其与 UIKit 的对应关系划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">UIKit</th>
<th style="text-align:center">YYImage</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图像层</td>
<td style="text-align:center">UIImage</td>
<td style="text-align:center">YYImage, YYFrameImage, YYSpriteSheetImage</td>
</tr>
<tr>
<td style="text-align:center">视图层</td>
<td style="text-align:center">UIImageView</td>
<td style="text-align:center">YYAnimatedImageView</td>
</tr>
<tr>
<td style="text-align:center">编/解码层</td>
<td style="text-align:center">ImageIO.framework</td>
<td style="text-align:center">YYImageCoder</td>
</tr>
</tbody>
</table>
<ul>
<li>图像层，把不同类型的图像信息封装成类并提供初始化和其他便捷接口。</li>
<li>视图层，负责图像层内容的显示（包含动态图像的动画播放）工作。</li>
<li>编/解码层，提供图像底层支持，使整个框架得以支持市场主流的图片格式。</li>
</ul>
<blockquote>
<p>Note: <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/imageio">ImageIO.framework</a> 是 iOS 底层实现的图片编/解码库，负责管理颜色和访问图像元数据。其内部的实现使用了第三方编/解码库（如 libpng 等）并对第三方库进行调整优化。除此之外，iOS 还专门针对 JPEG 的编/解码开发了 AppleJPEG.framework，实现了性能更高的硬编码和硬解码。</p>
</blockquote>
<img src="/yyimage/yyimage_struct.png" class="">
<h2 id="YYImage-YYFrameImage-YYSpriteSheetImage"><a href="#YYImage-YYFrameImage-YYSpriteSheetImage" class="headerlink" title="YYImage, YYFrameImage, YYSpriteSheetImage"></a>YYImage, YYFrameImage, YYSpriteSheetImage</h2><p>先来介绍 YYImage 库中图像层的三个类，它们分别是：</p>
<ul>
<li>YYImage</li>
<li>YYFrameImage</li>
<li>YYSpriteSheetImage</li>
</ul>
<h3 id="YYImage"><a href="#YYImage" class="headerlink" title="YYImage"></a>YYImage</h3><p>YYImage 是一个显示动态图片数据的高级别类，其继承自 UIImage 并对 UIImage 做了扩展以支持 WebP，APNG 和 GIF 格式的图片解码。它还支持 NSCoding 协议可以对多帧图像数据进行 archive 和 unarchive 操作。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageNamed:(<span class="built_in">NSString</span> *)name; <span class="comment">// 不同于 UIImage，此方法无缓存</span></span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithContentsOfFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line">+ (<span class="keyword">nullable</span> YYImage *)imageWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType animatedImageType; <span class="comment">// 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *animatedImageData; <span class="comment">// 动态图像的元数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> animatedImageMemorySize; <span class="comment">// 多帧图像内存占用量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> preloadAllAnimatedImageFrames; <span class="comment">// 预加载所有帧（到内存）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYImage 提供了类似 UIImage 的初始化方法，公开了一些属性便于我们检测和控制其内存使用。</p>
<p>值得一提的是 YYImage 的 <code>imageNamed:</code> 初始化方法并不支持缓存。因为其 <code>imageNamed:</code> 内部实现并不同于 UIImage 的 <code>imageNamed:</code> 方法，YYImage 中的实现流程如下：</p>
<ul>
<li>推测出给定图像资源路径</li>
<li>拿到路径中的图像数据（NSData）</li>
<li>调用 YYImage 的 <code>initWithData:scale:</code> 方法初始化</li>
</ul>
<p>YYImage 的私有变量部分也比较简单，相信大家可以根据上面暴露出的属性和接口猜得到哈。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImage</span> </span>&#123;</span><br><span class="line">    YYImageDecoder *_decoder; <span class="comment">// 解码器</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_preloadedFrames; <span class="comment">// 预加载的图像帧</span></span><br><span class="line">    dispatch_semaphore_t _preloadedLock; <span class="comment">// 预加载锁</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _bytesPerFrame; <span class="comment">// 内存占用量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内部有一把锁 <code>dispatch_semaphore_t</code>，我们知道 <code>dispatch_semaphore_t</code> 当信号量为 1 时可以当做锁来使用，在不阻塞时其作为锁的效率非常高。这里使用 <code>_preloadedLock</code> 的主要目的是保证 <code>_preloadedFrames</code> 的读写，由于 <code>_preloadedFrames</code> 的读写过程是在内存中完成的，操作耗时不会太多，所以不会长时间阻塞，这种情况使用 <code>dispatch_semaphore_t</code> 非常合适。</p>
<p>嘛~ <code>_preloadedFrames</code> 对应 <code>preloadAllAnimatedImageFrames</code> 属性，开启预加载所有帧到内存的话，<code>_preloadedFrames</code> 作为一个数组会保存所有帧的图像。<code>_bytesPerFrame</code> 则对应 <code>animatedImageMemorySize</code> 属性，在初始化 YYImage 时，如果帧总数超过 1 则会计算 <code>_bytesPerFrame</code> 的大小。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (decoder.frameCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    _decoder = decoder;</span><br><span class="line">    _bytesPerFrame = <span class="built_in">CGImageGetBytesPerRow</span>(image.CGImage) * <span class="built_in">CGImageGetHeight</span>(image.CGImage);</span><br><span class="line">    _animatedImageMemorySize = _bytesPerFrame * decoder.frameCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 YYImage 中还有一些实现也比较有趣，比如 <code>animatedImageDurationAtIndex:</code> 的实现中如果取到 &lt;= 10 ms 的时长会替换为 100 ms，并在 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImage.m#L246">注释</a> 中解释了为什么（一定要点进去看啊，笑~）。</p>
<h3 id="YYFrameImage"><a href="#YYFrameImage" class="headerlink" title="YYFrameImage"></a>YYFrameImage</h3><p>YYFrameImage 是专门用来显示基于帧的动画图像类，其也是 UIImage 的子类。YYFrameImage 仅支持系统图片格式例如 png 和 jpeg。</p>
<blockquote>
<p>Note: 使用 YYFrameImage 显示动画图像同样要基于 YYAnimatedImageView 播放。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYFrameImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                           oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImagePaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)paths</span><br><span class="line">                             frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                  loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                               oneFrameDuration:(<span class="built_in">NSTimeInterval</span>)oneFrameDuration</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithImageDataArray:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSData</span> *&gt; *)dataArray</span><br><span class="line">                                 frameDurations:(<span class="built_in">NSArray</span> *)frameDurations</span><br><span class="line">                                      loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYFrameImage 可以把静态图片类型如 png 和 jpeg 格式的静态图像用帧切换的方式以动态图片的形式显示，并且提供了 4 个常用的初始化方法方便我们使用。</p>
<p>YYFrameImage 内部有一些基本的变量分别对应于其暴露的 4 个常用初始化接口：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYFrameImage</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _loopCount;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _oneFrameBytes;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imagePaths;</span><br><span class="line">    <span class="built_in">NSArray</span> *_imageDatas;</span><br><span class="line">    <span class="built_in">NSArray</span> *_frameDurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YYFrameImage 的实现代码非常简单，初始化方法大致可以分为以下步骤：</p>
<ul>
<li>入参校验</li>
<li>根据入参取到首张图片</li>
<li>用首图初始化 <code>_oneFrameBytes</code> ，如入参初始化 <code>_imageDatas</code> ，<code>_frameDurations</code> 和 <code>_loopCount</code></li>
<li>用 <code>UIImage</code> 的 <code>initWithCGImage:scale:orientation:</code> 初始化并返回初始化结果</li>
</ul>
<h3 id="YYSpriteSheetImage"><a href="#YYSpriteSheetImage" class="headerlink" title="YYSpriteSheetImage"></a>YYSpriteSheetImage</h3><img src="/yyimage/ss_wukong.png" class="">
<p>YYSpriteSheetImage 是用来做 Spritesheet 动画显示的图像类，它也是 UIImage 的子类。</p>
<p>关于 Spritesheet 可能做过游戏开发或者以前鼓捣过简单网页游戏 Demo 的同学会很熟悉，其动画原理是把一个动画过程分解为多个动画帧，按照顺序将这些动画帧排布在一张大的画布中，播放动画时只需要按照每一帧图像的尺寸大小以及对应索引去画布中提取对应的帧替换显示以达到人眼判定动画的效果，点击 <a target="_blank" rel="noopener" href="https://gamedevelopment.tutsplus.com/tutorials/an-introduction-to-spritesheet-animation--gamedev-13099"><br>An Introduction to Spritesheet Animation</a> 或者 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/what-is-a-sprite-sheet">What is a sprite sheet?</a> 了解更多关于 Spritesheet 动画的信息。</p>
<blockquote>
<p>Note: 关于 SpriteSheet 素材的制作有一款工具 <a target="_blank" rel="noopener" href="https://www.codeandweb.com/sprite-sheet-maker">SpriteSheetMaker</a> 推荐使用。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYSpriteSheetImage</span> : <span class="title">UIImage</span> &lt;<span class="title">YYAnimatedImage</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化方法，这个第一次接触 Spritesheet 的同学可能会觉得比较繁琐</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithSpriteSheetImage:(<span class="built_in">UIImage</span> *)image</span><br><span class="line">                                     contentRects:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)contentRects</span><br><span class="line">                                   frameDurations:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *)frameDurations</span><br><span class="line">                                        loopCount:(<span class="built_in">NSUInteger</span>)loopCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *contentRects; <span class="comment">// 帧位置信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *frameDurations; <span class="comment">// 帧持续时长</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount; <span class="comment">// 循环数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引找到对应帧 CALayer 的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)contentsRectForCALayerAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>其中初始化方法的入参为 SpriteSheet 画布（包含所有动画帧的大图）image，每一帧的位置 contentRects，每一帧对应的持续显示时间 frameDurations，循环次数 loopCount，初始化示例在 YYImage 源文件 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYSpriteSheetImage.h#L32">YYSpriteSheetImage.h</a> 注释中有写。</p>
<blockquote>
<p>Note: 下文中要讲的 YYAnimatedImageView 中定义了 YYAnimatedImage 协议，这个协议中有一个可选方法 <code>animatedImageContentsRectAtIndex:</code> 就是为 YYSpriteSheetImage 量身打造的。</p>
</blockquote>
<p>这里需要提一下 <code>contentsRectForCALayerAtIndex:</code> 接口会根据索引找到对应帧的 CALayer 位置，该接口返回一个由 0.0~1.0 之间的数值组成的图层定位 LayerRect，如果在查找位置过程中发现异常则返回 CGRectMake(0, 0, 1, 1)，其内部实现大体步骤：</p>
<ul>
<li>校验入参索引是否超过 SpriteSheet 分割帧总数，超过返回 CGRectMake(0, 0, 1, 1)</li>
<li>没超过则通过 YYAnimatedImage 协议的 <code>animatedImageContentsRectAtIndex:</code> 方法找到对应索引的真实位置 RealRect</li>
<li>通过真实位置 RealRect 与 SpriteSheet 画布的比算错 0.0~1.0 之间的值，得到指定索引帧的逻辑定位 LogicRect</li>
<li>通过 <code>CGRectIntersection</code> 方法计算逻辑定位 LogicRect 与 CGRectMake(0, 0, 1, 1) 的交集，确保逻辑定位没有超出画布的部分</li>
<li>将处理后的逻辑定位 LogicRect 作为图层定位 LayerRect 返回</li>
</ul>
<p>返回的 LayerRect 作为对应索引帧的画布内相对位置存在，结合画布就可以定位到对应帧图像的具体尺寸和位置。</p>
<h2 id="YYAnimatedImageView"><a href="#YYAnimatedImageView" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h2><img src="/yyimage/blood_wheel_eye.jpeg" class="">
<p>人眼中呈现的动画是由一幅幅内容连贯的图像以较短时间按顺序替换形成的，所以要显示动画只需要知道动画顺序中每一帧图像以及对应的显示时间等信息即可。YYImage 中对应于 UIImage 层级的内容（YYImage, YYFrameImage, YYSpriteSheetImage）在上文已经介绍过了，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImageView 是 YYImage 的重要组成，它是 UIImageView 的子类，负责 YYImage 图像层中不同的图像类的视图显示（包含动态图像的动画播放），其内部包含 YYAnimatedImage 协议以及 YYAnimatedImageView 自身两部分。</p>
<h3 id="YYAnimatedImage-协议"><a href="#YYAnimatedImage-协议" class="headerlink" title="YYAnimatedImage 协议"></a>YYAnimatedImage 协议</h3><p>上文提到不论是 YYImage, YYFrameImage, YYSpriteSheetImage 还是以后可能会扩展的图像类，虽然它们之间存在内容和形式上的差异，但是对于人眼动画呈现的原理却是不变的。</p>
<p>YYAnimatedImage 协议就是在不影响原来图像类的情况下把不同图像类之间的共性找出来（求同存异？笑），以统一化的接口将人眼动画呈现所需的基本信息输出给 YYAnimatedImageView 使用的协议。</p>
<blockquote>
<p>Note: 作为图像类须遵循 YYAnimatedImage 协议以便可以使用 YYAnimatedImageView 播放动画。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YYAnimatedImage</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"><span class="comment">// 动画帧总数</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageFrameCount;</span><br><span class="line"><span class="comment">// 动画循环次数，0 表示无限循环</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageLoopCount;</span><br><span class="line"><span class="comment">// 每帧字节数（在内存中），可能用于优化内存缓冲区大小</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)animatedImageBytesPerFrame;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像，这个方法可能在异步线程中调用</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)animatedImageFrameAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定特殊索引对应的帧图像对应的显示持续时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)animatedImageDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 针对 Spritesheet 动画的方法，用于显示某一帧图像在 Spritesheet 画布中的位置</span></span><br><span class="line">- (<span class="built_in">CGRect</span>)animatedImageContentsRectAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上文提到过可选实现接口 <code>animatedImageContentsRectAtIndex:</code> 是专为 Spritesheet 动画设计的。</p>
</blockquote>
<p>像这样规定一个协议，使不相关的类遵循此协议拥有统一的功能接口方便另一个类调用的设计思想我们在自己日常项目的开发过程中很多场景都可以用到，例如可以封装一个 TableView，设计一个 TableViewCell 协议，让所有 TableViewCell 都实现这个协议以拥有统一的功能接口，然后我们封装的 TableView 类就可以统一的使用这些 TableViewCell 显示数据啦，省去了反复写相同功能 UITableView 的劳动力（实际应用场景很多，这里只是简单举例，抛砖引玉）。</p>
<h3 id="YYAnimatedImageView-1"><a href="#YYAnimatedImageView-1" class="headerlink" title="YYAnimatedImageView"></a>YYAnimatedImageView</h3><p>上文提到过 YYAnimatedImageView 作为 YYImage 框架中的图片视图层，上接图像层，下启编/解码底层，是枢纽一般的存在（承上启下啊有木有？），我们需要重点研究其内部实现：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span> : <span class="title">UIImageView</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 image 为多帧组成时，自动赋值为 YES，可以在显示和隐藏时自动播放和停止动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> autoPlayAnimatedImage;</span><br><span class="line"><span class="comment">// 当前显示的帧（从 0 起始），设置新值后会立即显示对应帧，如果新值无效则此方法无效</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> currentAnimatedImageIndex;</span><br><span class="line"><span class="comment">// 当前是否在播放动画</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line"><span class="comment">// 动画定时器所在的 runloop mode，默认为 NSRunLoopCommonModes，关乎动画定时器的触发</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *runloopMode;</span><br><span class="line"><span class="comment">// 内部缓存区的最大值（in bytes），默认为 0（动态），如果有值将会把缓存区限制为值大小，当收到内存警告或者 App 进入后台时，缓存区将会立即释放并且在适时的时候回复原状</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxBufferSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>额…出乎意料的简单呢~ 只有一些属性暴露出来以便我们在使用过程中实时查看动画的播放状态以及内存使用情况。笔者看源码总结出一条经验，即<strong>如果某个组件在库中占据重要地位，其 .h 文件中暴露的内容越是简单，其 .m 内部实现就越是复杂</strong>。</p>
<p>通过 <code>runloopMode</code> 属性大家用猜的也应该可以猜出 YYAnimatedImageView 内部实现动画的原理离不开 RunLoop，而且极有可能是用定时器 NSTimer 或者 CADisplayLink 实现的。下面我们来对 YYAnimatedImageView 的实现剖析，验证一下我们刚才的猜想。</p>
<h4 id="YYAnimatedImageView-的实现剖析"><a href="#YYAnimatedImageView-的实现剖析" class="headerlink" title="YYAnimatedImageView 的实现剖析"></a>YYAnimatedImageView 的实现剖析</h4><p>YYAnimatedImageView 内部实现源码很有趣，有很多值得分享的地方。不过为了不把文章写成 MarkDown 编辑器文（笑~）笔者不会逐行翻译源码。读者如果想要知道实现的细节建议结合文章去翻阅源码。相信有了文章梳理的思路源码看起来应该不会有太大的困难，文章还是重在传播实现思想和一些值得分享的技巧。</p>
<p>我们先简单看一下 YYAnimatedImageView 的内部结构，方便后面分析实现思路时大家脑中对 YYAnimatedImageView 的结构提前有一个大概的认识。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYAnimatedImageView</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *_curAnimatedImage; <span class="comment">///&lt; 当前图像</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once_t</span> _onceToken; <span class="comment">///&lt; 用于确保初始化代码只执行一次</span></span><br><span class="line">    dispatch_semaphore_t _lock; <span class="comment">///&lt; 信号量锁（用于 _buffer）</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *_requestQueue; <span class="comment">///&lt; 图片请求队列，串行</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_link; <span class="comment">///&lt; 帧转换</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">///&lt; 上一帧之后的时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *_curFrame; <span class="comment">///&lt; 当前帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curIndex; <span class="comment">///&lt; 当前帧索引</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalFrameCount; <span class="comment">///&lt; 帧总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _loopEnd; <span class="comment">///&lt; 是否在循环末尾</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _curLoop; <span class="comment">///&lt; 当前循环次数</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalLoop; <span class="comment">///&lt; 总循环次数, 0 表示无穷</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *_buffer; <span class="comment">///&lt; 帧缓冲区</span></span><br><span class="line">    <span class="type">BOOL</span> _bufferMiss; <span class="comment">///&lt; 是否丢帧，在上面 _link 定时执行的 step 函数中从帧缓冲区读取下一帧图片时如果没读到，则视为丢帧</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _maxBufferCount; <span class="comment">///&lt; 最大缓冲计数</span></span><br><span class="line">    <span class="built_in">NSInteger</span> _incrBufferCount; <span class="comment">///&lt; 当前允许的缓存区计数（将逐步增加）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGRect</span> _curContentsRect; <span class="comment">///&lt; 针对 YYSpriteSheetImage</span></span><br><span class="line">    <span class="type">BOOL</span> _curImageHasContentsRect; <span class="comment">///&lt; 图像类是否实现了 animatedImageContentsRectAtIndex: 接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>) <span class="type">BOOL</span> currentIsPlayingAnimation;</span><br><span class="line">- (<span class="type">void</span>)calcMaxBufferCount; <span class="comment">// 动态调节缓冲区最大限制 _maxBufferCount</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYAnimatedImageView 内部结构比 .h 中暴露的属性要复杂的多，而 <code>CADisplayLink *_link</code> 属性也证实了我们之前关于 .h 中 <code>runloopMode</code> 属性的猜想。</p>
<p>YYAnimatedImageView 内部的初始化没什么特别之处，初始化函数中会设置图片，当判定图片有更改时会依照下面 4 步去处理：</p>
<ul>
<li>改变图片</li>
<li>重置动画</li>
<li>初始化动画参数</li>
<li>重绘</li>
</ul>
<blockquote>
<p>Note: 这样可以保证 YYAnimatedImageView 的图片更改时都会执行上面的步骤为新的图片初始化配套的新动画参数并且重绘，而重置动画实现中会使用到上面的 <code>dispatch_once_t _onceToken;</code> 以确保某些内部变量的创建以及对 App 内存警告和进入后台的通知观察代码只执行一次。</p>
</blockquote>
<p>YYAnimatedImageView 使图片动起来是依靠 <code>CADisplayLink *_link;</code> 变量切换帧图像，其内部的实现逻辑可以简单理解为：</p>
<ul>
<li>根据当前帧索引推出下一帧索引</li>
<li>使用下一帧索引去帧缓冲区尝试获取对应帧图像</li>
<li>如果找到对应帧图像则使用其重绘</li>
<li>如果没找到则根据条件向图片请求队列加入请求操作（向图片缓冲区录入之后的帧图像数据）</li>
</ul>
<p>嘛~ 这里面有一些值得一提的实现细节哈！</p>
<blockquote>
<ul>
<li>YYAnimatedImageView 实现中当 <code>_curIndex</code> 即当前帧索引修改时在修改代码前后加入了 <code>willChangeValueForKey:</code> 与 <code>didChangeValueForKey:</code> 方法以支持 KVO</li>
<li>对帧缓冲区 <code>_buffer</code> 的操作都使用 <code>_lock</code> 上锁</li>
<li>通过将图片请求队列 <code>_requestQueue</code> 的 <code>maxConcurrentOperationCount</code> 设置为 1 使图片请求队列成为串行队列（最大并发数为 1）</li>
<li>图片请求队列中加入的操作均为 <code>_YYAnimatedImageViewFetchOperation</code></li>
<li>为了避免使用 <code>CADisplayLink</code> 可能造成的循环引用设计了 <code>_YYImageWeakProxy</code></li>
</ul>
</blockquote>
<p>先看一下 <code>_YYAnimatedImageViewFetchOperation</code> 的源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYAnimatedImageViewFetchOperation</span> : <span class="title">NSOperation</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) YYAnimatedImageView *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> nextIndex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> &lt;YYAnimatedImage&gt; *curImage;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYAnimatedImageViewFetchOperation</span></span></span><br><span class="line">- (<span class="type">void</span>)main &#123;<span class="comment">//...&#125;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><code>_YYAnimatedImageViewFetchOperation</code> 继承自 NSOperation 类，是自定义操作类，作者将其操作内容实现写在了 <code>main</code> 中，代码太长而且我觉得贴出来不仅不会帮助读者理解反而会因为片面的源码实现影响读者对 YYAnimatedImageView 的整体实现思路理解（因为大量贴源码会使文章生涩很多，而且会把读者注意力转移到某一个实现），这里简单描述一下 <code>main</code> 函数内部实现逻辑：</p>
<ul>
<li>判断帧缓冲区大小</li>
<li>扫描下一帧以及当前允许缓冲范围内之后的帧图片</li>
<li>如果发现丢失的帧则尝试重新获取帧图像并加入到帧缓冲</li>
</ul>
<p>嘛~ 不贴源码归不贴源码，该注意的细节还是需要列出来的（笑）。</p>
<blockquote>
<ul>
<li>操作中对于 <code>view</code> 缓冲区的操作也都上了锁</li>
<li>操作由于是放入图片请求队列中进行的，内部有对 <code>isCancelled</code> 做判断，如果操作已经被取消（发生在更改图片、停止动画、手动更改当前帧、收到内存警告或 App 进入后台等）则需要及时跳出</li>
<li>对于新的线程优先级只在 <code>main</code> 方法范围内有效，所以推荐把操作的实现放在 <code>main</code> 中而非 <code>start</code>（如需覆盖 start 方法时，需要关注 <code>isExecuting</code> 和 <code>isFinished</code> 两个 key paths）</li>
</ul>
</blockquote>
<p>YYAnimatedImageView 内部设计了 <code>_YYImageWeakProxy</code> 来避免使用 NSTimer 或者 CADisplayLink 可能造成的循环引用问题，<code>_YYImageWeakProxy</code> 内部实现也比较简单，继承自 NSProxy，关于 NSProxy 可以查看<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsproxy">官方文档</a>以了解更多。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYImageWeakProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="type">id</span> target;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(<span class="type">id</span>)target;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="type">id</span>)target;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYImageWeakProxy</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">- (<span class="type">id</span>)forwardingTargetForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> _target;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="type">void</span> *null = <span class="literal">NULL</span>;</span><br><span class="line">    [invocation setReturnValue:&amp;null];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSObject</span> instanceMethodSignatureForSelector:<span class="keyword">@selector</span>(init)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面贴出的源码省略了比较基础的实现部分，<code>_YYImageWeakProxy</code> 内部弱引用一个对象 target，对于 <code>_YYImageWeakProxy</code> 的一些基本操作包含 <code>hash</code> 和 <code>isEqual</code> 这些统统都转到 target 上，并且使用 <code>forwardingTargetForSelector:</code> 消息重定向将不能响应的运行时消息也重定向给 target 来响应。</p>
<p>Emmmmm..那么问题来了，既然都消息重定向给 target 了还要消息转发干嘛？因为要避免循环引用问题所以对 target 使用弱引用，期间无法保证 target 一定存在，所以 <code>forwardingTargetForSelector:</code> 方法可能返回 nil，接着在 Runtime 消息转发中借用 init 消息返回空以“吞掉”异常。</p>
<blockquote>
<p>Note: 消息转发产生的开销要比动态方法解析和消息重定向大。</p>
</blockquote>
<h2 id="YYImageCoder"><a href="#YYImageCoder" class="headerlink" title="YYImageCoder"></a>YYImageCoder</h2><img src="/yyimage/image_coder.jpg" class="">
<p>YYImageCoder 作为 YYImage 的编/解码器，对应于 iOS 中的 ImageIO.framework 图片编/解码库，正是因为有了 YYImageCoder 的存在，YYImage 才得以支持如此多的图片格式，所以说 YYImageCoder 是 YYImage 的底层核心。</p>
<p>YYImageCoder 内部定义了许多 YYImage 中用到的核心数据结构：</p>
<ul>
<li>YYImageType，所有的支持的图片格式做了枚举定义</li>
<li>YYImageDisposeMethod，指定在画布上渲染下一个帧之前如何处理当前帧所使用的区域方法</li>
<li>YYImageBlendOperation，指定当前帧的透明像素如何与前一个画布的透明像素混合操作</li>
<li>YYImageFrame，一帧图像数据</li>
<li>YYImageEncoder，图像编码器</li>
<li>YYImageDecoder，图像解码器</li>
<li>UIImage+YYImageCoder，UIImage 的分类，里面提供了一些方便使用的方法</li>
</ul>
<p>其中 YYImageFrame 是对一帧图像数据的封装，便于在 YYImageCoder 编/解码过程中使用。</p>
<p>YYImageCoder 内部图像编码器 YYImageEncoder 和图像解码器 YYImageDecoder 其实是分开来的，我们下面分别对它们做分析。</p>
<h3 id="YYImageEncoder"><a href="#YYImageEncoder" class="headerlink" title="YYImageEncoder"></a>YYImageEncoder</h3><p>先来讲一下 YYImageEncoder，其在 YYImageCoder 中担任编码器的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageEncoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type; <span class="comment">///&lt; 图像类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> loopCount;       <span class="comment">///&lt; 循环次数，0 无限循环，仅适用于 GIF/APNG/WebP 格式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> lossless;              <span class="comment">///&lt; 无损标记，仅适用于 WebP.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> quality;            <span class="comment">///&lt; 压缩质量，0.0~1.0，仅适用于 JPG/JP2/WebP.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止适用 init、new 初始化编码器（我没忘记我说过这些编码技巧会在之后统一写一篇文章汇总）</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据给定图片类型创建编码器</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithType:(YYImageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 添加图像</span></span><br><span class="line">- (<span class="type">void</span>)addImage:(<span class="built_in">UIImage</span> *)image duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加图像数据</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithData:(<span class="built_in">NSData</span> *)data duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 添加文件路径</span></span><br><span class="line">- (<span class="type">void</span>)addImageWithFile:(<span class="built_in">NSString</span> *)path duration:(<span class="built_in">NSTimeInterval</span>)duration;</span><br><span class="line"><span class="comment">// 开始图像编码并尝试返回编码后的数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encode;</span><br><span class="line"><span class="comment">// 编码并将得到的数据保存到给定路径文件中</span></span><br><span class="line">- (<span class="type">BOOL</span>)encodeToFile:(<span class="built_in">NSString</span> *)path;</span><br><span class="line"><span class="comment">// 便捷方法，对一个单帧图像编码</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImage:(<span class="built_in">UIImage</span> *)image type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"><span class="comment">// 便捷方法，从解码器中编码图像数据</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodeImageWithDecoder:(YYImageDecoder *)decoder type:(YYImageType)type quality:(<span class="built_in">CGFloat</span>)quality;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageEncoder 内部的一些属性和接口都比较基本，关于其内部实现我们需要先看一下私有变量：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageEncoder</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_images; <span class="comment">// 已添加到编码器的图片（数组）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_durations; <span class="comment">// 对应的图片帧显示持续时长（数组）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="YYImageEncoder-的实现思路"><a href="#YYImageEncoder-的实现思路" class="headerlink" title="YYImageEncoder 的实现思路"></a>YYImageEncoder 的实现思路</h4><p>YYImageEncoder 的初始化部分没有多复杂，根据图片的类型按照编码最优的参数做初始化而已。关于 YYImageEncoder 对于图片的编码工作，其实作者根据要支持的图片类型和对应图片类型的编码方式做了底层封装，再根据当前图片的类型选择对应的底层编码方法执行。</p>
<p>关于不同图片类型的图片编码格式可以查阅本文文末的扩展阅读章节，结合扩展阅读的内容查阅 YYImage 这部分源码可以理解作者对于底层图片格式信息的结构封装以及编/解码操作具体实现。</p>
<p>关于 YYImageEncoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L216">YYImageCoder.h</a> 了解。</p>
<h3 id="YYImageDecoder"><a href="#YYImageDecoder" class="headerlink" title="YYImageDecoder"></a>YYImageDecoder</h3><p>YYImageDecoder 在 YYImageCoder 中担任解码器的角色，其与上述 YYImageEncoder 对应，一个负责图像编码一个负责图像解码，不过 YYImageDecoder 的实现比 YYImageEncoder 更为复杂。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYImageDecoder</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSData</span> *data;    <span class="comment">///&lt; 图像数据</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYImageType type;          <span class="comment">///&lt; 图像数据类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> scale;             <span class="comment">///&lt; 图像大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> frameCount;     <span class="comment">///&lt; 图像帧数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> loopCount;      <span class="comment">///&lt; 图像循环次数，0 无限循环</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> width;          <span class="comment">///&lt; 图像画布宽度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> height;         <span class="comment">///&lt; 图像画布高度</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinalized) <span class="type">BOOL</span> finalized;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个图像解码器</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithScale:(<span class="built_in">CGFloat</span>)scale <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="comment">// 用新数据增量更新图像</span></span><br><span class="line">- (<span class="type">BOOL</span>)updateData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data final:(<span class="type">BOOL</span>)final;</span><br><span class="line"><span class="comment">// 方便用一个特殊的数据创建对应的解码器</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)decoderWithData:(<span class="built_in">NSData</span> *)data scale:(<span class="built_in">CGFloat</span>)scale;</span><br><span class="line"><span class="comment">// 解码并返回给定索引对应的帧数据</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYImageFrame *)frameAtIndex:(<span class="built_in">NSUInteger</span>)index decodeForDisplay:(<span class="type">BOOL</span>)decodeForDisplay;</span><br><span class="line"><span class="comment">// 返回给定索引对应的帧持续显示时长</span></span><br><span class="line">- (<span class="built_in">NSTimeInterval</span>)frameDurationAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回给定索引对应帧的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)framePropertiesAtIndex:(<span class="built_in">NSUInteger</span>)index;</span><br><span class="line"><span class="comment">// 返回图片的属性信息，去 ImageIO.framework 的 &quot;CGImageProperties.h&quot; 文件中了解更多</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)imageProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>可以看到 YYImageDecoder 暴露了一些关于解码图像的属性并提供了初始化解码器方法、图像解码方法以及访问图像帧信息的方法。不过上文也说过 YYImageDecoder 的实现比较复杂，我们接着看一下其内部变量结构：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYImageDecoder</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 递归锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">BOOL</span> _sourceTypeDetected; <span class="comment">// 是否推测图像源类型</span></span><br><span class="line">    <span class="built_in">CGImageSourceRef</span> _source; <span class="comment">// 图像源</span></span><br><span class="line">    yy_png_info *_apngSource; <span class="comment">// 如果判定图像为 YYImageTypePNG 则会以 APNG 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> YYIMAGE_WEBP_ENABLED</span></span><br><span class="line">    WebPDemuxer *_webpSource; <span class="comment">// 如果判定图像为 YYImageTypeWebP 则会议 WebP 更新图像源</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImageOrientation</span> _orientation; <span class="comment">// 绘制方向</span></span><br><span class="line">    dispatch_semaphore_t _framesLock; <span class="comment">// 针对于图像帧的锁</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_frames; <span class="comment">///&lt; Array&lt;_YYImageDecoderFrame *&gt;, without image</span></span><br><span class="line">    <span class="type">BOOL</span> _needBlend; <span class="comment">// 是否需要混合</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _blendFrameIndex; <span class="comment">// 从帧索引混合到当前帧</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> _blendCanvas; <span class="comment">// 混合画布</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_YYImageDecoderFrame</code> 继承自 YYImageFrame 类作为 YYImageCoder 图像解码器 YYImageDecoder 使用的内部框架类存在，是对于一帧图像的数据封装提供了便于编/解码时需要访问的数据。</p>
<h4 id="YYImageDecoder-内锁的选择"><a href="#YYImageDecoder-内锁的选择" class="headerlink" title="YYImageDecoder 内锁的选择"></a>YYImageDecoder 内锁的选择</h4><p>可以看到作者在 YYImageDecoder 内部使用了两种锁：</p>
<ul>
<li><code>pthread_mutex_t _lock;</code></li>
<li><code>dispatch_semaphore_t _framesLock;</code></li>
</ul>
<p><code>pthread_mutex_t</code> 在解码器初始化过程中被以 <code>PTHREAD_MUTEX_RECURSIVE</code> 类型设置为了递归锁。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init (&amp;attr);</span><br><span class="line">pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init (&amp;_lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy (&amp;attr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 一般情况下一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。</p>
<p>然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 <code>pthread_mutex</code> 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 <code>PTHREAD_MUTEX_RECURSIVE</code> 即可。</p>
</blockquote>
<p>作者使用 <code>dispatch_semaphore_t</code> 作为图像帧数组的锁是因为 <code>dispatch_semaphore_t</code> 更加轻量且对于图像帧数组的临界操作比较快，不会造成长时间的阻塞，这种情况下 <code>dispatch_semaphore_t</code> 具有性能优势（Emmmmmm..老生常谈了，熟悉的同学不要抱怨，照顾一下后面的同学）。</p>
<h4 id="YYImageDecoder-内的实现思路"><a href="#YYImageDecoder-内的实现思路" class="headerlink" title="YYImageDecoder 内的实现思路"></a>YYImageDecoder 内的实现思路</h4><p>YYImageDecoder 内在初始化时会初始化锁并更新图像源数据，在更新图像源时调用 <code>_updateSource</code> 方法根据当前图像类型以作者对该类型封装好的底层数据结构和对应图像类型解码规则做解码，解码之后设置对应属性。</p>
<p>关于作者对不同格式的图像数据的底层封装源码感兴趣的读者可以参考本文文末的扩展阅读章节内容自行查阅。</p>
<p>关于 YYImageDecoder 的一些简单使用示例可以查看 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYImage/blob/master/YYImage/YYImageCoder.h#L106">YYImageCoder.h</a> 了解。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的分析了 YYImage 源码，希望各位读者在阅读本文之后可以对 YYImage 整体架构和设计思路有清晰的认识。</li>
<li>文章对 YYImage 的 Image 层级的三类图像（YYImage, YYFrameImage, YYSpriteSheetImage）分别解读，希望可以对各位读者关于这三类图像的组成原理和呈现动画的方式的理解有所帮助。</li>
<li>文章深入剖析了 YYAnimatedImageView 的内部实现，提炼出其设计思路以供读者探究。</li>
<li>笔者把自己在阅读源码中发现的值得分享的实现细节结合源码单独拎出来分析，希望各位读者可以在自己平时工作中遇到相似情况时能够多一些思路，封装项目组件时可以用到这些技巧。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明出处 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。能力不足，水平有限，如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我，另外我的 <a target="_blank" rel="noopener" href="https://github.com/Lision">GitHub 主页</a> 里有很多有趣的小玩意哦~</p>
<p>最后，希望我的文章可以为你带来价值~</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.libpng.org/pub/png/spec/1.2/PNG-Structure.html">libpng 官网关于 PNG 结构的官方说明</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.mozilla.org/APNG_Specification">APNG 的维基百科</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/speed/webp/docs/api">WebP 开发者文档</a></li>
</ul>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yyimage/" rel="tag">yyimage</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yymodel0x02/">
      揭秘 YYModel 的魔法 0x02
    </a>
  </h2>
  
  <time>
    11月 19, 2017
  </time>
  <section class="content">
	  <img src="/yymodel0x02/design_model_0x02.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上文<a href="https://lision.me/yymodel_x01/">《揭秘 YYModel 的魔法（上）》</a> 中主要剖析了 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a> 的源码结构，并且分享了 YYClassInfo 与 NSObject+YYModel 内部有趣的实现细节。</p>
<p>紧接上篇，本文将解读 YYModel 关于 JSON 模型转换的源码，旨在揭秘 JSON 模型自动转换魔法。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>JSON 与 Model 相互转换</li>
<li>总结</li>
</ul>
<h2 id="JSON-与-Model-相互转换"><a href="#JSON-与-Model-相互转换" class="headerlink" title="JSON 与 Model 相互转换"></a>JSON 与 Model 相互转换</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式，它易于人们阅读和编写，同时也易于机器解析和生成。它是基于 <a target="_blank" rel="noopener" href="http://www.crockford.com/javascript/">JavaScript Programming Language</a>, <a target="_blank" rel="noopener" href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">Standard ECMA-262 3rd Edition - December 1999</a> 的一个子集。JSON 采用完全独立于语言的文本格式，但是也使用了类似于 C 语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。这些特性使 JSON 成为理想的数据交换语言，点击 <a target="_blank" rel="noopener" href="https://www.json.org/json-zh.html">这里</a> 了解更多关于 JSON 的信息。</p>
<p>Model 是 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象编程</a>（Object Oriented Programming，简称 OOP）程序设计思想中的对象，OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。一般我们会根据业务需求来创建对象，在一些设计模式中（如 MVC 等）对象一般作为模型（Model），即对象建模。</p>
<p>JSON 与 Model 相互转换按转换方向分为两种：</p>
<ul>
<li>JSON to Model</li>
<li>Model to JSON</li>
</ul>
<img src="/yymodel0x02/switch.jpg" class="">
<h3 id="JSON-to-Model"><a href="#JSON-to-Model" class="headerlink" title="JSON to Model"></a>JSON to Model</h3><p>我们从 YYModel 的接口开始解读。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithJSON:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="comment">// 将 json 转为字典 dic</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = [<span class="keyword">self</span> _yy_dictionaryWithJSON:json];</span><br><span class="line">    <span class="comment">// 再通过 dic 得到 model 并返回</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> yy_modelWithDictionary:dic];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面接口把 JSON 转 Model 很简单的分为了两个子任务：</p>
<ul>
<li>JSON to NSDictionary</li>
<li>NSDictionary to Model</li>
</ul>
<img src="/yymodel0x02/j2d2m.jpg" class="">
<h4 id="JSON-to-NSDictionary"><a href="#JSON-to-NSDictionary" class="headerlink" title="JSON to NSDictionary"></a>JSON to NSDictionary</h4><p>我们先看一下 <code>_yy_dictionaryWithJSON</code> 是怎么将 json 转为 NSDictionary 的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)_yy_dictionaryWithJSON:(<span class="type">id</span>)json &#123;</span><br><span class="line">    <span class="comment">// 入参判空</span></span><br><span class="line">    <span class="keyword">if</span> (!json || json == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *dic = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSData</span> *jsonData = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据 json 的类型对应操作</span></span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSDictionary 类则直接赋值</span></span><br><span class="line">        dic = json;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSString 类则用 UTF-8 编码转 NSData</span></span><br><span class="line">        jsonData = [(<span class="built_in">NSString</span> *)json dataUsingEncoding : <span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果是 NSData 则直接赋值给 jsonData</span></span><br><span class="line">        jsonData = json;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// jsonData 不为 nil，则表示上面的 2、3 情况中的一种</span></span><br><span class="line">    <span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">        <span class="comment">// 利用 NSJSONSerialization 方法将 jsonData 转为 dic</span></span><br><span class="line">        dic = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:jsonData options:kNilOptions error:<span class="literal">NULL</span>];</span><br><span class="line">        <span class="comment">// 判断转换结果 </span></span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) dic = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是根据入参的类型判断如何将其转为 NSDictionary 类型并返回。</p>
<p>其中 <code>kCFNull</code> 是 CoreFoundation 中 CFNull 的单例对象。如同 Foundation 框架中的 NSNull 一样，CFNull 是用来表示集合对象中的空值（不允许为 NULL）。CFNull 对象既不允许被创建也不允许被销毁，而是通过定义一个 CFNull 常量，即 <code>kCFNull</code>，在需要空值时使用。</p>
<blockquote>
<p>官方文档：<br>The CFNull opaque type defines a unique object used to represent null values in collection objects (which don’t allow NULL values). CFNull objects are neither created nor destroyed. Instead, a single CFNull constant object—<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/corefoundation/kcfnull">kCFNull</a>—is defined and is used wherever a null value is needed.</p>
</blockquote>
<p>NSJSONSerialization 是用于将 JSON 和等效的 Foundation 对象之间相互转换的对象。它在 iOS 7 以及 macOS 10.9（包含 iOS 7 和 macOS 10.9）之后是线程安全的。</p>
<p>代码中将 NSString 转为 NSData 用到了 NSUTF8StringEncoding，其中编码类型必须属于 JSON 规范中列出的 5 种支持的编码类型：</p>
<ul>
<li>UTF-8</li>
<li>UTF-16LE</li>
<li>UTF-16BE</li>
<li>UTF-32LE</li>
<li>UTF-32BE</li>
</ul>
<p>而用于解析的最高效的编码是 UTF-8 编码，所以作者这里使用 NSUTF8StringEncoding。</p>
<blockquote>
<p>官方注释：<br>The data must be in one of the 5 supported encodings listed in the JSON specification: UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE. The data may or may not have a BOM. The most efficient encoding to use for parsing is UTF-8, so if you have a choice in encoding the data passed to this method, use UTF-8.</p>
</blockquote>
<h4 id="NSDictionary-to-Model"><a href="#NSDictionary-to-Model" class="headerlink" title="NSDictionary to Model"></a>NSDictionary to Model</h4><p>现在我们要从 <code>yy_modelWithJSON</code> 接口中探究 <code>yy_modelWithDictionary</code> 是如何将 NSDictionary 转为 Model 的。</p>
<p>敲黑板！做好准备，这一小节介绍的代码是 YYModel 的精华哦~。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)yy_modelWithDictionary:(<span class="built_in">NSDictionary</span> *)dictionary &#123;</span><br><span class="line">    <span class="comment">// 入参校验</span></span><br><span class="line">    <span class="keyword">if</span> (!dictionary || dictionary == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dictionary isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用当前类生成一个 _YYModelMeta 模型元类</span></span><br><span class="line">    Class cls = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:cls];</span><br><span class="line">    <span class="comment">// 这里 _hasCustomClassFromDictionary 用于标识是否需要自定义返回类</span></span><br><span class="line">    <span class="comment">// 属于模型转换附加功能，可以不用投入太多关注</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">        cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 yy_modelSetWithDictionary 为新建的类实例 one 赋值，赋值成功则返回 one</span></span><br><span class="line">    <span class="built_in">NSObject</span> *one = [cls new];</span><br><span class="line">    <span class="comment">// 所以这个函数中我们应该把注意力集中在 yy_modelSetWithDictionary</span></span><br><span class="line">    <span class="keyword">if</span> ([one yy_modelSetWithDictionary:dictionary]) <span class="keyword">return</span> one;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中根据 <code>_hasCustomClassFromDictionary</code> 标识判断是否需要自定义返回模型的类型。这段代码属于 YYModel 的附加功能，为了不使大家分心，这里仅做简单介绍。</p>
<p>如果我们要在 JSON 转 Model 的过程中根据情况创建不同类型的实例，则可以在 Model 中实现接口：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">nullable</span> Class)modelCustomClassForDictionary:(<span class="built_in">NSDictionary</span> *)dictionary;</span><br></pre></td></tr></table></figure>
<p>来满足需求。当模型元初始化时会检测当前模型类是否可以响应上面的接口，如果可以响应则会把 <code>_hasCustomClassFromDictionary</code> 标识为 YES，所以上面才会出现这些代码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (modelMeta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">    cls = [cls modelCustomClassForDictionary:dictionary] ?: cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 我觉得这些附加的东西在阅读源码时很大程度上会分散我们的注意力，这次先详细的讲解一下，以后遇到类似的代码我们会略过，内部的实现大都与上述案例原理相同，感兴趣的同学可以自己研究哈。</p>
<p>我们应该把注意力集中在 <code>yy_modelSetWithDictionary</code> 上，这个函数（其实也是 NSObject+YYModel 暴露的接口）是根据字典初始化模型的实现方法。它的代码比较长，如果不想看可以跳过，在后面有解释。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)yy_modelSetWithDictionary:(<span class="built_in">NSDictionary</span> *)dic &#123;</span><br><span class="line">    <span class="comment">// 入参校验</span></span><br><span class="line">    <span class="keyword">if</span> (!dic || dic == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据自身类生成 _YYModelMeta 模型元类</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:object_getClass(<span class="keyword">self</span>)];</span><br><span class="line">    <span class="comment">// 如果模型元类键值映射数量为 0 则 return NO，表示构建失败</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，该标识对应 modelCustomWillTransformFromDictionary 接口</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomWillTransformFromDictionary) &#123;</span><br><span class="line">        <span class="comment">// 该接口类似 modelCustomTransformFromDictionary 接口，不过是在模型转换之前调用的</span></span><br><span class="line">        dic = [((<span class="type">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomWillTransformFromDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (![dic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化模型设置上下文 ModelSetContext</span></span><br><span class="line">    ModelSetContext context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    context.modelMeta = (__bridge <span class="type">void</span> *)(modelMeta);</span><br><span class="line">    context.model = (__bridge <span class="type">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    context.dictionary = (__bridge <span class="type">void</span> *)(dic);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断模型元键值映射数量与 JSON 所得字典的数量关系</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_keyMappedCount &gt;= <span class="built_in">CFDictionaryGetCount</span>((<span class="built_in">CFDictionaryRef</span>)dic)) &#123;</span><br><span class="line">        <span class="comment">// 一般情况下他们的数量相等</span></span><br><span class="line">        <span class="comment">// 特殊情况比如有的属性元会映射字典中的多个 key</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为字典中的每个键值对调用 ModelSetWithDictionaryFunction</span></span><br><span class="line">        <span class="comment">// 这句话是核心代码，一般情况下就是靠 ModelSetWithDictionaryFunction 通过字典设置模型</span></span><br><span class="line">        <span class="built_in">CFDictionaryApplyFunction</span>((<span class="built_in">CFDictionaryRef</span>)dic, ModelSetWithDictionaryFunction, &amp;context);</span><br><span class="line">        <span class="comment">// 判断模型中是否存在映射 keyPath 的属性元</span></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_keyPathPropertyMetas) &#123;</span><br><span class="line">            <span class="comment">// 为每个映射 keyPath 的属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_keyPathPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断模型中是否存在映射多个 key 的属性元</span></span><br><span class="line">        <span class="keyword">if</span> (modelMeta-&gt;_multiKeysPropertyMetas) &#123;</span><br><span class="line">            <span class="comment">// 为每个映射多个 key 的属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">            <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas,</span><br><span class="line">                                 <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, <span class="built_in">CFArrayGetCount</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_multiKeysPropertyMetas)),</span><br><span class="line">                                 ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                                 &amp;context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模型元键值映射数量少，则认为不存在映射多个 key 的属性元</span></span><br><span class="line">        <span class="comment">// 直接为每个 modelMeta 属性元执行 ModelSetWithPropertyMetaArrayFunction</span></span><br><span class="line">        <span class="built_in">CFArrayApplyFunction</span>((<span class="built_in">CFArrayRef</span>)modelMeta-&gt;_allPropertyMetas,</span><br><span class="line">                             <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, modelMeta-&gt;_keyMappedCount),</span><br><span class="line">                             ModelSetWithPropertyMetaArrayFunction,</span><br><span class="line">                             &amp;context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，该标识对应接口 modelCustomTransformFromDictionary</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformFromDictionary) &#123;</span><br><span class="line">        <span class="comment">// 该接口用于当默认 JSON 转 Model 不适合模型对象时做额外的逻辑处理</span></span><br><span class="line">        <span class="comment">// 我们也可以用这个接口来验证模型转换的结果</span></span><br><span class="line">        <span class="keyword">return</span> [((<span class="type">id</span>&lt;YYModel&gt;)<span class="keyword">self</span>) modelCustomTransformFromDictionary:dic];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码已经注明必要中文注释，关于两处自定义扩展接口我们不再多说，由于代码比较长我们先来梳理一下 <code>yy_modelSetWithDictionary</code> 主要做了哪些事？</p>
<ul>
<li>入参校验</li>
<li>初始化模型元以及映射表校验</li>
<li>初始化模型设置上下文 <code>ModelSetContext</code></li>
<li>为字典中的每个键值对调用 <code>ModelSetWithDictionaryFunction</code></li>
<li>检验转换结果</li>
</ul>
<p>模型设置上下文 <code>ModelSetContext</code> 其实就是一个包含模型元，模型实例以及待转换字典的结构体。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">void</span> *modelMeta;  <span class="comment">///&lt; 模型元</span></span><br><span class="line">    <span class="type">void</span> *model;      <span class="comment">///&lt; 模型实例，指向输出的模型</span></span><br><span class="line">    <span class="type">void</span> *dictionary; <span class="comment">///&lt; 待转换字典</span></span><br><span class="line">&#125; ModelSetContext;</span><br></pre></td></tr></table></figure>
<p>大家肯定都注意到了 <code>ModelSetWithDictionaryFunction</code> 函数，不论走哪条逻辑分支，最后都是调用这个函数把字典的 key（keypath）对应的 value 取出并赋值给 Model 的，那么我们就来看看这个函数的实现。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典键值对建模</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> ModelSetWithDictionaryFunction(<span class="keyword">const</span> <span class="type">void</span> *_key, <span class="keyword">const</span> <span class="type">void</span> *_value, <span class="type">void</span> *_context) &#123;</span><br><span class="line">    <span class="comment">// 拿到入参上下文</span></span><br><span class="line">    ModelSetContext *context = _context;</span><br><span class="line">    <span class="comment">// 取出上下文中模型元</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelMeta *meta = (__bridge _YYModelMeta *)(context-&gt;modelMeta);</span><br><span class="line">    <span class="comment">// 根据入参 _key 从模型元中取出映射表对应的属性元</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *propertyMeta = [meta-&gt;_mapper objectForKey:(__bridge <span class="type">id</span>)(_key)];</span><br><span class="line">    <span class="comment">// 拿到待赋值模型</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> model = (__bridge <span class="type">id</span>)(context-&gt;model);</span><br><span class="line">    <span class="comment">// 遍历 propertyMeta，直到 propertyMeta-&gt;_next == nil</span></span><br><span class="line">    <span class="keyword">while</span> (propertyMeta) &#123;</span><br><span class="line">        <span class="comment">// 当前遍历的 propertyMeta 有 setter 方法，则调用 ModelSetValueForProperty 赋值</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_<span class="keyword">setter</span>) &#123;</span><br><span class="line">            <span class="comment">// 核心方法，拎出来讲</span></span><br><span class="line">            ModelSetValueForProperty(model, (__bridge __<span class="keyword">unsafe_unretained</span> <span class="type">id</span>)_value, propertyMeta);</span><br><span class="line">        &#125;</span><br><span class="line">        propertyMeta = propertyMeta-&gt;_next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModelSetWithDictionaryFunction</code> 函数的实现逻辑就是先通过模型设置上下文拿到带赋值模型，之后遍历当前的属性元（直到 propertyMeta-&gt;_next == nil），找到 <code>setter</code> 不为空的属性元通过 <code>ModelSetValueForProperty</code> 方法赋值。</p>
<p><code>ModelSetValueForProperty</code> 函数是为模型中的属性赋值的实现方法，也是整个 YYModel 的核心代码。别紧张，这个函数写得很友好的，也就 300 多行而已 😜（无关紧要的内容我会尽量忽略掉），不过忽略的太多会影响代码阅读的连续性，如果嫌长可以不看，文章后面会总结一下这个函数的实现逻辑。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> ModelSetValueForProperty(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> model,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> value,</span><br><span class="line">                                     __<span class="keyword">unsafe_unretained</span> _YYModelPropertyMeta *meta) &#123;</span><br><span class="line">    <span class="comment">// 如果属性是一个 CNumber，即输入 int、uint……</span></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;_isCNumber) &#123;</span><br><span class="line">        <span class="comment">// 转为 NSNumber 之后赋值</span></span><br><span class="line">        <span class="built_in">NSNumber</span> *num = YYNSNumberCreateFromID(value);</span><br><span class="line">        <span class="comment">// 这里 ModelSetNumberToProperty 封装了给属性元赋值 NSNumber 的操作</span></span><br><span class="line">        ModelSetNumberToProperty(model, num, meta);</span><br><span class="line">        <span class="keyword">if</span> (num) [num <span class="keyword">class</span>]; <span class="comment">// hold the number</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">        <span class="comment">// 如果属性属于 nsType，即 NSString、NSNumber……</span></span><br><span class="line">        <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) &#123; <span class="comment">// 为空，则赋值 nil（通过属性元 _setter 方法使用 objc_msgSend 将 nil 赋值）</span></span><br><span class="line">            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)<span class="literal">nil</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不为空</span></span><br><span class="line">            <span class="keyword">switch</span> (meta-&gt;_nsType) &#123;</span><br><span class="line">                <span class="comment">// NSString 或 NSMutableString</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSString:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableString: &#123;</span><br><span class="line">                    <span class="comment">// 处理可能的 value 类型：NSString，NSNumber，NSData，NSURL，NSAttributedString</span></span><br><span class="line">                    <span class="comment">// 对应的分支就是把 value 转为 NSString 或者 NSMutableString，之后调用 setter 赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSValue，NSNumber 或 NSDecimalNumber</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSValue:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSNumber:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDecimalNumber: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSData 或 NSMutableData</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSData:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableData: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的类型分情况赋值（中间可能会涉及到类型之间的转换）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSDate</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDate: &#123;</span><br><span class="line">                    <span class="comment">// 考虑可能的 value 类型：NSDate 或 NSString</span></span><br><span class="line">                    <span class="comment">// 转换为 NSDate 之后赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSURL</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSURL: &#123;</span><br><span class="line">                    <span class="comment">// 考虑可能的 value 类型：NSURL 或 NSString</span></span><br><span class="line">                    <span class="comment">// 转换为 NSDate 之后赋值（这里对 NSString 的长度判断是否赋值 nil）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSArray 或 NSMutableArray</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSArray:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableArray: &#123;</span><br><span class="line">                    <span class="comment">// 对属性元的泛型判断</span></span><br><span class="line">                    <span class="keyword">if</span> (meta-&gt;_genericCls) &#123; <span class="comment">// 如果存在泛型</span></span><br><span class="line">                        <span class="built_in">NSArray</span> *valueArr = <span class="literal">nil</span>;</span><br><span class="line">                        <span class="comment">// value 所属 NSArray 则直接赋值，如果所属 NSSet 类则转为 NSArray</span></span><br><span class="line">                        <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) valueArr = value;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) valueArr = ((<span class="built_in">NSSet</span> *)value).allObjects;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 遍历刚才通过 value 转换来的 valueArr</span></span><br><span class="line">                        <span class="keyword">if</span> (valueArr) &#123;</span><br><span class="line">                            <span class="built_in">NSMutableArray</span> *objectArr = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">id</span> one <span class="keyword">in</span> valueArr) &#123;</span><br><span class="line">                                <span class="comment">// 遇到 valueArr 中的元素属于泛型类，直接加入 objectArr</span></span><br><span class="line">                                <span class="keyword">if</span> ([one isKindOfClass:meta-&gt;_genericCls]) &#123;</span><br><span class="line">                                    [objectArr addObject:one];</span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([one isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                                    <span class="comment">// 遇到 valueArr 中的元素是字典类，</span></span><br><span class="line">                                    Class cls = meta-&gt;_genericCls;</span><br><span class="line">                                    <span class="comment">// 忽略</span></span><br><span class="line">                                    <span class="keyword">if</span> (meta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">                                        cls = [cls modelCustomClassForDictionary:one];</span><br><span class="line">                                        <span class="keyword">if</span> (!cls) cls = meta-&gt;_genericCls; <span class="comment">// for xcode code coverage</span></span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="comment">// 还记得我们直接的起点 yy_modelSetWithDictionary，将字典转模型</span></span><br><span class="line">                                    <span class="comment">// 我觉得这应该算是一个间接递归调用</span></span><br><span class="line">                                    <span class="comment">// 如果设计出的模型是无限递归（从前有座山，山上有座庙的故事），那么肯定会慢</span></span><br><span class="line">                                    <span class="built_in">NSObject</span> *newOne = [cls new];</span><br><span class="line">                                    [newOne yy_modelSetWithDictionary:one];</span><br><span class="line">                                    <span class="comment">// 转化成功机也加入 objectArr</span></span><br><span class="line">                                    <span class="keyword">if</span> (newOne) [objectArr addObject:newOne];</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 最后将得到的 objectArr 赋值给属性</span></span><br><span class="line">                            ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, objectArr);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 没有泛型，嘛~ 判断一下 value 的可能所属类型 NSArray 或 NSSet</span></span><br><span class="line">                        <span class="comment">// 转换赋值（涉及 mutable）</span></span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// NSDictionary 或 NSMutableDictionary</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSDictionary:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableDictionary: &#123;</span><br><span class="line">                    <span class="comment">// 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// NSSet 或 NSMutableSet</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSSet:</span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeNSMutableSet: &#123;</span><br><span class="line">                    <span class="comment">// 跟上面数组的处理超相似，泛型的间接递归以及无泛型的类型转换（mutable 的处理）</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 属性元不属于 CNumber 和 nsType </span></span><br><span class="line">        <span class="type">BOOL</span> isNull = (value == (<span class="type">id</span>)kCFNull);</span><br><span class="line">        <span class="keyword">switch</span> (meta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">            <span class="comment">// id</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 空，赋值 nil</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)<span class="literal">nil</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:meta-&gt;_cls] || !meta-&gt;_cls) &#123;</span><br><span class="line">                    <span class="comment">// 属性元与 value 从属于同一个类，则直接赋值</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    <span class="comment">// 嘛~ value 从属于 </span></span><br><span class="line">                    <span class="built_in">NSObject</span> *one = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="comment">// 如果属性元有 getter 方法，则通过 getter 获取到实例</span></span><br><span class="line">                    <span class="keyword">if</span> (meta-&gt;_<span class="keyword">getter</span>) &#123;</span><br><span class="line">                        one = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (one) &#123;</span><br><span class="line">                        <span class="comment">// 用 yy_modelSetWithDictionary 输出化属性实例对象</span></span><br><span class="line">                        [one yy_modelSetWithDictionary:value];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Class cls = meta-&gt;_cls;</span><br><span class="line">                        <span class="comment">// 略过</span></span><br><span class="line">                        <span class="keyword">if</span> (meta-&gt;_hasCustomClassFromDictionary) &#123;</span><br><span class="line">                            cls = [cls modelCustomClassForDictionary:value];</span><br><span class="line">                            <span class="keyword">if</span> (!cls) cls = meta-&gt;_genericCls; <span class="comment">// for xcode code coverage</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 用 yy_modelSetWithDictionary 输出化属性实例对象，赋值</span></span><br><span class="line">                        one = [cls new];</span><br><span class="line">                        [one yy_modelSetWithDictionary:value];</span><br><span class="line">                        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">id</span>))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">id</span>)one);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Class</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 空，赋值(Class)NULL，由于 Class 其实是 C 语言定义的结构体，所以使用 NULL</span></span><br><span class="line">                    <span class="comment">// 关于 nil，Nil，NULL，NSNull，kCFNull 的横向比较，我会单独拎出来在下面介绍</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, Class))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (Class)<span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断 value 可能的类型 NSString 或判断 class_isMetaClass(object_getClass(value))</span></span><br><span class="line">                    <span class="comment">// 如果满足条件则赋值</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// SEL</span></span><br><span class="line">            <span class="keyword">case</span>  YYEncodingTypeSEL: &#123;</span><br><span class="line">                <span class="comment">// 判空，赋值(SEL)NULL</span></span><br><span class="line">                <span class="comment">// 否则转换类型 SEL sel = NSSelectorFromString(value); 然后赋值</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// block</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeBlock: &#123;</span><br><span class="line">                <span class="comment">// 判空，赋值(void (^)())NULL</span></span><br><span class="line">                <span class="comment">// 否则判断类型 [value isKindOfClass:YYNSBlockClass()] 之后赋值</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// struct、union、char[n]，关于 union 共同体感兴趣的同学可以自己 google，这里简单介绍一下</span></span><br><span class="line">            <span class="comment">// union 共同体，类似 struct 的存在，但是 union 每个成员会用同一个存储空间，只能存储最后一个成员的信息</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeStruct:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeUnion:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeCArray: &#123;</span><br><span class="line">                <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) &#123; </span><br><span class="line">                    <span class="comment">// 涉及 Type Encodings</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="type">char</span> *valueType = ((<span class="built_in">NSValue</span> *)value).objCType;</span><br><span class="line">                    <span class="keyword">const</span> <span class="type">char</span> *metaType = meta-&gt;_info.typeEncoding.UTF8String;</span><br><span class="line">                    <span class="comment">// 比较 valueType 与 metaType 是否相同，相同（strcmp(a, b) 返回 0）则赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (valueType &amp;&amp; metaType &amp;&amp; strcmp(valueType, metaType) == <span class="number">0</span>) &#123;</span><br><span class="line">                        [model setValue:value forKey:meta-&gt;_name];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// void* 或 char*</span></span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypePointer:</span><br><span class="line">            <span class="keyword">case</span> YYEncodingTypeCString: &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNull) &#123; <span class="comment">// 判空，赋值(void *)NULL</span></span><br><span class="line">                    ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">void</span> *))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, (<span class="type">void</span> *)<span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSValue</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                    <span class="comment">// 涉及 Type Encodings</span></span><br><span class="line">                    <span class="built_in">NSValue</span> *nsValue = value;</span><br><span class="line">                    <span class="keyword">if</span> (nsValue.objCType &amp;&amp; strcmp(nsValue.objCType, <span class="string">&quot;^v&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                        ((<span class="type">void</span> (*)(<span class="type">id</span>, SEL, <span class="type">void</span> *))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, meta-&gt;_<span class="keyword">setter</span>, nsValue.pointerValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额 😓 我是真的已经忽略掉很多代码了，没办法还是有点长。其实代码逻辑还是很简单的，只是模型赋值涉及的编码类型等琐碎逻辑比较多导致代码量比较大，我们一起来总结一下核心代码的实现逻辑。</p>
<ul>
<li>根据属性元类型划分代码逻辑</li>
<li>如果属性元是 CNumber 类型，即 int、uint 之类，则使用 <code>ModelSetNumberToProperty</code> 赋值</li>
<li>如果属性元属于 NSType 类型，即 NSString、NSNumber 之类，则根据类型转换中可能涉及到的对应类型做逻辑判断并赋值（可以去上面代码中查看具体实现逻辑）</li>
<li>如果属性元不属于 CNumber 和 NSType，则猜测为 id，Class，SEL，Block，struct、union、char[n]，void<em> 或 char</em> 类型并且做出相应的转换和赋值</li>
</ul>
<p>嘛~ 其实上面的代码除了长以外逻辑还是很简单的，总结起来就是根据可能出现的类型去做出对应的逻辑操作，建议各位有时间还是去读下源码，尤其是自己项目中用到 YYModel 的同学。相信看完之后会对 YYModel 属性赋值一清二楚，这样在使用 YYModel 的日常中出现任何问题都可以心中有数，改起代码自然如有神助哈。</p>
<p>额…考虑到 NSDictionary to Model 的整个过程代码量不小，我花了一些时间将其逻辑总结归纳为一张图：</p>
<img src="/yymodel0x02/d2m.png" class="">
<p>希望可以尽自己的努力让文章的表述变得更直白。</p>
<h3 id="Model-to-JSON"><a href="#Model-to-JSON" class="headerlink" title="Model to JSON"></a>Model to JSON</h3><img src="/yymodel0x02/m2j.jpg" class="">
<p>相比于 JSON to Model 来说，Model to JSON 更简单一些。其中因为 NSJSONSerialization 在对 JSON 的转换时做了一些规定：</p>
<ul>
<li>顶级对象是 NSArray 或者 NSDictionary 类型</li>
<li>所有的对象都是 NSString, NSNumber, NSArray, NSDictionary, 或 NSNull 的实例</li>
<li>所有字典中的 key 都是一个 NSString 实例</li>
<li>Numbers 是除去无穷大和 NaN 的其他表示</li>
</ul>
<blockquote>
<p>Note: 上文出自 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsjsonserialization">NSJSONSerialization 官方文档</a>。</p>
</blockquote>
<p>知道了这一点后，我们就可以从 YYModel 的 Model to JSON 接口 <code>yy_modelToJSONObject</code> 处开始解读源码了。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)yy_modelToJSONObject &#123;</span><br><span class="line">    <span class="comment">// 递归转换模型到 JSON</span></span><br><span class="line">    <span class="type">id</span> jsonObject = ModelToJSONObjectRecursive(<span class="keyword">self</span>);</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    <span class="keyword">if</span> ([jsonObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> jsonObject;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 一共 4 行代码，只需要关注一下第一行代码中的 <code>ModelToJSONObjectRecursive</code> 方法，<code>Objective-C</code> 的语言特性决定了从函数名称即可无需注释看懂代码，这个方法从名字上就可以 get 到它是通过递归方法使 Model 转换为 JSON 的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归转换模型到 JSON，如果转换异常则返回 nil</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">id</span> ModelToJSONObjectRecursive(<span class="built_in">NSObject</span> *model) &#123;</span><br><span class="line">    <span class="comment">// 判空或者可以直接返回的对象，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!model || model == (<span class="type">id</span>)kCFNull) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> model;</span><br><span class="line">    <span class="comment">// 如果 model 从属于 NSDictionary</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果可以直接转换为 JSON 数据，则返回</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSJSONSerialization</span> isValidJSONObject:model]) <span class="keyword">return</span> model;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *newDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">        <span class="comment">// 遍历 model 的 key 和 value</span></span><br><span class="line">        [((<span class="built_in">NSDictionary</span> *)model) enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="type">id</span> obj, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *stringKey = [key isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]] ? key : key.description;</span><br><span class="line">            <span class="keyword">if</span> (!stringKey) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 递归解析 value </span></span><br><span class="line">            <span class="type">id</span> jsonObj = ModelToJSONObjectRecursive(obj);</span><br><span class="line">            <span class="keyword">if</span> (!jsonObj) jsonObj = (<span class="type">id</span>)kCFNull;</span><br><span class="line">            newDic[stringKey] = jsonObj;</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> newDic;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 model 从属于 NSSet</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果能够直接转换 JSON 对象，则直接返回</span></span><br><span class="line">        <span class="comment">// 否则遍历，按需要递归解析</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 如果能够直接转换 JSON 对象，则直接返回</span></span><br><span class="line">        <span class="comment">// 否则遍历，按需要递归解析</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对 NSURL, NSAttributedString, NSDate, NSData 做相应处理</span></span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSURL</span> *)model).absoluteString;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSAttributedString</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> ((<span class="built_in">NSAttributedString</span> *)model).string;</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSDate</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> [YYISODateFormatter() stringFromDate:(<span class="type">id</span>)model];</span><br><span class="line">    <span class="keyword">if</span> ([model isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用 [model class] 初始化一个模型元</span></span><br><span class="line">    _YYModelMeta *modelMeta = [_YYModelMeta metaWithClass:[model <span class="keyword">class</span>]];</span><br><span class="line">    <span class="comment">// 如果映射表为空，则不做解析直接返回 nil</span></span><br><span class="line">    <span class="keyword">if</span> (!modelMeta || modelMeta-&gt;_keyMappedCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 性能优化细节，使用 __unsafe_unretained 来避免在下面遍历 block 中直接使用 result 指针造成的不必要 retain 与 release 开销</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *result = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">64</span>];</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="built_in">NSMutableDictionary</span> *dic = result;</span><br><span class="line">    <span class="comment">// 遍历模型元属性映射字典</span></span><br><span class="line">    [modelMeta-&gt;_mapper enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *propertyMappedKey, _YYModelPropertyMeta *propertyMeta, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">        <span class="comment">// 如果遍历当前属性元没有 getter 方法，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!propertyMeta-&gt;_<span class="keyword">getter</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">id</span> value = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 如果属性元属于 CNumber，即其 type 是 int、float、double 之类的</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_isCNumber) &#123;</span><br><span class="line">            <span class="comment">// 从属性中利用 getter 方法得到对应的值</span></span><br><span class="line">            value = ModelCreateNumberFromProperty(model, propertyMeta);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (propertyMeta-&gt;_nsType) &#123; <span class="comment">// 属性元属于 nsType，即 NSString 之类</span></span><br><span class="line">            <span class="comment">// 利用 getter 方法拿到 value</span></span><br><span class="line">            <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">            <span class="comment">// 对拿到的 value 递归解析</span></span><br><span class="line">            value = ModelToJSONObjectRecursive(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 根据属性元的 type 做相应处理</span></span><br><span class="line">            <span class="keyword">switch</span> (propertyMeta-&gt;_type &amp; YYEncodingTypeMask) &#123;</span><br><span class="line">                <span class="comment">// id，需要递归解析，如果解析失败则返回 nil</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeObject: &#123;</span><br><span class="line">                    <span class="type">id</span> v = ((<span class="type">id</span> (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = ModelToJSONObjectRecursive(v);</span><br><span class="line">                    <span class="keyword">if</span> (value == (<span class="type">id</span>)kCFNull) value = <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// Class，转 NSString，返回 Class 名称</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeClass: &#123;</span><br><span class="line">                    Class v = ((Class (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromClass</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// SEL，转 NSString，返回给定 SEL 的字符串表现形式</span></span><br><span class="line">                <span class="keyword">case</span> YYEncodingTypeSEL: &#123;</span><br><span class="line">                    SEL v = ((SEL (*)(<span class="type">id</span>, SEL))(<span class="type">void</span> *) objc_msgSend)((<span class="type">id</span>)model, propertyMeta-&gt;_<span class="keyword">getter</span>);</span><br><span class="line">                    value = v ? <span class="built_in">NSStringFromSelector</span>(v) : <span class="literal">nil</span>;</span><br><span class="line">                &#125; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 value 还是没能解析，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前属性元是 KeyPath 映射，即 a.b.c 之类</span></span><br><span class="line">        <span class="keyword">if</span> (propertyMeta-&gt;_mappedToKeyPath) &#123;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *superDic = dic;</span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subDic = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">// _mappedToKeyPath 是 a.b.c 根据 &#x27;.&#x27; 拆分成的字符串数组，遍历 _mappedToKeyPath</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>, max = propertyMeta-&gt;_mappedToKeyPath.count; i &lt; max; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = propertyMeta-&gt;_mappedToKeyPath[i];</span><br><span class="line">                <span class="comment">// 遍历到结尾</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> == max) &#123;</span><br><span class="line">                    <span class="comment">// 如果结尾的 key 为 nil，则使用 value 赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (!superDic[key]) superDic[key] = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 用 subDic 拿到当前 key 对应的值</span></span><br><span class="line">                subDic = superDic[key];</span><br><span class="line">                <span class="comment">// 如果 subDic 存在</span></span><br><span class="line">                <span class="keyword">if</span> (subDic) &#123;</span><br><span class="line">                    <span class="comment">// 如果 subDic 从属于 NSDictionary</span></span><br><span class="line">                    <span class="keyword">if</span> ([subDic isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                        <span class="comment">// 将 subDic 的 mutable 版本赋值给 superDic[key]</span></span><br><span class="line">                        subDic = subDic.mutableCopy;</span><br><span class="line">                        superDic[key] = subDic;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将 NSMutableDictionary 赋值给 superDic[key]</span></span><br><span class="line">                    <span class="comment">// 注意这里使用 subDic 间接赋值是有原因的，原因就在下面</span></span><br><span class="line">                    subDic = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                    superDic[key] = subDic;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// superDic 指向 subDic，这样在遍历 _mappedToKeyPath 时即可逐层解析</span></span><br><span class="line">                <span class="comment">// 这就是上面先把 subDic 转为 NSMutableDictionary 的原因</span></span><br><span class="line">                superDic = subDic;</span><br><span class="line">                subDic = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是 KeyPath 则检测 dic[propertyMeta-&gt;_mappedToKey]，如果为 nil 则赋值 value</span></span><br><span class="line">            <span class="keyword">if</span> (!dic[propertyMeta-&gt;_mappedToKey]) &#123;</span><br><span class="line">                dic[propertyMeta-&gt;_mappedToKey] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略，对应 modelCustomTransformToDictionary 接口</span></span><br><span class="line">    <span class="keyword">if</span> (modelMeta-&gt;_hasCustomTransformToDictionary) &#123;</span><br><span class="line">        <span class="comment">// 用于在默认的 Model 转 JSON 过程不适合当前 Model 类型时提供自定义额外过程</span></span><br><span class="line">        <span class="comment">// 也可以用这个方法来验证转换结果</span></span><br><span class="line">        <span class="type">BOOL</span> suc = [((<span class="type">id</span>&lt;YYModel&gt;)model) modelCustomTransformToDictionary:dic];</span><br><span class="line">        <span class="keyword">if</span> (!suc) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额…代码还是有些长，不过相比于之前 JSON to Model 方向上由 <code>yy_modelSetWithDictionary</code>，<code>ModelSetWithDictionaryFunction</code> 和 <code>ModelSetValueForProperty</code> 三个方法构成的间接递归来说算是非常简单了，那么总结一下上面的代码逻辑。</p>
<ul>
<li>判断入参，如果满足条件可以直接返回</li>
<li>如果 Model 从属于 NSType，则根据不同的类型做逻辑处理</li>
<li>如果上面条件不被满足，则用 Model 的 Class 初始化一个模型元 _YYModelMeta</li>
<li>判断模型元的映射关系，遍历映射表拿到对应键值对并存入字典中并返回</li>
</ul>
<blockquote>
<p>Note: 这里有一个性能优化的细节，用 <code>__unsafe_unretained</code> 修饰的 dic 指向我们最后要 return 的 NSMutableDictionary *result，看作者的注释：<code>// avoid retain and release in block</code> 是为了避免直接使用 <code>result</code> 在后面遍历映射表的代码块中不必要的 retain 和 release 操作以节省开销。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章紧接上文<a href="https://lision.me/yymodel_x01/">《揭秘 YYModel 的魔法（上）》</a>中对 YYModel 代码结构的讲解后将重点放到了对 JSON 模型相互转换的实现逻辑上。</li>
<li>从 JSON 模型的转换方向上划分，将 YYModel 的 JSON 模型转换过程正反方向剖析揭秘，希望可以解开大家对 JSON 模型自动转换的疑惑。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a><a class="tag-none-link" href="/tags/yymodel/" rel="tag">yymodel</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yymodel0x01/">
      揭秘 YYModel 的魔法 0x01
    </a>
  </h2>
  
  <time>
    11月 12, 2017
  </time>
  <section class="content">
	  <img src="/yymodel0x01/design_model_0x01.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中少不了各种各样的模型，不论是采用 MVC、MVP 还是 MVVM 设计模式都逃不过 Model。</p>
<p>那么大家在使用 Model 的时候肯定遇到过一个问题，即接口传递过来的数据（一般是 JSON 格式）需要转换为 iOS 内我们能直接使用的模型（类）。iOS 开发早期第三方框架没有那么多，大家可能会手写相关代码，但是随着业务的扩展，模型的增多，这些没什么技术含量的代码只是在重复的浪费我们的劳动力而已。</p>
<p>这时候就需要一种工具来帮助我们把劳动力从这些无意义的繁琐代码中解放出来，于是 GitHub 上出现了很多解决此类问题的第三方库，诸如 Mantle、JSONModel、MJExtension 以及 YYModel 等等。</p>
<p>这些库的神奇之处在于它们提供了模型与 JSON 数据的自动转换功能，仿佛具有魔法一般！本文将通过剖析 YYModel 源码一步一步破解这“神奇”的魔法。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel">YYModel</a> 是一个高性能 iOS/OSX 模型转换框架（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 在我之前的文章【<a href="https://lision.me/yycache/">从 YYCache 源码 Get 到如何设计一个优秀的缓存</a>】中已经很详细的介绍过了，感兴趣的同学可以点进去了解一下。</p>
<p>YYModel 是一个非常轻量级的 JSON 模型自动转换库，代码风格良好且思路清晰，可以从源码中看到作者对 Runtime 深厚的理解。难能可贵的是 YYModel 在其轻量级的代码下还保留着自动类型转换，类型安全，无侵入等特性，并且具有接近手写解析代码的超高性能。</p>
<blockquote>
<p>处理 GithubUser 数据 10000 次耗时统计 (iPhone 6):</p>
</blockquote>
<img src="/yymodel0x01/yymodel_performance.png" class="">
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYModel 简介</li>
<li>YYClassInfo 剖析</li>
<li>NSObject+YYModel 探究</li>
<li>JSON 与 Model 相互转换</li>
<li>总结</li>
</ul>
<h2 id="YYModel-简介"><a href="#YYModel-简介" class="headerlink" title="YYModel 简介"></a>YYModel 简介</h2><img src="/yymodel0x01/yymodel.png" class="">
<p>撸了一遍 YYModel 的源码，果然是非常轻量级的 JSON 模型自动转换库，加上 YYModel.h 一共也只有 5 个文件。</p>
<p>抛开 YYModel.h 来看，其实只有 YYClassInfo 和 NSObject+YYModel 两个模块。</p>
<ul>
<li>YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用。</li>
<li>NSObject+YYModel 负责提供方便调用的接口以及实现具体的模型转换逻辑（借助 YYClassInfo 中的封装）。</li>
</ul>
<h2 id="YYClassInfo-剖析"><a href="#YYClassInfo-剖析" class="headerlink" title="YYClassInfo 剖析"></a>YYClassInfo 剖析</h2><img src="/yymodel0x01/yyclassinfo.jpg" class="">
<p>前面说到 YYClassInfo 主要将 Runtime 层级的一些结构体封装到 NSObject 层级以便调用，我觉得如果需要与 Runtime 层级的结构体做对比的话，没什么比表格来的更简单直观了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">YYClassInfo</th>
<th style="text-align:center">Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">YYClassIvarInfo</td>
<td style="text-align:center"><code>objc_ivar</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassMethodInfo</td>
<td style="text-align:center"><code>objc_method</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassPropertyInfo</td>
<td style="text-align:center"><code>property_t</code></td>
</tr>
<tr>
<td style="text-align:center">YYClassInfo</td>
<td style="text-align:center"><code>objc_class</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Note: 本次比较基于 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">Runtime 源码</a> 723 版本。</p>
</blockquote>
<p>安~ 既然是剖析肯定不会列个表格这样子哈。</p>
<h3 id="YYClassIvarInfo-amp-amp-objc-ivar"><a href="#YYClassIvarInfo-amp-amp-objc-ivar" class="headerlink" title="YYClassIvarInfo &amp;&amp; objc_ivar"></a>YYClassIvarInfo &amp;&amp; objc_ivar</h3><p>我把 YYClassIvarInfo 看做是作者对 Runtime 层 <code>objc_ivar</code> 结构体的封装，<code>objc_ivar</code> 是 Runtime 中表示变量的结构体。</p>
<ul>
<li>YYClassIvarInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassIvarInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Ivar ivar; <span class="comment">///&lt; 变量，对应 objc_ivar</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 变量名称，对应 ivar_name</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) ptrdiff_t offset; <span class="comment">///&lt; 变量偏移量，对应 ivar_offset</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 变量类型编码，通过 ivar_getTypeEncoding 函数得到</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 变量类型，通过 YYEncodingGetType 方法从类型编码中得到</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithIvar:(Ivar)ivar;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_ivar</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_ivar &#123;</span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_name OBJC2_UNAVAILABLE; <span class="comment">// 变量名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable ivar_type OBJC2_UNAVAILABLE; <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="type">int</span> ivar_offset OBJC2_UNAVAILABLE; <span class="comment">// 变量偏移量</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__ <span class="comment">// 如果已定义 __LP64__ 则表示正在构建 64 位目标</span></span></span><br><span class="line">    <span class="type">int</span> space OBJC2_UNAVAILABLE; <span class="comment">// 变量空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 日常开发中 NSString 类型的属性我们都会用 copy 来修饰，而 YYClassIvarInfo 中的 <code>name</code> 和 <code>typeEncoding</code> 属性都用 strong 修饰。因为其内部是先通过 Runtime 方法拿到 <code>const char *</code> 之后通过 <code>stringWithUTF8String</code> 方法转为 NSString 的。所以即便是 NSString 这类属性在确定其不会在初始化之后被修改的情况下，使用 strong 做一次单纯的强引用在性能上讲比 copy 要高一些。</p>
</blockquote>
<p>囧~ 不知道讲的这么细会不会反而引起反感，如果对文章有什么建议可以联系我 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">@薛定谔的猹</a> 。</p>
<blockquote>
<p>Note: 类型编码，关于 YYClassIvarInfo 中的 YYEncodingType 类型属性 type 的解析代码篇幅很长，而且没有搬出来的必要，可以参考官方文档 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encodings</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html">Declared Properties</a> 阅读这部分源码。</p>
</blockquote>
<h3 id="YYClassMethodInfo-amp-amp-objc-method"><a href="#YYClassMethodInfo-amp-amp-objc-method" class="headerlink" title="YYClassMethodInfo &amp;&amp; objc_method"></a>YYClassMethodInfo &amp;&amp; objc_method</h3><p>相应的，YYClassMethodInfo 则是作者对 Runtime 中 <code>objc_method</code> 的封装，<code>objc_method</code> 在 Runtime 是用来定义方法的结构体。</p>
<ul>
<li>YYClassMethodInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassMethodInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Method method; <span class="comment">///&lt; 方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 方法名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL sel; <span class="comment">///&lt; 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) IMP imp; <span class="comment">///&lt; 方法实现，指向实现方法函数的函数指针</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 方法参数和返回类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *returnTypeEncoding; <span class="comment">///&lt; 返回值类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *argumentTypeEncodings; <span class="comment">///&lt; 参数类型编码数组</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMethod:(Method)method;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_method</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">    SEL _Nonnull method_name OBJC2_UNAVAILABLE; <span class="comment">// 方法名称</span></span><br><span class="line">    <span class="type">char</span> * _Nullable method_types OBJC2_UNAVAILABLE; <span class="comment">// 方法类型</span></span><br><span class="line">    IMP _Nonnull method_imp OBJC2_UNAVAILABLE; <span class="comment">// 方法实现（函数指针）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到基本也是一一对应的关系，除了类型编码的问题作者为了方便使用在封装时进行了扩展。</p>
<p>为了照顾对 Runtime 还没有一定了解的读者，我这里简单的解释一下 <code>objc_method</code> 结构体（都是我自己的认知，欢迎讨论）：</p>
<ul>
<li>SEL，selector 在 Runtime 中的表现形式，可以理解为方法选择器</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<ul>
<li>IMP，函数指针，指向具体实现逻辑的函数</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*IMP)(<span class="type">void</span> <span class="comment">/* id, SEL, ... */</span> ); </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">id</span> _Nullable (*IMP)(<span class="type">id</span> _Nonnull, SEL _Nonnull, ...); </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>关于更多 Runtime 相关的知识由于篇幅原因（真的写不完）就不在这篇文章介绍了，我推荐大家去鱼神的文章 <a target="_blank" rel="noopener" href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a> 学习（因为我最早接触 Runtime 就是通过这篇文章，笑~）。</p>
<p>有趣的是，鱼神的文章中对 SEL 的描述有一句“其实它就是个映射到方法的 C 字符串”，但是他在文章中没有介绍出处。本着对自己文章质量负责的原则，对于一切没有出处的表述都应该持有怀疑的态度，所以我下面讲一下自己的对于 SEL 的理解。</p>
<p>撸了几遍 Runtime 源码，发现不论是 objc-runtime-new 还是 objc-runtime-old 中都用 SEL 类型作为方法结构体的 name 属性类型，而且通过以下源码：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT SEL _Nonnull sel_registerName(<span class="keyword">const</span> <span class="type">char</span> * _Nonnull str)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">const</span> <span class="type">char</span> * _Nonnull sel_getName(SEL _Nonnull sel)</span><br><span class="line">    OBJC_AVAILABLE(<span class="number">10.0</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到通过一个 <code>const char *</code> 类型的字符串即可在 Runtime 系统中注册并返回一个 SEL，方法的名称则会映射到这个 SEL。</p>
<blockquote>
<p>官方注释：<br>Registers a method with the Objective-C runtime system, maps the method name to a selector, and returns the selector value.</p>
</blockquote>
<p>所以我觉得 SEL 和 <code>char *</code> 的的确确是有某种一一对应的映射关系，不过 SEL 的本质是否是 <code>char *</code> 就要打一个问号了。因为我在调试 SEL 阶段发现 SEL 内还有一个当前 SEL 的指针，与 <code>char *</code> 不同的是当 <code>char *</code> 赋值之后当前 <code>char *</code> 变量指针指向字符串首字符，而 SEL 则是 <no value available>，即我们无法直接看到它。</p>
<p>所以我做了一个无聊的测试，用相同的字符串初始化一个 <code>char *</code> 实例与一个 SEL 实例，之后尝试打印它们，有趣的是不论我使用 <code>%s</code> 还是 <code>%c</code> 都可以从两个实例中得到相同的打印输出，不知道鱼神是否做过相同的测试（笑~）</p>
<p>嘛~ 经过验证我们可以肯定 SEL 和 <code>char *</code> 存在某种映射关系，可以相互转换。同时猜测 SEL 本质上就是 <code>char *</code>，如果有哪位知道 SEL 与 <code>char *</code> 确切关系的可以留言讨论哟。</p>
<h3 id="YYClassPropertyInfo-amp-amp-property-t"><a href="#YYClassPropertyInfo-amp-amp-property-t" class="headerlink" title="YYClassPropertyInfo &amp;&amp; property_t"></a>YYClassPropertyInfo &amp;&amp; property_t</h3><p>YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装，<code>property_t</code> 在 Runtime 中是用来表示属性的结构体。</p>
<ul>
<li>YYClassPropertyInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassPropertyInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) objc_property_t property; <span class="comment">///&lt; 属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 属性名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) YYEncodingType type; <span class="comment">///&lt; 属性类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *typeEncoding; <span class="comment">///&lt; 属性类型编码</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *ivarName; <span class="comment">///&lt; 变量名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *protocols; <span class="comment">///&lt; 属性相关协议</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">getter</span>; <span class="comment">///&lt; getter 方法选择器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) SEL <span class="keyword">setter</span>; <span class="comment">///&lt; setter 方法选择器</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithProperty:(objc_property_t)property;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>property_t</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name; <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes; <span class="comment">// 修饰</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为什么说 YYClassPropertyInfo 是作者对 <code>property_t</code> 的封装呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-private.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __OBJC2__</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> property_t *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> old_property *objc_property_t;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// objc-runtime-new.h</span></span><br><span class="line"><span class="keyword">struct</span> property_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里唯一值得注意的就是 getter 与 setter 方法了。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先尝试获取属性的 getter 与 setter</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomGetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>: &#123;</span><br><span class="line">        type |= YYEncodingTypePropertyCustomSetter;</span><br><span class="line">        <span class="keyword">if</span> (attrs[i].value) &#123;</span><br><span class="line">            _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithUTF8String:attrs[i].value]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果没有则按照标准规则自己造</span></span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">getter</span>) &#123;</span><br><span class="line">    _<span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>(_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!_<span class="keyword">setter</span>) &#123;</span><br><span class="line">    _<span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;set%@%@:&quot;</span>, [_name substringToIndex:<span class="number">1</span>].uppercaseString, [_name substringFromIndex:<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="YYClassInfo-amp-amp-objc-class"><a href="#YYClassInfo-amp-amp-objc-class" class="headerlink" title="YYClassInfo &amp;&amp; objc_class"></a>YYClassInfo &amp;&amp; objc_class</h3><p>最后作者用 YYClassInfo 封装了 <code>objc_class</code>，<code>objc_class</code> 在 Runtime 中表示一个 Objective-C 类。</p>
<ul>
<li>YYClassInfo</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYClassInfo</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class cls; <span class="comment">///&lt; 类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class superCls; <span class="comment">///&lt; 超类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) Class metaCls;  <span class="comment">///&lt; 元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="type">BOOL</span> isMeta; <span class="comment">///&lt; 元类标识，自身是否为元类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name; <span class="comment">///&lt; 类名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYClassInfo *superClassInfo; <span class="comment">///&lt; 父类（超类）信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassIvarInfo *&gt; *ivarInfos; <span class="comment">///&lt; 变量信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassMethodInfo *&gt; *methodInfos; <span class="comment">///&lt; 方法信息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, YYClassPropertyInfo *&gt; *propertyInfos; <span class="comment">///&lt; 属性信息</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setNeedUpdate;</span><br><span class="line">- (<span class="type">BOOL</span>)needUpdate;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)classInfoWithClassName:(<span class="built_in">NSString</span> *)className;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>objc_class</code></li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime.h</span></span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class _Nonnull isa OBJC_ISA_AVAILABILITY; <span class="comment">// isa 指针</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !__OBJC2__</span></span><br><span class="line">    Class _Nullable super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类（超类）指针</span></span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> * _Nonnull name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 版本</span></span><br><span class="line">    <span class="type">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 信息</span></span><br><span class="line">    <span class="type">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 初始尺寸</span></span><br><span class="line">    <span class="keyword">struct</span> objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; <span class="comment">// 变量列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; <span class="comment">// 缓存</span></span><br><span class="line">    <span class="keyword">struct</span> objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE; <span class="comment">// 协议列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>额… 看来想完全避开 Runtime 的知识来讲 YYModel 源码是不现实的。这里简单介绍一下 Runtime 中关于 Class 的知识以便阅读，已经熟悉这方面知识的同学就当温习一下好了。</p>
<img src="/yymodel0x01/class_diagram.jpg" class="">
<ul>
<li>isa 指针，用于找到所属类，类对象的 isa 一般指向对应元类。</li>
<li>元类，由于 objc_class 继承于 objc_object，即类本身同时也是一个对象，所以 Runtime 库设计出元类用以表述类对象自身所具备的元数据。</li>
<li>cache，实际上当一个对象收到消息时并不会直接在 isa 指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了。为了优化方法调用的效率，加入了 cache，也就是说在收到消息时，会先去 cache 中查找，找不到才会去像上图所示遍历查找，相信苹果为了提升缓存命中率，应该也花了一些心思（笑~）。</li>
<li>version，我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。</li>
</ul>
<blockquote>
<p>关于 Version 的官方描述：<br>Classes derived from the Foundation framework NSObject class can set the class-definition version number using the setVersion: class method, which is implemented using the class_setVersion function.</p>
</blockquote>
<h4 id="YYClassInfo-的初始化细节"><a href="#YYClassInfo-的初始化细节" class="headerlink" title="YYClassInfo 的初始化细节"></a>YYClassInfo 的初始化细节</h4><p>关于 YYClassInfo 的初始化细节我觉得还是有必要分享出来的。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)classInfoWithClass:(Class)cls &#123;</span><br><span class="line">    <span class="comment">// 判空入参</span></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单例缓存 classCache 与 metaCache，对应缓存类和元类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> classCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> metaCache;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="keyword">static</span> dispatch_semaphore_t lock;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        classCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        metaCache = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">// 这里把 dispatch_semaphore 当做锁来使用（当信号量只有 1 时）</span></span><br><span class="line">        lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化之前，首先会根据当前 YYClassInfo 是否为元类去对应的单例缓存中查找</span></span><br><span class="line">    <span class="comment">// 这里使用了上面的 dispatch_semaphore 加锁，保证单例缓存的线程安全 </span></span><br><span class="line">    dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    YYClassInfo *info = <span class="built_in">CFDictionaryGetValue</span>(class_isMetaClass(cls) ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls));</span><br><span class="line">    <span class="comment">// 如果找到了，且找到的信息需要更新的话则执行更新操作</span></span><br><span class="line">    <span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">        [info _update];</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_semaphore_signal(lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没找到，才会去老实初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!info) &#123;</span><br><span class="line">        info = [[YYClassInfo alloc] initWithClass:cls];</span><br><span class="line">        <span class="keyword">if</span> (info) &#123; <span class="comment">// 初始化成功</span></span><br><span class="line">            <span class="comment">// 线程安全</span></span><br><span class="line">            dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">            <span class="comment">// 根据初始化信息选择向对应的类/元类缓存注入信息，key = cls，value = info</span></span><br><span class="line">            <span class="built_in">CFDictionarySetValue</span>(info.isMeta ? metaCache : classCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(cls), (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(info));</span><br><span class="line">            dispatch_semaphore_signal(lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下初始化的主要步骤：</p>
<ul>
<li>创建单例缓存，类缓存和元类缓存</li>
<li>使用 <code>dispatch_semaphore</code> 作为锁保证缓存线程安全</li>
<li>初始化前先去缓存中查找是否已经向缓存中注册过当前要初始化的 YYClassInfo</li>
<li>如果查找到缓存对象，则判断缓存对象是否需要更新并执行相关操作</li>
<li>如果缓存中未找到缓存对象则初始化</li>
<li>初始化成功后向缓存中注册该 YYClassInfo 实例</li>
</ul>
<p>其中，使用缓存可以有效减少我们在 JSON 模型转换时反复初始化 YYClassInfo 带来的开销，而 <code>dispatch_semaphore</code> 在信号量为 1 时是可以当做锁来使用的，虽然它在阻塞时效率超低，但是对于代码中的缓存阻塞这里属于低频事件，使用 <code>dispatch_semaphore</code> 在非阻塞状态下性能很高，这里锁的选择非常合适。</p>
<h4 id="关于-YYClassInfo-的更新"><a href="#关于-YYClassInfo-的更新" class="headerlink" title="关于 YYClassInfo 的更新"></a>关于 YYClassInfo 的更新</h4><p>首先 YYClassInfo 是作者对应 <code>objc_class</code> 封装出来的类，所以理应在其对应的 <code>objc_class</code> 实例发生变化时更新。那么 <code>objc_class</code> 什么时候会发生变化呢？</p>
<p>嘛~ 比如你使用了 <code>class_addMethod</code> 方法为你的模型类加入了一个方法等等。</p>
<p>YYClassInfo 有一个私有 BOOL 类型参数 <code>_needUpdate</code> 用以表示当前的 YYClassInfo 实例是否需要更新，并且提供了 <code>- (void)setNeedUpdate;</code> 接口方便我们在更改了自己的模型类时调用其将 <code>_needUpdate</code> 设置为 YES，当 <code>_needUpdate</code> 为 YES 时后面就不用我说了，相关的代码在上一节初始化中有哦。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (info &amp;&amp; info-&gt;_needUpdate) &#123;</span><br><span class="line">    [info _update];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单介绍一下 <code>_update</code>，它是 YYClassInfo 的私有方法，它的实现逻辑简单介绍就是清空当前 YYClassInfo 实例变量，方法以及属性，之后再重新初始化它们。由于 <code>_update</code> 实现源码并没有什么特别之处，我这里就不贴源码了。</p>
<p>嘛~ 对 YYClassInfo 的剖析到这里就差不多了。</p>
<h2 id="NSObject-YYModel-探究"><a href="#NSObject-YYModel-探究" class="headerlink" title="NSObject+YYModel 探究"></a>NSObject+YYModel 探究</h2><img src="/yymodel0x01/nsobject_yymodel.jpg" class="">
<p>如果说 YYClassInfo 主要是作者对 Runtime 层在 JSON 模型转换中需要用到的结构体的封装，那么 NSObject+YYModel 在 YYModel 中担当的责任则是利用 YYClassInfo 层级封装好的类切实的执行 JSON 模型之间的转换逻辑，并且提供了无侵入性的接口。</p>
<p>第一次阅读 NSObject+YYModel.m 的源码可能会有些不适应，这很正常。因为其大量使用了 Runtime 函数与 CoreFoundation 库，加上各种类型编码和递归解析，代码量也有 1800 多行了。</p>
<p>我简单把 NSObject+YYModel.m 的源码做了一下划分，这样划分之后代码看起来一样很简单清晰：</p>
<ul>
<li>类型编码解析</li>
<li>数据结构定义</li>
<li>递归模型转换</li>
<li>接口相关代码</li>
</ul>
<h3 id="类型编码解析"><a href="#类型编码解析" class="headerlink" title="类型编码解析"></a>类型编码解析</h3><p>类型编码解析代码主要集中在 NSObject+YYModel.m 的上面部分，涉及到 YYEncodingNSType 枚举的定义，配套 <code>YYClassGetNSType</code> 函数将 NS 类型转为 YYEncodingNSType 还有 <code>YYEncodingTypeIsCNumber</code> 函数判断类型是否可以直接转为 C 语言数值类型的函数。</p>
<p>此外还有将 id 指针转为对应 NSNumber 的函数 <code>YYNSNumberCreateFromID</code>，将 NSString 转为 NSDate 的 <code>YYNSDateFromString</code> 函数，这类函数主要是方便在模型转换时使用。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline <span class="built_in">NSDate</span> *YYNSDateFromString(__<span class="keyword">unsafe_unretained</span> <span class="built_in">NSString</span> *string) &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">NSDate</span>* (^YYNSDateParseBlock)(<span class="built_in">NSString</span> *string);</span><br><span class="line">    <span class="comment">// YYNSDateFromString 支持解析的最长时间字符串</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> kParserNum 34</span></span><br><span class="line">    <span class="comment">// 这里创建了一个单例时间解析代码块数组</span></span><br><span class="line">    <span class="comment">// 为了避免重复创建这些 NSDateFormatter，它的初始化开销不小</span></span><br><span class="line">    <span class="keyword">static</span> YYNSDateParseBlock blocks[kParserNum + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">// 这里拿 `yyyy-MM-dd` 举例分析</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             2014-01-20  // Google</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">            formatter.locale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@&quot;en_US_POSIX&quot;</span>];</span><br><span class="line">            formatter.timeZone = [<span class="built_in">NSTimeZone</span> timeZoneForSecondsFromGMT:<span class="number">0</span>];</span><br><span class="line">            formatter.dateFormat = <span class="string">@&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line">            <span class="comment">// 这里使用 blocks[10] 是因为 `yyyy-MM-dd` 的长度就是 10</span></span><br><span class="line">            blocks[<span class="number">10</span>] = ^(<span class="built_in">NSString</span> *string) &#123; <span class="keyword">return</span> [formatter dateFromString:string]; &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他的格式都是一样类型的代码，省略</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!string) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (string.length &gt; kParserNum) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 根据入参的长度去刚才存满各种格式时间解析代码块的单例数组取出对应的代码块执行</span></span><br><span class="line">    YYNSDateParseBlock parser = blocks[string.length];</span><br><span class="line">    <span class="keyword">if</span> (!parser) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> parser(string);</span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> kParserNum</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 iOS 7 之前 NSDateFormatter 是<strong>非线程安全</strong>的。</p>
</blockquote>
<p>除此之外还用 YYNSBlockClass 指向了 NSBlock 类，实现过程也比较巧妙。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> force_inline Class YYNSBlockClass() &#123;</span><br><span class="line">    <span class="keyword">static</span> Class cls;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="type">void</span> (^block)(<span class="type">void</span>) = ^&#123;&#125;;</span><br><span class="line">        cls = ((<span class="built_in">NSObject</span> *)block).class;</span><br><span class="line">        <span class="comment">// 轮询父类直到父类指向 NSObject 停止</span></span><br><span class="line">        <span class="keyword">while</span> (class_getSuperclass(cls) != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">            cls = class_getSuperclass(cls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cls; <span class="comment">// 拿到的就是 &quot;NSBlock&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>force_inline</code> 这种代码技巧，我说过我在写完 YYModel 或者攒到足够多的时候会主动拿出来与大家分享这些代码技巧，不过这里大家通过字面也不难理解，就是强制内联。</p>
<p>嘛~ 关于内联函数应该不需要我多说（笑）。</p>
<h3 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h3><p>NSObject+YYModel 中重新定义了两个类，通过它们来使用 YYClassInfo 中的封装。</p>
<table>
<thead>
<tr>
<th style="text-align:center">NSObject+YYModel</th>
<th style="text-align:center">YYClassInfo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>_YYModelPropertyMeta</code></td>
<td style="text-align:center">YYClassPropertyInfo</td>
</tr>
<tr>
<td style="text-align:center"><code>_YYModelMeta</code></td>
<td style="text-align:center">YYClassInfo</td>
</tr>
</tbody>
</table>
<h4 id="YYModelPropertyMeta"><a href="#YYModelPropertyMeta" class="headerlink" title="_YYModelPropertyMeta"></a>_YYModelPropertyMeta</h4><p><code>_YYModelPropertyMeta</code> 表示模型对象中的属性信息，它包含 YYClassPropertyInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelPropertyMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">NSString</span> *_name;             <span class="comment">///&lt; 属性名称</span></span><br><span class="line">    YYEncodingType _type;        <span class="comment">///&lt; 属性类型</span></span><br><span class="line">    YYEncodingNSType _nsType;    <span class="comment">///&lt; 属性在 Foundation 框架中的类型</span></span><br><span class="line">    <span class="type">BOOL</span> _isCNumber;             <span class="comment">///&lt; 是否为 CNumber</span></span><br><span class="line">    Class _cls;                  <span class="comment">///&lt; 属性类</span></span><br><span class="line">    Class _genericCls;           <span class="comment">///&lt; 属性包含的泛型类型，没有则为 nil</span></span><br><span class="line">    SEL _<span class="keyword">getter</span>;                 <span class="comment">///&lt; getter</span></span><br><span class="line">    SEL _<span class="keyword">setter</span>;                 <span class="comment">///&lt; setter</span></span><br><span class="line">    <span class="type">BOOL</span> _isKVCCompatible;       <span class="comment">///&lt; 如果可以使用 KVC 则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _isStructAvailableForKeyedArchiver; <span class="comment">///&lt; 如果可以使用 archiver/unarchiver 归/解档则返回 YES</span></span><br><span class="line">    <span class="type">BOOL</span> _hasCustomClassFromDictionary; <span class="comment">///&lt; 类/泛型自定义类型，例如需要在数组中实现不同类型的转换需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     property-&gt;key:       _mappedToKey:key     _mappedToKeyPath:nil            _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keyPath:   _mappedToKey:keyPath _mappedToKeyPath:keyPath(array) _mappedToKeyArray:nil</span></span><br><span class="line"><span class="comment">     property-&gt;keys:      _mappedToKey:keys[0] _mappedToKeyPath:nil/keyPath    _mappedToKeyArray:keys(array)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSString</span> *_mappedToKey;      <span class="comment">///&lt; 映射 key</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyPath;   <span class="comment">///&lt; 映射 keyPath，如果没有映射到 keyPath 则返回 nil</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_mappedToKeyArray;  <span class="comment">///&lt; key 或者 keyPath 的数组，如果没有映射多个键的话则返回 nil</span></span><br><span class="line">    YYClassPropertyInfo *_info;  <span class="comment">///&lt; 属性信息，详见上文 YYClassPropertyInfo &amp;&amp; property_t 章节</span></span><br><span class="line">    _YYModelPropertyMeta *_next; <span class="comment">///&lt; 如果有多个属性映射到同一个 key 则指向下一个模型属性元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="YYModelMeta"><a href="#YYModelMeta" class="headerlink" title="_YYModelMeta"></a>_YYModelMeta</h4><p><code>_YYModelMeta</code> 表示模型的类信息，它包含 YYClassInfo。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYModelMeta</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    YYClassInfo *_classInfo;</span><br><span class="line">    <span class="comment">/// Key:被映射的 key 与 keyPath, Value:_YYModelPropertyMeta.</span></span><br><span class="line">    <span class="built_in">NSDictionary</span> *_mapper;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 当前模型的所有 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_allPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到 keyPath 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_keyPathPropertyMetas;</span><br><span class="line">    <span class="comment">/// Array&lt;_YYModelPropertyMeta&gt;, 被映射到多个 key 的 _YYModelPropertyMeta 数组</span></span><br><span class="line">    <span class="built_in">NSArray</span> *_multiKeysPropertyMetas;</span><br><span class="line">    <span class="comment">/// 映射 key 与 keyPath 的数量，等同于 _mapper.count</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _keyMappedCount;</span><br><span class="line">    <span class="comment">/// 模型 class 类型</span></span><br><span class="line">    YYEncodingNSType _nsType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 忽略</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="递归模型转换"><a href="#递归模型转换" class="headerlink" title="递归模型转换"></a>递归模型转换</h3><p>NSObject+YYModel.m 内写了一些（间接）递归模型转换相关的函数，如 <code>ModelToJSONObjectRecursive</code> 之类的，由于涉及繁杂的模型编码解析以及代码量比较大等原因我不准备放在这里详细讲解。</p>
<p>我认为这种逻辑并不复杂但是牵扯较多的函数代码与结构/类型定义代码不同，后者更适合列出源码让读者对数据有全面清醒的认识，而前者结合功能实例讲更容易使读者对整条功能的流程有一个更透彻的理解。</p>
<p>所以我准备放到后面 JSON 与 Model 相互转换时一起讲。</p>
<h3 id="接口相关代码"><a href="#接口相关代码" class="headerlink" title="接口相关代码"></a>接口相关代码</h3><p>嘛~ 理由同上。</p>
<h2 id="半章总结"><a href="#半章总结" class="headerlink" title="半章总结"></a>半章总结</h2><ul>
<li>文章对 YYModel 源码进行了系统解读，有条理的介绍了 YYModel 的结构，相信会让各位对 YYModel 的代码结构有一个清晰的认识。</li>
<li>深入剖析了 YYClassInfo 的 4 个类，并详细讲解了它们与 Runtime 层级结构体的对应。</li>
<li>在剖析 YYClassInfo 章节中分享了一些我在阅读源码的过程中发现的并且觉得值得分享的处理细节，比如为什么作者选择用 <code>strong</code> 来修饰 NSString 等。顺便还对 SEL 与 <code>char *</code> 的关系做了实验得出了我的推论。</li>
<li>把 YYClassInfo 的初始化以及更新细节单独拎出来做了分析。</li>
<li>探究 NSObject+YYModel 源码（分享了一些实现细节）并对其实现代码做了划分，希望能够对读者阅读 YYModel 源码时提供一些小小的帮助。</li>
</ul>
<p>嘛~ 上篇差不多就这样了。我写的上一篇 YYKit 源码系列文章<a href="https://lision.me/yycache/">【从 YYCache 源码 Get 到如何设计一个优秀的缓存】</a>收到了不少的好评和支持（掘金里一位读者 <a target="_blank" rel="noopener" href="https://juejin.im/user/5912c8b2da2f600053723275">@ios123456</a> 的评论更是暖化了我），这些美好的东西让我更加坚定了继续用心创作文章的决心。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a><a class="tag-none-link" href="/tags/yymodel/" rel="tag">yymodel</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/yycache/">
      从 YYCache 源码 Get 到如何设计一个优秀的缓存
    </a>
  </h2>
  
  <time>
    10月 30, 2017
  </time>
  <section class="content">
	  <img src="/yycache/how_to_design_a_good_cache.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 开发中总会用到各种缓存，但是各位有没有考虑过什么样的缓存才能被叫做优秀的缓存，或者说优秀的缓存应该具备哪些特质？</p>
<p><strong>闭上眼睛，想一想如果面试官让你设计一个缓存你会怎么回答？</strong></p>
<p>本文将结合 YYCache 的源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 是一个线程安全的高性能键值缓存（该项目是 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit">YYKit</a> 组件之一）。YYKit 是在 2015 年发布到 Github 的，由于其代码质量很高，在短时间内就收获了大量的 Star（目前已经 1w+ Star 了），而且在 iOS 各大社区反响广泛，Google 一下也是漫天赞叹。</p>
<p>YYKit 作者是 <a target="_blank" rel="noopener" href="https://github.com/ibireme">@ibireme</a>，原名郭曜源（猜测 YY 前缀来源于曜源？），是我个人非常喜欢的国人开发者（何止喜欢，简直是迷弟😘）。</p>
<p>YYCache 的代码逻辑清晰，注释详尽，加上自身不算太大的代码量使得其阅读非常简单，更加难能可贵的是它的性能还非常高。</p>
<img src="/yycache/performance_yymemorycache.jpg" class="">
<img src="/yycache/performance_yydiskcache.jpg" class="">
<p>我对它的评价是<strong>小而美</strong>，这种小而美的缓存源码对于我们今天的主题太合适不过了（本文中 YYCache 源码版本为 v1.0.4）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>YYCache 简介</li>
<li>YYMemoryCache 细节剖析</li>
<li>YYDiskCache 细节剖析</li>
<li>优秀的缓存应该具备哪些特质</li>
<li>总结</li>
</ul>
<h2 id="YYCache-简介"><a href="#YYCache-简介" class="headerlink" title="YYCache 简介"></a>YYCache 简介</h2><img src="/yycache/yycache.jpg" class="">
<p>简单把 YYCache 从头到尾撸了一遍，最大的感触就是代码风格干净整洁，代码思路清晰明了。</p>
<p>由于代码整体阅读难度不是非常大，本文不会去逐字逐句的解读源码，而是提炼 YYCache 作为一个小而美的缓存实现了哪些缓存该具备的特质，并且分析实现细节。</p>
<p>我们先来简单看一下 YYCache 的代码结构，YYCache 是由 YYMemoryCache 与 YYDiskCache 两部分组成的，其中 YYMemoryCache 作为高速内存缓存，而 YYDiskCache 则作为低速磁盘缓存。</p>
<blockquote>
<p>通常一个缓存是由内存缓存和磁盘缓存组成，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>上面的代码我做了简化，只保留了最基本的代码（我认为作者在最初设计 YYCache 雏形时很可能也只是提供了这些基本的接口），其他的接口只是通过调用基本的接口再附加对应处理代码而成。</p>
<blockquote>
<p>Note: 其实源码中作者用了一些技巧性的宏，例如 <code>NS_ASSUME_NONNULL_BEGIN</code> 与 <code>NS_ASSUME_NONNULL_END</code> 来通过编译器层检测入参是否为空并给予警告，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a>。</p>
<p>类似上述的编码技巧还有很多，我并非不想与大家分享我 get 到的这些编码技巧，只是觉得它与本文的主题似乎不太相符。我准备在之后专门写一篇文章来与大家分享我在阅读各大源码库过程中 get 到的编码技巧（感兴趣的话可以 <a target="_blank" rel="noopener" href="https://weibo.com/5071795354/profile">关注我</a>）。</p>
</blockquote>
<p>从代码中我们可以看到 YYCache 中持有 YYMemoryCache 与 YYDiskCache，并且对外提供了一些接口。这些接口基本都是基于 Key 和 Value 设计的，类似于 iOS 原生的字典类接口（增删改查）。</p>
<h2 id="YYMemoryCache-细节剖析"><a href="#YYMemoryCache-细节剖析" class="headerlink" title="YYMemoryCache 细节剖析"></a>YYMemoryCache 细节剖析</h2><img src="/yycache/yymemorycache.jpg" class="">
<p>YYMemoryCache 是一个高速的内存缓存，用于存储键值对。它与 NSDictionary 相反，Key 被保留并且不复制。API 和性能类似于 NSCache，所有方法都是线程安全的。</p>
<p>YYMemoryCache 对象与 NSCache 的不同之处在于：</p>
<ul>
<li>YYMemoryCache 使用 LRU(least-recently-used) 算法来驱逐对象；NSCache 的驱逐方式是非确定性的。</li>
<li>YYMemoryCache 提供 age、cost、count 三种方式控制缓存；NSCache 的控制方式是不精确的。</li>
<li>YYMemoryCache 可以配置为在收到内存警告或者 App 进入后台时自动逐出对象。</li>
</ul>
<blockquote>
<p>Note: YYMemoryCache 中的 <code>Access Methods</code> 消耗时长通常是稳定的 <code>(O(1))</code>。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount; <span class="comment">// 缓存对象总数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost; <span class="comment">// 缓存对象总开销</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 5s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning; <span class="comment">// 是否应该在收到内存警告时删除所有缓存内对象</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground; <span class="comment">// 是否应该在 App 进入后台时删除所有缓存内对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到内存警告时自定义处理缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache); <span class="comment">// 我认为这是一个 hook，便于我们在收到 App 进入后台时自定义处理缓存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseOnMainThread; <span class="comment">// 是否在主线程释放对象，默认 NO，有些对象（例如 UIView/CALayer）应该在主线程释放</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> releaseAsynchronously; <span class="comment">// 是否异步释放对象，默认 YES</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>)objectForKey:(<span class="type">id</span>)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="type">id</span>)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count; <span class="comment">// 用 LRU 算法删除对象，直到 totalCount &lt;= count</span></span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost; <span class="comment">// 用 LRU 算法删除对象，直到 totalCost &lt;= cost</span></span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age; <span class="comment">// 用 LRU 算法删除对象，直到所有到期对象全部被删除</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYMemoryCache 的定义代码比较简单~ 该有的注释我已经加到了上面，这里 LRU 算法的实现我准备单独拎出来放到后面和（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）一起讲。我们这里只需要再关注一下 YYMemoryCache 是如何做到线程安全的。</p>
<h3 id="YYMemoryCache-是如何做到线程安全的"><a href="#YYMemoryCache-是如何做到线程安全的" class="headerlink" title="YYMemoryCache 是如何做到线程安全的"></a>YYMemoryCache 是如何做到线程安全的</h3><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYMemoryCache</span> </span>&#123;</span><br><span class="line">    pthread_mutex_t _lock; <span class="comment">// 线程锁，旨在保证 YYMemoryCache 线程安全</span></span><br><span class="line">    _YYLinkedMap *_lru; <span class="comment">// _YYLinkedMap，YYMemoryCache 通过它间接操作缓存对象</span></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> _queue; <span class="comment">// 串行队列，用于 YYMemoryCache 的 trim 操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没错，这里 ibireme 选择使用 <code>pthread_mutex</code> 线程锁来确保 YYMemoryCache 的线程安全。</p>
<blockquote>
<p>有趣的是，这里 ibireme 使用 <code>pthread_mutex</code> 是有一段小故事的。在最初 YYMemoryCache 这里使用的锁是 <code>OSSpinLock</code> 自旋锁（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 备注-关于锁），后面有人在 Github 向作者提 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYModel/issues/43">issue</a> 反馈 <code>OSSpinLock</code> 不安全，经过作者的确认（详见 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a>）最后选择用 <code>pthread_mutex</code> 替代 <code>OSSpinLock</code>。</p>
</blockquote>
<img src="/yycache/lock_benchmark.jpg" class="">
<p>上面是 ibireme 在确认 <code>OSSpinLock</code> 不再安全之后为了寻找替代方案做的简单性能测试，对比了一下几种能够替代 <code>OSSpinLock</code> 锁的性能。在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/">不再安全的 OSSpinLock</a> 文末的评论中，我找到了作者使用 <code>pthread_mutex</code> 的原因。</p>
<blockquote>
<p>ibireme: 苹果员工说 libobjc 里 <code>spinlock</code> 是用了一些私有方法 (<code>mach_thread_switch</code>)，贡献出了高线程的优先来避免优先级反转的问题，但是我翻了下 libdispatch 的源码倒是没发现相关逻辑，也可能是我忽略了什么。在我的一些测试中，<code>OSSpinLock</code> 和 <code>dispatch_semaphore</code> 都不会产生特别明显的死锁，所以我也无法确定用 <code>dispatch_semaphore</code> 代替 <code>OSSpinLock</code> 是否正确。能够肯定的是，用 <code>pthread_mutex</code> 是安全的。</p>
</blockquote>
<h3 id="YYLinkedMapNode-与-YYLinkedMap"><a href="#YYLinkedMapNode-与-YYLinkedMap" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code></h3><p>上文介绍了 YYMemoryCache，其实 YYMemoryCache 并不直接操作缓存对象，而是通过内部的 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 来间接的操作缓存对象。这两个类对于上文中提到的 LRU 缓存算法的理解至关重要，所以我把他们俩单独拎出来放在这里详细解读一下。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 中的一个节点。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// __unsafe_unretained 是为了性能优化，节点被 _YYLinkedMap 的 _dic 强引用</span></span><br><span class="line">    <span class="type">id</span> _key;</span><br><span class="line">    <span class="type">id</span> _value;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost; <span class="comment">// 记录开销，对应 YYMemoryCache 提供的 cost 控制</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time; <span class="comment">// 记录时间，对应 YYMemoryCache 提供的 age 控制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYMemoryCache 内的一个链表。</span></span><br><span class="line"><span class="comment"> _YYLinkedMap 不是一个线程安全的类，而且它也不对参数做校验。</span></span><br><span class="line"><span class="comment"> 通常情况下我们不应该使用这个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// 不要直接设置该对象</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;</span><br><span class="line">    _YYLinkedMapNode *_head; <span class="comment">// MRU, 最常用节点，不要直接修改它</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// LRU, 最少用节点，不要直接修改它</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseOnMainThread; <span class="comment">// 对应 YYMemoryCache 的 releaseOnMainThread</span></span><br><span class="line">    <span class="type">BOOL</span> _releaseAsynchronously; <span class="comment">// 对应 YYMemoryCache 的 releaseAsynchronously</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表操作，看接口名称应该不需要注释吧~</span></span><br><span class="line">- (<span class="type">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line">- (<span class="type">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line">- (<span class="type">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了方便大家阅读，我标注了必要的中文注释。其实对数据结构与算法不陌生的同学应该一眼就看的出来 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 这俩货的本质。没错，丫就是双向链表节点和双向链表。</p>
<p><code>_YYLinkedMapNode</code> 作为双向链表节点，除了基本的 <code>_prev</code>、<code>_next</code>，还有键值缓存基本的 <code>_key</code> 与 <code>_value</code>，<strong>我们可以把 <code>_YYLinkedMapNode</code> 理解为 YYMemoryCache 中的一个缓存对象</strong>。</p>
<p><code>_YYLinkedMap</code> 作为由 <code>_YYLinkedMapNode</code> 节点组成的双向链表，使用 <code>CFMutableDictionaryRef _dic</code> 字典存储 <code>_YYLinkedMapNode</code>。这样在确保 <code>_YYLinkedMapNode</code> 被强引用的同时，能够利用字典的 Hash 快速定位用户要访问的缓存对象，这样既符合了键值缓存的概念又省去了自己实现的麻烦（笑）。</p>
<p>嘛~ 总得来说 YYMemoryCache 是通过使用 <code>_YYLinkedMap</code> 双向链表来操作 <code>_YYLinkedMapNode</code> 缓存对象节点的。</p>
<h3 id="LRU-least-recently-used-算法的实现"><a href="#LRU-least-recently-used-算法的实现" class="headerlink" title="LRU(least-recently-used) 算法的实现"></a>LRU(least-recently-used) 算法的实现</h3><p>上文我们认清了 <code>_YYLinkedMap</code> 与 <code>_YYLinkedMapNode</code> 本质上就是双向链表和链表节点，这里我们简单讲一下 YYMemoryCache 是如何利用双向链表实现 LRU(least-recently-used) 算法的。</p>
<h4 id="缓存替换策略"><a href="#缓存替换策略" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h4><p>首先 LRU 是缓存替换策略（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Cache replacement policies</a>）的一种，还有很多缓存替换策略诸如：</p>
<ul>
<li>First In First Out (FIFO)</li>
<li>Last In First Out (LIFO)</li>
<li>Time aware Least Recently Used (TLRU)</li>
<li>Most Recently Used (MRU)</li>
<li>Pseudo-LRU (PLRU)</li>
<li>Random Replacement (RR)</li>
<li>Segmented LRU (SLRU)</li>
<li>Least-Frequently Used (LFU)</li>
<li>Least Frequent Recently Used (LFRU)</li>
<li>LFU with Dynamic Aging (LFUDA)</li>
<li>Low Inter-reference Recency Set (LIRS)</li>
<li>Adaptive Replacement Cache (ARC)</li>
<li>Clock with Adaptive Replacement (CAR)</li>
<li>Multi Queue (MQ) caching algorithm|Multi Queue (MQ)</li>
<li>Pannier: Container-based caching algorithm for compound objects</li>
</ul>
<p>是不是被唬到了？不要担心，我这里会表述的尽量易懂。</p>
<h4 id="缓存命中率"><a href="#缓存命中率" class="headerlink" title="缓存命中率"></a>缓存命中率</h4><img src="/yycache/cache_hit_ratio.png" class="">
<p>为什么有这么多缓存替换策略，或者说搞这么多名堂究竟是为了什么呢？</p>
<p>答案是提高缓存命中率，那么何谓缓存命中率呢？</p>
<p>Google 一下自然是有不少解释，不过很多都是 web 相关的，而且不说人话（很难理解），我个人非常讨厌各种不说人话的“高深”抽象概念。</p>
<p>这里抖了好几抖胆才敢谈一下我对于缓存命中率的理解（限于 YYCache 和 iOS 开发）。</p>
<ul>
<li>缓存命中 = 用户要访问的缓存对象在高速缓存中，我们直接在高速缓存中通过 Hash 将其找到并返回给用户。</li>
<li>缓存命中率 = 用户要访问的缓存对象在高速缓存中被我们访问到的概率。</li>
</ul>
<p>既然谈到了自己的理解，我索性说个够。</p>
<ul>
<li>缓存丢失 = 由于高速缓存数量有限（占据内存等原因），所以用户要访问的缓存对象很有可能被我们从有限的高速缓存中淘汰掉了，我们可能会将其存储于低速的磁盘缓存中（如果磁盘缓存还有资源的话），那么就要从磁盘缓存中获取该缓存对象以返回给用户，这种情况我理解为（高速）缓存未命中，即缓存丢失（并不是真的被我们丢掉了，但肯定是被我们从高速缓存淘汰掉了）。</li>
</ul>
<p>缓存命中是 cache-hit，那么如果你玩游戏，可以理解为这次 hit miss 了（笑，有人找我开黑吗）。</p>
<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>首先来讲一下 LRU 的概念让大家有一个基本的认识。LRU(least-recently-used) 翻译过来是“最近最少使用”，顾名思义这种缓存替换策略是基于用户最近最少访问过的缓存对象而建立。</p>
<p>我认为 LRU 缓存替换策略的核心思想在于：LRU 认为用户最新使用（访问）过的缓存对象为高频缓存对象，即用户很可能还会再次使用（访问）该缓存对象；而反之，用户很久之前使用（访问）过的缓存对象（期间一直没有再次访问）为低频缓存对象，即用户很可能不会再去使用（访问）该缓存对象，通常在资源不足时会先去释放低频缓存对象。</p>
<h4 id="YYLinkedMapNode-与-YYLinkedMap-实现-LRU"><a href="#YYLinkedMapNode-与-YYLinkedMap-实现-LRU" class="headerlink" title="_YYLinkedMapNode 与 _YYLinkedMap 实现 LRU"></a><code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 实现 LRU</h4><p>YYCache 作者通过 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 双向链表实现 LRU 缓存替换策略的思路其实很简捷清晰，我们一步一步来看。</p>
<p>双向链表中有头结点和尾节点：</p>
<ul>
<li>头结点 = 链表中用户最近一次使用（访问）的缓存对象节点，MRU。</li>
<li>尾节点 = 链表中用户已经很久没有再次使用（访问）的缓存对象节点，LRU。</li>
</ul>
<p>如何让头结点和尾节点指向我们想指向的缓存对象节点？我们结合代码来看：</p>
<ul>
<li>在用户使用（访问）时更新缓存节点信息，并将其移动至双向链表头结点。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">id</span>)objectForKey:(<span class="type">id</span>)key &#123;</span><br><span class="line">    <span class="comment">// 判断入参</span></span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 找到对应缓存节点</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 更新缓存节点时间，并将其移动至双向链表头结点</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 返回找到的缓存节点 value</span></span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在用户设置缓存对象时，判断入参 key 对应的缓存对象节点是否存在？存在则更新缓存对象节点并将节点移动至链表头结点；不存在则根据入参生成新的缓存对象节点并插入链表表头。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setObject:(<span class="type">id</span>)object forKey:(<span class="type">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    <span class="comment">// 判断入参，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="comment">// 判断入参 key 对应的缓存对象节点是否存在</span></span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(key));</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 存在则更新缓存对象节点并将节点移动至链表头结点</span></span><br><span class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class="line">        _lru-&gt;_totalCost += cost;</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在则根据入参生成新的缓存对象节点并插入链表表头</span></span><br><span class="line">        node = [_YYLinkedMapNode new];</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_key = key;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        [_lru insertNodeAtHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断插入、更新节点之后是否超过了限制 cost、count，如果超过则 trim，省略</span></span><br><span class="line">    ...</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在资源不足时，从双线链表的尾节点（LRU）开始清理缓存，释放资源。</li>
</ul>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里拿 count 资源举例，cost、age 自己举一反三</span></span><br><span class="line">- (<span class="type">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    <span class="comment">// 判断 countLimit 为 0，则全部清空缓存，省略</span></span><br><span class="line">    <span class="comment">// 判断 _lru-&gt;_totalCount &lt;= countLimit，没有超出资源限制则不作处理，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class="line">                <span class="comment">// 从双线链表的尾节点（LRU）开始清理缓存，释放资源</span></span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 usleep 以微秒为单位挂起线程，在短时间间隔挂起线程</span></span><br><span class="line">            <span class="comment">// 对比 sleep 用 usleep 能更好的利用 CPU 时间</span></span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否需要在主线程释放，采取释放缓存对象操作</span></span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 是不是感觉敲简单？上面代码去掉了可能会分散大家注意力的代码，我们这里仅仅讨论 LRU 的实现，其余部分的具体实现源码也非常简单，我觉得没必要贴出来单独讲解，感兴趣的同学可以自己去 <a target="_blank" rel="noopener" href="https://github.com/ibireme/YYCache">YYCache</a> 下载源码查阅。</p>
<h4 id="异步释放技巧"><a href="#异步释放技巧" class="headerlink" title="异步释放技巧"></a>异步释放技巧</h4><p>关于上面的异步释放缓存对象的代码，我觉得还是有必要单独拎出来讲一下的：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="comment">// 异步释放，我们单独拎出来讲</span></span><br><span class="line">    [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个技巧 ibireme 在他的另一篇文章 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a> 中有提及：</p>
<blockquote>
<p>Note: 对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。同样的，如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</p>
</blockquote>
<p>而上面代码中的 YYMemoryCacheGetReleaseQueue 这个队列源码为：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内联 dispatch_queue_t</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在源码中可以看到 YYMemoryCacheGetReleaseQueue 是一个低优先级 <code>DISPATCH_QUEUE_PRIORITY_LOW</code> 队列，猜测这样设计的原因是可以让 iOS 在系统相对空闲时再来异步释放缓存对象。</p>
<h2 id="YYDiskCache-细节剖析"><a href="#YYDiskCache-细节剖析" class="headerlink" title="YYDiskCache 细节剖析"></a>YYDiskCache 细节剖析</h2><img src="/yycache/yydiskcache.jpg" class="">
<p>YYDiskCache 是一个线程安全的磁盘缓存，用于存储由 SQLite 和文件系统支持的键值对（类似于 NSURLCache 的磁盘缓存）。</p>
<p>YYDiskCache 具有以下功能：</p>
<ul>
<li>它使用 LRU(least-recently-used) 来删除对象。</li>
<li>支持按 cost，count 和 age 进行控制。</li>
<li>它可以被配置为当没有可用的磁盘空间时自动驱逐缓存对象。</li>
<li>它可以自动抉择每个缓存对象的存储类型（sqlite/file）以便提供更好的性能表现。</li>
</ul>
<blockquote>
<p>Note: 您可以编译最新版本的 sqlite 并忽略 iOS 系统中的 libsqlite3.dylib 来获得 2x〜4x 的速度提升。</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYDiskCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name; <span class="comment">// 缓存名称，默认为 nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path; <span class="comment">// 缓存路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold; <span class="comment">// 阈值，大于阈值则存储类型为 file；否则存储类型为 sqlite</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSData</span> *(^customArchiveBlock)(<span class="type">id</span> object); <span class="comment">// 用来替换 NSKeyedArchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="type">id</span> (^customUnarchiveBlock)(<span class="built_in">NSData</span> *data); <span class="comment">// 用来替换 NSKeyedUnarchiver，你可以使用该代码块以支持没有 conform `NSCoding` 协议的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *(^customFileNameBlock)(<span class="built_in">NSString</span> *key); <span class="comment">// 当一个对象将以 file 的形式保存时，该代码块用来生成指定文件名。如果为 nil，则默认使用 md5(key) 作为文件名</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Limit</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit; <span class="comment">// 缓存对象数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit; <span class="comment">// 缓存开销数量限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit; <span class="comment">// 缓存时间限制，默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> freeDiskSpaceLimit; <span class="comment">// 缓存应该保留的最小可用磁盘空间（以字节为单位），默认无限制，超过限制则会在后台逐出一些对象以满足限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval; <span class="comment">// 缓存自动清理时间间隔，默认 60s</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> errorLogsEnabled; <span class="comment">// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">- (<span class="type">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setObject:(<span class="keyword">nullable</span> <span class="type">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">void</span>)removeAllObjects;</span><br><span class="line">                                 </span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCount;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCost;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Trim</span></span><br><span class="line">- (<span class="type">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="type">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="type">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Extended Data</span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getExtendedDataFromObject:(<span class="type">id</span>)object;</span><br><span class="line">+ (<span class="type">void</span>)setExtendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData toObject:(<span class="type">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>YYDiskCache 结构与 YYMemoryCache 类似，由于很多接口都是基于基本的接口做了扩展所得，这里贴的代码省略了一些接口。代码还是一如既往的干净简洁，相信各位都能看懂。</p>
<p>YYDiskCache 是基于 sqlite 和 file 来做的磁盘缓存，我们的缓存对象可以自由的选择存储类型，下面简单对比一下：</p>
<ul>
<li>sqlite: 对于小数据（例如 NSNumber）的存取效率明显高于 file。</li>
<li>file: 对于较大数据（例如高质量图片）的存取效率优于 sqlite。</li>
</ul>
<p>所以 YYDiskCache 使用两者配合，灵活的存储以提高性能。</p>
<h3 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h3><p>NSMapTable 是类似于字典的集合，但具有更广泛的可用内存语义。NSMapTable 是 iOS6 之后引入的类，它基于 NSDictionary 建模，但是具有以下差异：</p>
<ul>
<li>键/值可以选择 “weakly” 持有，以便于在回收其中一个对象时删除对应条目。</li>
<li>它可以包含任意指针（其内容不被约束为对象）。</li>
<li>您可以将 NSMapTable 实例配置为对任意指针进行操作，而不仅仅是对象。</li>
</ul>
<blockquote>
<p>Note: 配置映射表时，请注意，只有 NSMapTableOptions 中列出的选项才能保证其余的 API 能够正常工作，包括复制，归档和快速枚举。 虽然其他 NSPointerFunctions 选项用于某些配置，例如持有任意指针，但并不是所有选项的组合都有效。使用某些组合，NSMapTableOptions 可能无法正常工作，甚至可能无法正确初始化。</p>
</blockquote>
<p>更多信息详见 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/foundation/nsmaptable?language=objc">NSMapTable 官方文档</a>。</p>
<p>需要特殊说明的是，YYDiskCache 内部是基于一个单例 NSMapTable 管理的，这点有别于 YYMemoryCache。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSMapTable</span> *_globalInstances; <span class="comment">// 引用管理所有的 YYDiskCache 实例</span></span><br><span class="line"><span class="keyword">static</span> dispatch_semaphore_t _globalInstancesLock; <span class="comment">// YYDiskCache 使用 dispatch_semaphore 保障 NSMapTable 线程安全</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheInitGlobal() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _globalInstancesLock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">        _globalInstances = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> YYDiskCache *_YYDiskCacheGetGlobal(<span class="built_in">NSString</span> *path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    <span class="type">id</span> cache = [_globalInstances objectForKey:path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">void</span> _YYDiskCacheSetGlobal(YYDiskCache *cache) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.path.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    _YYDiskCacheInitGlobal();</span><br><span class="line">    dispatch_semaphore_wait(_globalInstancesLock, DISPATCH_TIME_FOREVER);</span><br><span class="line">    [_globalInstances setObject:cache forKey:cache.path];</span><br><span class="line">    dispatch_semaphore_signal(_globalInstancesLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当一个 YYDiskCache 被初始化时，其实会先到 NSMapTable 中获取对应 path 的 YYDiskCache 实例，如果获取不到才会去真正的初始化一个 YYDiskCache 实例，并且将其引用在 NSMapTable 中，这样做也会提升不少性能。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    <span class="comment">// 判断是否可以成功初始化，省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先从 NSMapTable 单例中根据 path 获取 YYDiskCache 实例，如果获取到就直接返回该实例</span></span><br><span class="line">    YYDiskCache *globalCache = _YYDiskCacheGetGlobal(path);</span><br><span class="line">    <span class="keyword">if</span> (globalCache) <span class="keyword">return</span> globalCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 没有获取到则初始化一个 YYDiskCache 实例</span></span><br><span class="line">    <span class="comment">// 要想初始化一个 YYDiskCache 首先要初始化一个 YYKVStorage</span></span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据刚才得到的 kv 和 path 入参初始化一个 YYDiskCache 实例，代码太长省略</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开启递归清理，会根据 _autoTrimInterval 对 YYDiskCache trim</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    <span class="comment">// 向 NSMapTable 单例注册新生成的 YYDiskCache 实例</span></span><br><span class="line">    _YYDiskCacheSetGlobal(<span class="keyword">self</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// App 生命周期通知相关代码，省略</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我在 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中找到了作者使用 dispatch_semaphore 作为 YYDiskCache 锁的原因：</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<h3 id="YYKVStorageItem-与-YYKVStorage"><a href="#YYKVStorageItem-与-YYKVStorage" class="headerlink" title="YYKVStorageItem 与 YYKVStorage"></a>YYKVStorageItem 与 YYKVStorage</h3><p>刚才在 YYDiskCache 的初始化源码中，我们不难发现一个类 YYKVStorage。与 YYMemoryCache 相对应的，YYDiskCache 也不会直接操作缓存对象（sqlite/file），而是通过 YYKVStorage 来间接的操作缓存对象。</p>
<p>从这一点上不难发现，YYKVStorage 等价于 YYMemoryCache 中的双向链表 <code>_YYLinkedMap</code>，而对应于 <code>_YYLinkedMap</code> 中的节点 <code>_YYLinkedMapNode</code>，YYKVStorage 中也有一个类 YYKVStorageItem 充当着与缓存对象一对一的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// YYKVStorageItem 是 YYKVStorage 中用来存储键值对和元数据的类</span></span><br><span class="line"><span class="comment">// 通常情况下，我们不应该直接使用这个类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">///&lt; key</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">///&lt; value</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">///&lt; filename (nil if inline)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> size;                             <span class="comment">///&lt; value&#x27;s size in bytes</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> modTime;                          <span class="comment">///&lt; modification unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span> accessTime;                       <span class="comment">///&lt; last access unix timestamp</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">///&lt; extended data (nil if no extended data)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> YYKVStorage 是基于 sqlite 和文件系统的键值存储。</span></span><br><span class="line"><span class="comment"> 通常情况下，我们不应该直接使用这个类。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @warning </span></span><br><span class="line"><span class="comment">  这个类的实例是 *非* 线程安全的，你需要确保</span></span><br><span class="line"><span class="comment">  只有一个线程可以同时访问该实例。如果你真的</span></span><br><span class="line"><span class="comment">  需要在多线程中处理大量的数据，应该分割数据</span></span><br><span class="line"><span class="comment">  到多个 KVStorage 实例（分片）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorage</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Attribute</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *path;        <span class="comment">/// storage 路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYKVStorageType type;  <span class="comment">/// storage 类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">BOOL</span> errorLogsEnabled;           <span class="comment">/// 是否开启错误日志</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Initializer</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path type:(YYKVStorageType)type <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Save Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Remove Items</span></span><br><span class="line">- (<span class="type">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Items</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - Get Storage Status</span></span><br><span class="line">- (<span class="type">BOOL</span>)itemExistsForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="type">int</span>)getItemsCount;</span><br><span class="line">- (<span class="type">int</span>)getItemsSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>代码美哭了有木有！？这种代码根本不需要翻译，我觉得相比于逐行的翻译，直接看代码更舒服。这里我们只需要看一下 YYKVStorageType 这个枚举，他决定着 YYKVStorage 的存储类型。</p>
<h4 id="YYKVStorageType"><a href="#YYKVStorageType" class="headerlink" title="YYKVStorageType"></a>YYKVStorageType</h4><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 存储类型，指示“YYKVStorageItem.value”存储在哪里。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> @discussion</span></span><br><span class="line"><span class="comment">  通常，将数据写入 sqlite 比外部文件更快，但是</span></span><br><span class="line"><span class="comment">  读取性能取决于数据大小。在我的测试（环境 iPhone 6 64G），</span></span><br><span class="line"><span class="comment">  当数据较大（超过 20KB）时从外部文件读取数据比 sqlite 更快。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class="line">    YYKVStorageTypeFile = <span class="number">0</span>, <span class="comment">// value 以文件的形式存储于文件系统</span></span><br><span class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>, <span class="comment">// value 以二进制形式存储于 sqlite</span></span><br><span class="line">    YYKVStorageTypeMixed = <span class="number">2</span>, <span class="comment">// value 将根据你的选择基于上面两种形式混合存储</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 YYKVStorageType 的注释中标记了作者写 YYCache 时做出的测试结论，大家也可以基于自己的环境去测试验证作者的说法（这一点是可以讨论的，我们可以根据自己的测试来设置 YYDiskCache 中的 inlineThreshold 阈值）。</p>
<blockquote>
<p>如果想要了解更多的信息可以点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/intern-v-extern-blob.html">Internal Versus External BLOBs in SQLite</a> 查阅 SQLite 官方文档。</p>
</blockquote>
<h4 id="YYKVStorage-性能优化细节"><a href="#YYKVStorage-性能优化细节" class="headerlink" title="YYKVStorage 性能优化细节"></a>YYKVStorage 性能优化细节</h4><p>上文说到 YYKVStorage 可以基于 SQLite 和文件系统做磁盘存储，这里再提一些我阅读源码发现到的有趣细节：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">YYKVStorage</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">CFMutableDictionaryRef</span> _dbStmtCache; <span class="comment">// 焦点集中在这里</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>CFMutableDictionaryRef _dbStmtCache;</code> 是 YYKVStorage 中的私有成员，它是一个可变字典充当着 sqlite3_stmt 缓存的角色。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (sqlite3_stmt *)_dbPrepareStmt:(<span class="built_in">NSString</span> *)sql &#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> _dbCheck] || sql.length == <span class="number">0</span> || !_dbStmtCache) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 先尝试从 _dbStmtCache 根据入参 sql 取出已缓存 sqlite3_stmt</span></span><br><span class="line">    sqlite3_stmt *stmt = (sqlite3_stmt *)<span class="built_in">CFDictionaryGetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql));</span><br><span class="line">    <span class="keyword">if</span> (!stmt) &#123;</span><br><span class="line">        <span class="comment">// 如果没有缓存再从新生成一个 sqlite3_stmt</span></span><br><span class="line">        <span class="type">int</span> result = sqlite3_prepare_v2(_db, sql.UTF8String, <span class="number">-1</span>, &amp;stmt, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 生成结果异常则根据错误日志开启标识打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@&quot;%s line:%d sqlite stmt prepare error (%d): %s&quot;</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成成功则放入 _dbStmtCache 缓存</span></span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(_dbStmtCache, (__bridge <span class="keyword">const</span> <span class="type">void</span> *)(sql), stmt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sqlite3_reset(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以省去一些重复生成 sqlite3_stmt 的开销。</p>
<blockquote>
<p>sqlite3_stmt: 该对象的实例表示已经编译成二进制形式并准备执行的单个 SQL 语句。</p>
</blockquote>
<p>更多关于 SQLite 的信息请点击 <a target="_blank" rel="noopener" href="http://www.sqlite.org/docs.html">SQLite 官方文档</a> 查阅。</p>
<h2 id="优秀的缓存应该具备哪些特质"><a href="#优秀的缓存应该具备哪些特质" class="headerlink" title="优秀的缓存应该具备哪些特质"></a>优秀的缓存应该具备哪些特质</h2><img src="/yycache/good_cache.jpg" class="">
<p>嘛~ 我们回到文章最初提到的问题，优秀的缓存应该具备哪些特质？</p>
<p>如果跟着文章一步步读到这里，相信很容易举出以下几点：</p>
<ul>
<li>内存缓存和磁盘缓存</li>
<li>线程安全</li>
<li>缓存控制</li>
<li>缓存替换策略</li>
<li>缓存命中率</li>
<li>性能</li>
</ul>
<p>我们简单的总结一下 YYCache 源码中是如何体现这些特质的。</p>
<h3 id="内存缓存和磁盘缓存"><a href="#内存缓存和磁盘缓存" class="headerlink" title="内存缓存和磁盘缓存"></a>内存缓存和磁盘缓存</h3><p>YYCache 是由内存缓存 YYMemoryCache 与磁盘缓存 YYDiskCache 相互配合组成的，内存缓存提供容量小但高速的存取功能，磁盘缓存提供大容量但低速的持久化存储。这样的设计支持用户在缓存不同对象时都能够有很好的体验。</p>
<p>在 YYCache 中使用接口访问缓存对象时，会先去尝试从内存缓存 YYMemoryCache 中访问，如果访问不到（没有使用该 key 缓存过对象或者该对象已经从容量有限的 YYMemoryCache 中淘汰掉）才会去从 YYDiskCache 访问，如果访问到（表示之前确实使用该 key 缓存过对象，该对象已经从容量有限的 YYMemoryCache 中淘汰掉成立）会先在 YYMemoryCache 中更新一次该缓存对象的访问信息之后才返回给接口。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>如果说 YYCache 这个类是一个纯逻辑层的缓存类（指 YYCache 的接口实现全部是调用其他类完成），那么 YYMemoryCache 与 YYDiskCache 还是做了一些事情的（并没有 YYCache 当甩手掌柜那么轻松），其中最显而易见的就是 YYMemoryCache 与 YYDiskCache 为 YYCache 保证了线程安全。</p>
<p>YYMemoryCache 使用了 <code>pthread_mutex</code> 线程锁来确保线程安全，而 YYDiskCache 则选择了更适合它的 <code>dispatch_semaphore</code>，上文已经给出了作者选择这些锁的原因。</p>
<h3 id="缓存控制"><a href="#缓存控制" class="headerlink" title="缓存控制"></a>缓存控制</h3><p>YYCache 提供了三种控制维度，分别是：cost、count、age。这已经满足了绝大多数开发者的需求，我们在自己设计缓存时也可以根据自己的使用环境提供合适的控制方式。</p>
<h3 id="缓存替换策略-1"><a href="#缓存替换策略-1" class="headerlink" title="缓存替换策略"></a>缓存替换策略</h3><p>在上文解析 YYCache 源码的时候，介绍了缓存替换策略的概念并且列举了很多经典的策略。YYCache 使用了双向链表（<code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code>）实现了 LRU(least-recently-used) 策略，旨在提高 YYCache 的缓存命中率。</p>
<h3 id="缓存命中率-1"><a href="#缓存命中率-1" class="headerlink" title="缓存命中率"></a>缓存命中率</h3><p>这一概念是在上文解析 <code>_YYLinkedMapNode</code> 与 <code>_YYLinkedMap</code> 小节介绍的，我们在自己设计缓存时不一定非要使用 LRU 策略，可以根据我们的实际使用环境选择最适合我们自己的缓存替换策略。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>其实性能这个东西是隐而不见的，又是到处可见的（笑）。它从我们最开始设计一个缓存架构时就被带入，一直到我们具体的实现细节中慢慢成形，最后成为了我们设计出来的缓存优秀与否的决定性因素。</p>
<p>上文中剖析了太多 YYCache 中对于性能提升的实现细节：</p>
<ul>
<li>异步释放缓存对象</li>
<li>锁的选择</li>
<li>使用 NSMapTable 单例管理的 YYDiskCache</li>
<li>YYKVStorage 中的 <code>_dbStmtCache</code></li>
<li>甚至使用 CoreFoundation 来换取微乎其微的性能提升</li>
</ul>
<p>看到这里是不是恍然大悟，性能是怎么来的？就是这样对于每一个细节的极致追求一点一滴积少成多抠出来的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>文章系统的解读了 YYCache 源码，相信可以让各位读者对 YYCache 的整体架构有一个清晰的认识。</li>
<li>文章结合作者 <a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/10/26/yycache/">YYCache 设计思路</a> 中的内容对 YYCache 具体功能点实现源码做了深入剖析，再用我自己的理解表述出来，希望可以对读者理解 YYCache 中具体功能的实现提供帮助。</li>
<li>根据我自己的源码理解，把我认为做的不错的提升性能的源码细节单独拎出来做出详细分析。</li>
<li>总结归纳出“一个优秀缓存需要具备哪些特质？”这一问题的答案，希望大家在面试中如果被问及“如何设计一个缓存”这类问题时可以游刃有余。额，至少可以为大家提供一些回答思路，抛砖引玉（笑）。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/yycache/" rel="tag">yycache</a><a class="tag-none-link" href="/tags/yykit/" rel="tag">yykit</a>
	  </div>
    

  </section>
</article>
  
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
