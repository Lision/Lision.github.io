<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: wwdc | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/tags/wwdc/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	<section class="page-header tag">
    <h1>- <span>wwdc</span> -</h1>
  </section>






<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/wwdc18_llvm/">
      WWDC18 What’s New in LLVM
    </a>
  </h2>
  
  <time>
    6月 24, 2018
  </time>
  <section class="content">
	  <img src="/wwdc18_llvm/wwdc18.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://llvm.org/">LLVM</a> 作为 Apple 御用的编译基础设施其重要性不言而喻，Apple 从未停止对 LLVM 的维护和更新，并且几乎在每年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/wwdc/">WWDC</a> 中都有专门的 Session 来针对 LLVM 的新特性做介绍和讲解，刚刚过去的 WWDC18 也不例外。</p>
<p>WWDC18 Session 409 What’s New in LLVM 中 Apple 的工程师们又为我们介绍了 LLVM 最新的特性，这篇文章将会结合 WWDC18 Session 409 给出的 <a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/409t8zw7rumablsh/409/409_whats_new_in_llvm.pdf?dl=1">官方演示文稿</a> 分享一下 LLVM 的新特性并谈谈笔者自己个人对这些特性的拙见。</p>
<blockquote>
<p>Note: 本文不会对官方演示文稿做逐字逐句的翻译工作，亦不会去过多介绍 LLVM 的基本常识。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>ARC 更新</li>
<li>Xcode 10 新增诊断</li>
<li>Clang 静态分析</li>
<li>增加安全性</li>
<li>新指令集扩展</li>
<li>总结</li>
</ul>
<h2 id="ARC-更新"><a href="#ARC-更新" class="headerlink" title="ARC 更新"></a>ARC 更新</h2><p>本次 ARC 更新的亮点在于 C struct 中允许使用 ARC Objective-C 对象。</p>
<p>在之前版本的 Xcode 中尝试在 C struct 的定义中使用 Obj—C 对象，编译器会抛出 <strong>Error: ARC forbids Objective-C objects in struct</strong>，如下图所示：</p>
<img src="/wwdc18_llvm/arc_00.png" class="">
<p>嘛~ 这是因为之前 LLVM 不支持，如果在 Xcode 10 中书写同样的代码则不会有任何 Warning 与 Error：</p>
<img src="/wwdc18_llvm/arc_01.png" class="">
<p>那么直接在 C struct 中使用 Objective-C 对象的话难道就没有内存上的问题吗？Objective-C 所占用的内存空间是何时被销毁的呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC Object Pointers in C Structs!</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> orderFreeFood(<span class="built_in">NSString</span> *name) &#123;	MenuItem item = &#123;		name,		[<span class="built_in">NSNumber</span> numberWithInt:<span class="number">0</span>]	&#125;;	<span class="comment">// [item.name retain];</span>	<span class="comment">// [item.price retain];</span>	orderMenuItem(item);	<span class="comment">// [item.name release]; </span></span><br><span class="line">	<span class="comment">// [item.price release];</span>&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，编译器会在 C struct <code>MenuItem</code> 创建后 <code>retain</code> 其中的 ARC Objective-C 对象，并在 <code>orderMenuItem(item);</code> 语句之后，即其他使用 <code>MenuItem item</code> 的函数调用结束之后 <code>release</code> 掉相关 ARC Objective-C 对象。</p>
<p>思考，在<strong>动态内存管理</strong>时，ARC Objective-C 对象的内存管理会有什么不同呢？ </p>
<blockquote>
<p>Note: 动态内存管理（Dynamic Memory Management），指非 <code>int a[100];</code> 或 <code>MenuItem item = &#123;name, [NSNumber numberWithInt:0]&#125;;</code> 这种在决定了使用哪一存储结构之后，就自动决定了作用域和存储时期的代码，这种代码必须服从预先制定的内存管理规则。</p>
</blockquote>
<p>我们知道 C 语言中如果想要灵活的创建一个动态大小的数组需要自己手动开辟、管理、释放相关的内存，示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> max;</span><br><span class="line">	<span class="type">double</span> *ptd;</span><br><span class="line">	    </span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;What is the maximum number of type double entries?&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;max);</span><br><span class="line">	ptd = <span class="built_in">malloc</span>(max * <span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line">	<span class="keyword">if</span> (ptd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// memory allocation failed</span></span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// some logic</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">free</span>(ptd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 C struct 中 ARC Objective-C 的动态内存管理是否应该这么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = malloc(<span class="number">10</span> * <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>答案是<strong>否定</strong>的！</p>
<img src="/wwdc18_llvm/arc_02.png" class="">
<p>可以看到通过 <code>malloc</code> 开辟内存初始化带有 ARC Objective-C 的 C struct 中 ARC Objective-C 指针不会 <code>zero-initialized</code>。</p>
<p>嘛~ 这个时候自然而然的会想起使用 <code>calloc</code> ^_^ </p>
<blockquote>
<p>Note: <code>calloc</code> 和 <code>malloc</code> 均可完成内存分配，不同之处在于 <code>calloc</code> 会将分配过来的内存块中全部位置都置 0（然而要注意，在某些硬件系统中，浮点值 0 不是全部位为 0 来表示的）。</p>
</blockquote>
<p>另一个问题就是 <code>free(items);</code> 语句执行之前，ARC Objective-C 并没有被清理。</p>
<p>Emmmmm… 官方推荐的写法是在 <code>free(items);</code> 之前将 <code>items</code> 内的所有 struct 中使用到的 ARC Objective-C 指针手动职位 <code>nil</code> …</p>
<p>所以在<strong>动态内存管理</strong>时，上面的代码应该这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Structs with ARC Fields Need Care for Dynamic Memory Management</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *name;</span><br><span class="line">	<span class="built_in">NSNumber</span> *price;</span><br><span class="line">&#125; MenuItem;</span><br><span class="line"><span class="type">void</span> testMenuItems() &#123;	<span class="comment">// Allocate an array of 10 menu items</span>	MenuItem *items = calloc(<span class="number">10</span>, <span class="keyword">sizeof</span>(MenuItem));	orderMenuItems(items, <span class="number">10</span>);	<span class="comment">// ARC Object Pointer Fields Must be Cleared Before Deallocation</span>	<span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;		items[i].name = <span class="literal">nil</span>;		items[i].price = <span class="literal">nil</span>;	&#125;	free(items);&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间有种<strong>日了狗</strong>的感觉有木有？</p>
<h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 在 C struct 中增加对 ARC Objective-C 对象字段的支持意味着我们<strong>今后 Objective-C 可以构建跨语言模式的交互操作</strong>。</p>
<blockquote>
<p>Note: 官方声明为了统一 ARC 与 manual retain/release (MRR) 下部分 function 按值传递、返回 struct 对 Objective-C++ ABI 做出了些许调整。 </p>
</blockquote>
<p>值得一提的是 Swift <strong>并不支持</strong>这一特性（2333~ 谁说 Objective-C 的更新都是为了迎合 Swift 的变化）。</p>
<h2 id="Xcode-10-新增诊断"><a href="#Xcode-10-新增诊断" class="headerlink" title="Xcode 10 新增诊断"></a>Xcode 10 新增诊断</h2><h3 id="Swift-与-Objective-C-互通性"><a href="#Swift-与-Objective-C-互通性" class="headerlink" title="Swift 与 Objective-C 互通性"></a>Swift 与 Objective-C 互通性</h3><p>我们都知道 Swift 与 Objective-C 具有一定程度的互通性，即 Swift 与 Objective-C 可以混编，在混编时 Xcode 生成一个头文件将 Swift 可以转化为 Objective-C 的部分接口暴露出来。</p>
<p>不过由于 Swift 与 Objective-C 的兼容性导致用 Swift 实现的部分代码无法转换给 Objective-C 使用。</p>
<p>近些年来 LLVM 一致都在尝试让这两种语言可以更好的互通（这也就是上文中提到 Objective-C 的更新都是为了迎合 Swift 说法的由来），本次 LLVM 支持<strong>将 Swift 中的闭包（Closures）导入 Objective-C</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@objc</span> <span class="keyword">protocol</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">	<span class="keyword">func</span> <span class="title function_">performOperation</span>(<span class="params">handler</span>: () -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import “Executor-Swift.h”</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span></span><br><span class="line">- (<span class="type">void</span>)performOperation:(<span class="type">void</span> (^)(<span class="type">void</span>))handler; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 在 Swift 中闭包默认都是非逃逸闭包（non-escaping closures），即闭包不应该在函数返回之后执行。</p>
</blockquote>
<p>Objective-C 中与 Swift 闭包对应的就是 Block 了，但是 Objective-C 中的 Block 并没有诸如 Swift 中逃逸与否的限制，那么我们这样将 Swift 的非逃逸闭包转为 Objective-C 中无限制的 Block 岂不是会有问题？</p>
<img src="/wwdc18_llvm/interoperability.png" class="">
<p>别担心，转换过来的闭包（非逃逸）会有 Warnning 提示，而且我们说过一般这种情况下 Apple 的工程师都会在 LLVM 为 Objective-C 加一个宏来迎合 Swift…</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning for Missing Noescape Annotations for Method Overrides</span><span class="meta">#import “Executor-Swift.h”</span><span class="class"><span class="keyword">@interface</span> <span class="title">DispatchExecutor</span> : <span class="title">NSObject</span>&lt;<span class="title">Executor</span>&gt;</span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler;<span class="keyword">@end</span><span class="class"><span class="keyword">@implementation</span> <span class="title">DispatchExecutor</span></span>- (<span class="type">void</span>)performOperation:(<span class="built_in">NS_NOESCAPE</span> <span class="type">void</span> (^)(<span class="type">void</span>))handler &#123;&#125;</span><br><span class="line"><span class="comment">// Programmer must ensure that handler is not called after performOperation returns</span><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="个人观点-1"><a href="#个人观点-1" class="headerlink" title="个人观点"></a>个人观点</h4><p>如果 Swift 5 真的可以做到 ABI 稳定，那么 Swift 与 Objective-C 混编的 App 包大小也应该回归正常，相信很多公司的项目都会慢慢从 Objective-C 转向 Swift。在 Swift 中闭包（Closures）作为一等公民的存在奠定了 Swift 作为函数式语言的根基，本次 LLVM 提供了将 Swift 中的 Closures 与 Objective-C 中的 Block 互通转换的支持无疑是很有必要的。</p>
<h3 id="使用-pragma-pack-打包-Struct-成员"><a href="#使用-pragma-pack-打包-Struct-成员" class="headerlink" title="使用 #pragma pack 打包 Struct 成员"></a>使用 <code>#pragma pack</code> 打包 Struct 成员</h3><p>Emmmmm… 老实说这一节的内容更底层，所以可能会比较晦涩，希望自己可以表述清楚吧。在 C 语言中 struct 有 <strong>内存布局（memory layout）</strong> 的概念，C 语言允许编译器为每个基本类型指定一些<strong>对齐方式</strong>，通常情况下是以类型的大小为标准对齐，但是它是<strong>特定于实现</strong>的。</p>
<p>嘛~ 还是举个例子吧，就拿 WWDC18 官方演示文稿中的吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Struct</span> &#123;</span> </span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="comment">// 2 byte padding </span></span><br><span class="line">	<span class="type">uint32_t</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上述例子中，编译器为了对齐内存布局不得不在 <code>Struct</code> 的第二字段与第三字段之间插入 2 个 byte。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p><strong>这样本该占用 6 byte 的 struct 就占用了 8 byte，尽管其中只有 6 byte 的数据。</strong></p>
<p>C 语言允许每个远程现代编译器实现 <code>#pragma pack</code>，它允许程序猿对填充进行控制来依从 ABI。</p>
<blockquote>
<p>From C99 §6.7.2.1: </p>
<p>12 Each non-bit-field member of a structure or union object is aligned in an implementation- defined manner appropriate to its type.</p>
<p>13 Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. There may be unnamed padding within a structure object, but not at its beginning.</p>
</blockquote>
<p>实际上关于 <code>#pragma pack</code> 的相关信息可以在 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/preprocessor/pack">MSDN page</a> 中找到。</p>
<p>LLVM 本次也加入了对 <code>#pragma pack</code> 的支持，使用方式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (push, 1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PackedStruct</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> a, b;</span><br><span class="line">	<span class="type">uint32_t</span> c; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack (pop)</span></span><br></pre></td></tr></table></figure>
<p>经过 <code>#pragma pack</code> 之后我们的 struct 对齐方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|   1   |</span><br><span class="line">|   a   | </span><br><span class="line">|   b   |</span><br><span class="line">|  c(1) |</span><br><span class="line">|  c(2) |</span><br><span class="line">|  c(3) |</span><br><span class="line">|  c(4) |</span><br></pre></td></tr></table></figure>
<p>其实 <code>#pragma pack (push, 1)</code> 中的 <code>1</code> 就是对齐字节数，如果设置为 <code>4</code> 那么对齐方式又会变回到最初的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|   1   |   2   |   3   |   4   |</span><br><span class="line">|   a   |   b   | pad.......... |</span><br><span class="line">|  c(1) |  c(2) |  c(3) |  c(4) |</span><br></pre></td></tr></table></figure>
<p>值得一提的是，如果你使用了 <code>#pragma pack (push, n)</code> 之后忘记写 <code>#pragma pack (pop)</code> 的话，Xcode 10 会抛出 warning：</p>
<img src="/wwdc18_llvm/pack.png" class="">
<h4 id="个人观点-2"><a href="#个人观点-2" class="headerlink" title="个人观点"></a>个人观点</h4><p>嘛~ 当在网络层面传输 struct 时，通过 <code>#pragma pack</code> 自定义内存布局的对齐方式可以为用户节约更多流量。</p>
<h2 id="Clang-静态分析"><a href="#Clang-静态分析" class="headerlink" title="Clang 静态分析"></a>Clang 静态分析</h2><p>Xcode 一直都提供静态分析器（Static Analyzer），使用 Clang Static Analyzer 可以帮助我们找出边界情况以及难以发觉的 Bug。</p>
<img src="/wwdc18_llvm/static_analyzer_00.jpg" class="">
<p>点击 Product -&gt; Analyze 或者使用快捷键 Shift+Command+B 就可以静态分析当前构建的项目了，当然也可以在项目的 Build Settings 中设置构建项目时自动执行静态分析（个人不推荐）：</p>
<img src="/wwdc18_llvm/static_analyzer_01.jpg" class="">
<p>本地静态分析器有以下提升：</p>
<ul>
<li>GCD 性能反模式</li>
<li>自动释放变量超出自动释放池</li>
<li>性能和可视化报告的提升</li>
</ul>
<h3 id="GCD-性能反模式"><a href="#GCD-性能反模式" class="headerlink" title="GCD 性能反模式"></a>GCD 性能反模式</h3><p>在之前某些迫不得已的情况下，我们可能需要使用 GCD 信号（<code>dispatch_semaphore_t</code>）来阻塞某些异步操作，并将阻塞后得到的最终的结果同步返回：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task;</span><br><span class="line">	dispatch_semaphore_signal(sema);</span><br><span class="line">&#125;];</span><br><span class="line">dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这样写有什么问题呢？</p>
<p>上述代码存在通过使用异步线程执行任务来阻塞当前线程，而 Task 队列通常优先级较低，所以会导致<strong>优先级反转</strong>。</p>
<p>那么 Xcode 10 之后我们应该怎么写呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="built_in">NSString</span> *taskName = <span class="literal">nil</span>;</span><br><span class="line"><span class="type">id</span> remoteObjectProxy = [<span class="keyword">self</span>.connection synchronousRemoteObjectProxyWithErrorHandler:</span><br><span class="line">	^(<span class="built_in">NSError</span> *error) &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;Error: %@&quot;</span>, error); &#125;];</span><br><span class="line">[remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123;</span><br><span class="line">	taskName = task; </span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">return</span> taskName;</span><br></pre></td></tr></table></figure>
<p>如果可能的话，尽量使用 <code>synchronous</code> 版本的 API。或者，使用 <code>asynchronous</code> 方式的 API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.connection.remoteObjectProxy requestCurrentTaskName:^(<span class="built_in">NSString</span> *task) &#123; </span><br><span class="line">	completionHandler(task);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>可以在 build settings 下启用 GCD 性能反模式的静态分析检查：</p>
<img src="/wwdc18_llvm/static_analyzer_gcd_00.png" class="">
<h3 id="自动释放变量超出自动释放池"><a href="#自动释放变量超出自动释放池" class="headerlink" title="自动释放变量超出自动释放池"></a>自动释放变量超出自动释放池</h3><p>众所周知，使用 <code>__autoreleasing</code> 修饰符修饰的变量会在自动释放池离开时被释放（release）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">	__autoreleasing <span class="built_in">NSError</span> *err = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种看似不需要我们注意的点往往就是引起程序 Crash 的隐患：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123; </span><br><span class="line">			<span class="keyword">if</span> (error) &#123;</span><br><span class="line">				*error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嘛~ 上述代码是会引起 Crash 的，你可以指出为什么吗？</p>
<p>Objective-C 在 ARC（Automatic Reference Counting）下会隐式使用 <code>__autoreleasing</code> 修饰 <code>error</code>，即 <code>NSError *__autoreleasing*</code>。而 <code>-enumerateObjectsUsingBlock:</code> 内部会在迭代 <code>block</code> 时使用 <code>@autoreleasepool</code>，在迭代逻辑中这样做有助于减少内存峰值。</p>
<p>于是 <code>*error</code> 在 <code>-enumerateObjectsUsingBlock:</code> 中被提前 release 掉了，这样在随后读取 <code>*error</code> 时会出现 crash。</p>
<p>Xcode 10 中会给出具有针对性的静态分析警告：</p>
<img src="/wwdc18_llvm/static_analyzer_autoreleasing_00.png" class="">
<p>正确的书写方式应该是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)findProblems:(<span class="built_in">NSArray</span> *)arr error:(<span class="built_in">NSError</span> *__autoreleasing*)error &#123; </span><br><span class="line">	__block <span class="built_in">NSError</span> *localError;</span><br><span class="line">	[arr enumerateObjectsUsingBlock:^(<span class="type">id</span> value, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> *stop) &#123;</span><br><span class="line">		<span class="keyword">if</span> ([value isEqualToString:<span class="string">@&quot;problem&quot;</span>]) &#123;</span><br><span class="line">			localError = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@&quot;domain&quot;</span> code:<span class="number">1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;];</span><br><span class="line">	<span class="keyword">if</span> (error) &#123;</span><br><span class="line">		*error = localError;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 其实早在去年的 <a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2017/411/">WWDC17 Session 411 What’s New in LLVM</a> 中 Xcode 9 就引入了一个需要显示书写 <code>__autoreleasing</code> 的警告。</p>
</blockquote>
<h3 id="性能和可视化报告的提升"><a href="#性能和可视化报告的提升" class="headerlink" title="性能和可视化报告的提升"></a>性能和可视化报告的提升</h3><p>Xcode 10 中静态分析器可以以更高效的方式工作，在相同的分析时间内平均可以发现比之前增加 15% 的 Bug 数量。</p>
<p>不仅仅是性能的提升，Xcode 10 在报告的可视化方面也有所进步。在 Xcode 9 的静态分析器报告页面有着非必要且冗长的 Error Path：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_9.jpg" class="">
<p>Xcode 10 中则对其进行了优化：</p>
<img src="/wwdc18_llvm/static_analyzer_xcode_10.jpg" class="">
<h3 id="个人观点-3"><a href="#个人观点-3" class="headerlink" title="个人观点"></a>个人观点</h3><p>嘛~ 对于 Xcode 的静态分析，个人认为还是聊胜于无的。不过不建议每次构建项目时都去做静态分析，这样大大增加了构建项目的成本。</p>
<p>个人建议在开发流程中自测完毕提交代码给组内小伙伴们 Code Review 之前做静态分析，可以避免一些 issue 的出现，也可以发现一些代码隐患。有些问题是可以使用静态分析器在提交代码之前就暴露出来的，没必要消耗组内 Code Review 的宝贵人力资源。</p>
<p>还可以在 CI 设置每隔固定是时间间隔去跑一次静态分析，生成报表发到组内小群，根据问题指派责任人去检查是否需要修复（静态分析在比较复杂的代码结构下并不一定准确），这样定期维护从某种角度讲可以保持项目代码的健康状况。</p>
<h2 id="增加安全性"><a href="#增加安全性" class="headerlink" title="增加安全性"></a>增加安全性</h2><h3 id="Stack-Protector"><a href="#Stack-Protector" class="headerlink" title="Stack Protector"></a>Stack Protector</h3><p>Apple 工程师在介绍 Stack Protector 之前很贴心的带领着在场的开发者们复习了一遍栈 Stack 相关的基础知识：</p>
<img src="/wwdc18_llvm/stack_protector_00.png" class="">
<p>如上图，其实就是简单的讲了一下 Stack 的工作方式，如栈帧结构以及函数调用时栈的展开等。每一级的方法调用，都对应了一张相关的活动记录，也被称为<strong>活动帧</strong>。函数的调用栈是由一张张帧结构组成的，所以也称之为<strong>栈帧</strong>。</p>
<p>我们可以看到，栈帧中包含着 <strong>Return Address</strong>，也就是当前活动记录执行结束后要返回的地址。</p>
<p>那么会有什么安全性问题呢？Apple 工程师接着介绍了通过不正当手段修改栈帧 Return Address 从而实现的一些权限提升。嘛~ 也就是历史悠久的 <a target="_blank" rel="noopener" href="http://www.cis.syr.edu/~wedu/Teaching/CompSec/LectureNotes_New/Buffer_Overflow.pdf">缓冲区溢出攻击</a>。</p>
<img src="/wwdc18_llvm/stack_protector_01.png" class="">
<p>当使用 C 语言中一些不太安全的函数时（比如上图的 <code>strcpy()</code>），就有可能造成缓冲区溢出。</p>
<blockquote>
<p>Note: <code>strcpy()</code> 函数将源字符串复制到指定缓冲区中。但是丫没有指定要复制字符的具体数目！如果源字符串碰巧来自用户输入，且没有专门限制其大小，则有可能会造成<strong>缓冲区溢出</strong>！</p>
</blockquote>
<p>针对缓冲区溢出攻击，LLVM 引入了一块额外的区域（下图绿色区域）来作为栈帧 Return Address 的<strong>护城河</strong>，叫做 Stack Canary，已默认启用：</p>
<img src="/wwdc18_llvm/stack_protector_02.png" class="">
<blockquote>
<p>Note: Canary 译为 “金丝雀”，Stack Canary 的命名源于早期煤矿工人下矿坑时会携带金丝雀来检测矿坑内一氧化碳是否达到危险值，从而判断是否需要逃生。</p>
</blockquote>
<p>根据我们上面对缓冲区溢出攻击的原理分析，大家应该很容易发现 Stack Canary 的防御原理，即缓冲区溢出攻击旨在利用缓冲区溢出来篡改栈帧的 Return Address，加入了 Stack Canary 之后想要篡改 Return Address 就必然会经过 Stack Canary，在当前栈帧执行结束后要使用 Return Address 回溯时先检测 Stack Canary 是否有变动，如果有就调用 <code>abort()</code> 强制退出。</p>
<p>嘛~ 是不是和矿坑中的金丝雀很像呢？</p>
<p>不过 Stack Canary 存在一些局限性：</p>
<ul>
<li>可以在缓冲区溢出攻击时计算 Canary 的区域并伪装 Canary 区域的值，使得 Return Address 被篡改的同时 Canary 区域内容无变化，绕过检测。</li>
<li>再粗暴一点的话，可以通过双重 <code>strcpy()</code> 覆写任意不受内存保护的数据，通过构建合适的溢出字符串，可以达到修改 ELF（Executable and Linking Format）映射的 GOT（Global Offset Table），只要修改了 GOT 中的 <code>_exit()</code> 入口，即便 Canary 检测到了篡改，函数返回前调用 <code>abort()</code> 退出还是会走已经被篡改了的 <code>_exit()</code>。</li>
</ul>
<h3 id="Stack-Checking"><a href="#Stack-Checking" class="headerlink" title="Stack Checking"></a>Stack Checking</h3><p>Stack Protector 是 Xcode 既有的、且默认开启的特性，而 Stack Checking 是 Xcode 10 引入的新特性，主要针对的是 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">Stack Clash</a> 问题。</p>
<img src="/wwdc18_llvm/stack_checking_00.png" class="">
<p>Stack Clash 问题的产生源于 Stack 和 Heap，Stack 是<strong>从上向下</strong>增长的，Heap 则是<strong>自下而上</strong>增长的，两者相向扩展而内存又是有限的。</p>
<p>Stack Checking 的工作原理是在 Stack 区域规定合理的分界线（上图红线），在可变长度缓冲区的函数内部对将要分配的缓冲区大小做校验，如果缓冲区超出分界线则调用 <code>abort()</code> 强制退出。</p>
<blockquote>
<p>Note: LLVM 团队在本次 WWDC18 加入 Stack Checking，大概率是因为去年年中 <a target="_blank" rel="noopener" href="https://www.qualys.com/">Qualys</a> 公布的一份 <a target="_blank" rel="noopener" href="https://www.qualys.com/2017/06/19/stack-clash/stack-clash.txt">关于 Stack Clash 的报告</a>。</p>
</blockquote>
<h2 id="新指令集扩展"><a href="#新指令集扩展" class="headerlink" title="新指令集扩展"></a>新指令集扩展</h2><img src="/wwdc18_llvm/new_instruction_set_extensions.png" class="">
<p>Emmmmm… 这一节的内容是针对于 iMac Pro 以及 iPhone X 使用的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instruction_set_architecture">指令集架构（ISA - Instruction set architecture）</a> 所做的扩展。坦白说，我对这块并不是很感兴趣，也没有深入的研究，所以就不献丑了…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 WWDC18 Session 409 What’s New in LLVM 中的内容，并分享了我个人对这些内容的拙见，希望能够对各位因为种种原因还没有来得及看 WWDC18 Session 409 的同学有所帮助。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/llvm/" rel="tag">llvm</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/ios-rendering-process/">
      深入理解 iOS Rendering Process
    </a>
  </h2>
  
  <time>
    4月 15, 2018
  </time>
  <section class="content">
	  <img src="/ios-rendering-process/rendering.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS 最早名为 iPhone OS，是 <a target="_blank" rel="noopener" href="https://www.apple.com/">Apple</a> 公司专门为其硬件设备开发的操作系统，最初于 2007 年随第一代 iPhone 推出，后扩展为支持 Apple 公司旗下的其他硬件设备，如 iPod、iPad 等。</p>
<p>作为一名 iOS Developer，相信大多数人都有写出过造成 iOS 设备卡顿的代码经历，相应的也有过想方设法优化卡顿代码的经验。</p>
<p>本文将从 OpenGL 的角度结合 Apple 官方给出的部分资料，介绍 iOS Rendering Process 的概念及其整个底层渲染管道的各个流程。</p>
<p>相信在理解了 iOS Rendering Process 的底层各个阶段之后，我们可以在平日的开发工作之中写出性能更高的代码，在解决帧率不足的显示卡顿问题时也可以多一些思路~</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>iOS Rendering Process 概念</li>
<li>iOS Rendering 技术框架</li>
<li>OpenGL 主要渲染步骤</li>
<li>OpenGL Render Pipeline</li>
<li>Core Animation Pipeline</li>
<li>Commit Transaction</li>
<li>Animation</li>
<li>全文总结</li>
<li>扩展阅读</li>
</ul>
<h2 id="iOS-Rendering-Process-概念"><a href="#iOS-Rendering-Process-概念" class="headerlink" title="iOS Rendering Process 概念"></a>iOS Rendering Process 概念</h2><p>iOS Rendering Process 译为 iOS 渲染流程，本文特指 iOS 设备从设置将要显示的图元数据到最终在设备屏幕成像的整个过程。</p>
<p>在开始剖析 iOS Rendering Process 之前，我们需要对 iOS 的渲染概念有一个基本的认知：</p>
<h3 id="基于平铺的渲染"><a href="#基于平铺的渲染" class="headerlink" title="基于平铺的渲染"></a>基于平铺的渲染</h3><p>iOS 设备的屏幕分为 N * N 像素的图块，每个图块都适合于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/System_on_a_chip">SoC</a> 缓存，几何体在图块内被大量拆分，只有在所有几何体全部提交之后才可以进行光栅化（Rasterization）。</p>
<img src="/ios-rendering-process/tile_based_rendering.jpg" class="">
<blockquote>
<p>Note: 这里的光栅化指将屏幕上面被大量拆分出来的几何体渲染为像素点的过程。</p>
</blockquote>
<img src="/ios-rendering-process/rasterization.jpg" class="">
<h2 id="iOS-Rendering-技术框架"><a href="#iOS-Rendering-技术框架" class="headerlink" title="iOS Rendering 技术框架"></a>iOS Rendering 技术框架</h2><p>事实上 iOS 渲染相关的层级划分大概如下：</p>
<img src="/ios-rendering-process/ios_rendering_framework.png" class="">
<h3 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h3><p>嘛~ 作为一名 iOS Developer 来说，应该对 UIKit 都不陌生，我们日常开发中使用的用户交互组件都来自于 UIKit Framework，我们通过设置 UIKit 组件的 Layout 以及 BackgroundColor 等属性来完成日常的界面绘画工作。</p>
<p>其实 UIKit Framework 自身并不具备在屏幕成像的能力，它主要负责对用户操作事件的响应，事件响应的传递大体是经过逐层的<strong>视图树</strong>遍历实现的。</p>
<blockquote>
<p>那么我们日常写的 UIKit 组件为什么可以呈现在 iOS 设备的屏幕上呢？</p>
</blockquote>
<h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><p>Core Animation 其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做 <strong>Layer Kit</strong> 这么一个不怎么和动画有关的名字演变而来的，所以做动画仅仅是 Core Animation 特性的冰山一角。</p>
<p>Core Animation 本质上可以理解为是一个复合引擎，旨在尽可能快的组合屏幕上不同的显示内容。这些显示内容被分解成独立的图层，即 CALayer，CALayer 才是你所能在屏幕上看见的一切的基础。</p>
<p>其实很多同学都应该知道 CALayer，UIKit 中需要在屏幕呈现的组件内部都有一个对应的 CALayer，也就是所谓的 Backing Layer。正是因为一一对应，所以 CALayer 也是树形结构的，我们称之为<strong>图层树</strong>。</p>
<p>视图的职责就是<strong>创建并管理</strong>这个图层，以确保当子视图在层级关系中<strong>添加或者被移除</strong>的时候，<strong>他们关联的图层</strong>也<strong>同样对应在层级关系树当中有相同的操作</strong>。</p>
<blockquote>
<p>但是为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级关系来处理所有事情呢？</p>
</blockquote>
<p>原因在于要做<strong>职责分离</strong>，这样也能<strong>避免很多重复代码</strong>。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，而 Mac OS X 有 AppKit 和 NSView 的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>
<blockquote>
<p>Note: 实际上，这里并不是两个层级关系，而是<strong>四个</strong>，每一个都扮演不同的角色，除了<strong>视图树</strong>和<strong>图层树</strong>之外，还存在<strong>呈现树</strong>和<strong>渲染树</strong>。</p>
</blockquote>
<h3 id="OpenGL-ES-amp-Core-Graphics"><a href="#OpenGL-ES-amp-Core-Graphics" class="headerlink" title="OpenGL ES &amp; Core Graphics"></a>OpenGL ES &amp; Core Graphics</h3><h4 id="OpenGL-ES"><a href="#OpenGL-ES" class="headerlink" title="OpenGL ES"></a>OpenGL ES</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenGL_ES">OpenGL ES</a> 简称 GLES，即 OpenGL for Embedded Systems，是 OpenGL 的子集，通常面向<strong>图形硬件加速处理单元（GPU）</strong>渲染 2D 和 3D 计算机图形，例如视频游戏使用的计算机图形。</p>
<p>OpenGL ES 专为智能手机，平板电脑，视频游戏机和 PDA 等嵌入式系统而设计 。OpenGL ES 是“历史上应用最广泛的 3D 图形 API”。</p>
<h4 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h4><p><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/coregraphics?language=objc">Core Graphics</a> Framework 基于 Quartz 高级绘图引擎。它提供了具有无与伦比的输出保真度的低级别轻量级 2D 渲染。您可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。</p>
<blockquote>
<p>Note: 在 Mac OS X 中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。</p>
</blockquote>
<h3 id="Graphics-Hardware"><a href="#Graphics-Hardware" class="headerlink" title="Graphics Hardware"></a>Graphics Hardware</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graphics_hardware">Graphics Hardware</a> 译为图形硬件，iOS 设备中也有自己的图形硬件设备，也就是我们经常提及的 GPU。</p>
<p><a href="">图形处理单元（GPU）</a>是一种专用电子电路，旨在快速操作和改变存储器，以加速在用于输出到显示设备的帧缓冲器中创建图像。GPU 被用于嵌入式系统，手机，个人电脑，工作站和游戏控制台。现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在<strong>大块数据并行处理的算法</strong>中比通用 CPU 更有效。</p>
<h2 id="OpenGL-主要渲染步骤"><a href="#OpenGL-主要渲染步骤" class="headerlink" title="OpenGL 主要渲染步骤"></a>OpenGL 主要渲染步骤</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> 全称 Open Graphics Library，译为开放图形库，是用于渲染 2D 和 3D 矢量图形的<strong>跨语言，跨平台</strong>的<strong>应用程序编程接口（API）</strong>。OpenGL 可以直接访问 GPU，以实现硬件加速渲染。</p>
<p>一个用来渲染图像的 OpenGL 程序主要可以大致分为以下几个步骤：</p>
<ul>
<li>设置图元数据</li>
<li>着色器-shader 计算图元数据（位置·颜色·其他）</li>
<li>光栅化-rasterization 渲染为像素</li>
<li>fragment shader，决定最终成像</li>
<li>其他操作（显示·隐藏·融合）</li>
</ul>
<blockquote>
<p>Note: 其实还有一些非必要的步骤，与本文主题不相关，这里点到为止。</p>
</blockquote>
<p>我们日常开发时使用 UIKit 布局视图控件，设置透明度等等都属于<strong>设置图元数据</strong>这步，这也是我们日常开发中可以影响 OpenGL 渲染的主要步骤。</p>
<h2 id="OpenGL-Render-Pipeline"><a href="#OpenGL-Render-Pipeline" class="headerlink" title="OpenGL Render Pipeline"></a>OpenGL Render Pipeline</h2><p>如果有同学看过 WWDC 的一些演讲稿或者接触过一些 OpenGL 知识，应该对 Render Pipeline 这个专业术语并不陌生。</p>
<p>不过 Render Pipeline 实在是一个初次见面不太容易理解的词，它译为<strong>渲染管道</strong>，也有译为渲染管线的…</p>
<p>其实 Render Pipeline 指的是<strong>从应用程序数据转换到最终渲染的图像之间的一系列数据处理过程</strong>。</p>
<p>好比我们上文中提到的 OpenGL 主要渲染步骤一样，我们开发应用程序时在<strong>设置图元数据</strong>这步为视图控件的设定布局，背景颜色，透明度以及阴影等等数据。</p>
<p>下面以 OpenGL 4.5 的 Render Pipeline 为例介绍一下：</p>
<img src="/ios-rendering-process/opengl_rendering_pipeline.png" class="">
<p>这些图元数据流入 OpenGL 中，传入<strong>顶点着色器（vetex shader）</strong>，然后顶点着色器对其进行着色器内部的处理后流出。之后可能进入<strong>细分着色阶段（tessellation shading stage）</strong>，其中又有可能分为细分控制着色器和细分赋值着色器两部分处理，还可能会进入<strong>几何着色阶段（geometry shading stage）</strong>，数据从中传递。最后都会走<strong>片元着色阶段（fragment shading stage）</strong>。</p>
<blockquote>
<p>Note: 图元数据是以 copy 的形式流入 shader 的，shader 一般会以特殊的<strong>类似全局变量的形式</strong>接收数据。</p>
</blockquote>
<p>OpenGL 在最终成像之前还会经历一个阶段名为<strong>计算着色阶段（compute shaing stage）</strong>，这个阶段 OpenGL 会计算最终要在屏幕中成像的像素位置以及颜色，如果在之前提交代码时用到了 CALayer 会引起 <strong>blending</strong> 的显示效果（例如 Shadow）或者视图颜色或内容图片的 alpha 通道开启，都将会加大这个阶段 OpenGL 的工作量。</p>
<h2 id="Core-Animation-Pipeline"><a href="#Core-Animation-Pipeline" class="headerlink" title="Core Animation Pipeline"></a>Core Animation Pipeline</h2><p>上文说到了 iOS 设备之所以可以成像不是因为 UIKit 而是因为 LayerKit，即 Core Animation。</p>
<p>Core Animation 图层，即 CALayer 中包含一个属性 contents，我们可以通过给这个属性赋值来<strong>控制 CALayer 成像的内容</strong>。这个属性的类型定义为 id，在程序编译时不论我们给 contents 赋予任何类型的值，都是可以编译通过的。但实践中，<strong>如果 contents 赋值类型不是 CGImage，那么你将会得到一个空白图层</strong>。</p>
<blockquote>
<p>Note: 造成 contents 属性的奇怪表现的原因是 Mac OS X 的历史包袱，它之所以被定义为 id 类型是因为在 Mac OS X 中这个属性对 CGImage 和 NSImage 类型的值都起作用。但是在 iOS 中，如果你赋予一个 UIImage 属性的值，仅仅会得到一个空白图层。</p>
</blockquote>
<p>说完 Core Animation 的 contents 属性，下面介绍一下 iOS 中 Core Animation Pipeline：</p>
<ul>
<li>在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层</li>
<li>Core Animation 图层相关的数据提交到 iOS Render Server，即 OpenGL ES &amp; Core Graphics</li>
<li>Render Server 将与 GPU 通信把数据经过处理之后传递给 GPU</li>
<li>GPU 调用 iOS 当前设备渲染相关的图形设备 Display</li>
</ul>
<img src="/ios-rendering-process/core_animation_pipeline.png" class="">
<blockquote>
<p>Note: 由于 iOS 设备目前的显示屏最大支持 <strong>60 FPS</strong> 的刷新率，所以每个处理间隔为 16.67 ms。</p>
</blockquote>
<p>可以看到从 Commit Transaction 之后我们的图元数据就将会在下一次 RunLoop 时被 Application 发送给底层的 Render Server，底层 Render Server 直接面向 GPU 经过一系列的数据处理将处理完毕的数据传递给 GPU，然后 GPU 负责渲染工作，根据当前 iOS 设备的屏幕计算图像<strong>像素位置以及像素 alpha 通道混色计算</strong>等等最终在当前 iOS 设备的显示屏中呈现图像。</p>
<blockquote>
<p>嘛~ 由于 Core Animation Pipeline 中 Render Server 包含 OpenGL ES &amp; Core Graphics，其中 OpenGL ES 的渲染可以参考上文 OpenGL Render Pipeline 理解。</p>
</blockquote>
<h2 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h2><p>Core Animation Pipeline 的整个管线中 iOS 常规开发一般可以影响到的范围也就仅仅是在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层这一级，即 <strong>Commit Transaction 之前的一些操作</strong>。</p>
<p>那么在 Commit Transaction 之前我们一般要做的事情有哪些？</p>
<ul>
<li>Layout，构建视图</li>
<li>Display，绘制视图</li>
<li>Prepare，额外的 Core Animation 工作</li>
<li>Commit，打包图层并将它们发送到 Render Server</li>
</ul>
<h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>在 Layout 阶段我们能做的是把 constraint 写的尽量高效，iOS 的 Layout Constraint 类似于 Android 的 Relative Layout。</p>
<blockquote>
<p>Note: Emmmmm… 据观察 iOS 的 Layout Constraint 在书写时应该尽量少的依赖于视图树中同层级的兄弟视图节点，它会拖慢整个视图树的 Layout 计算过程。</p>
</blockquote>
<p><strong>这个阶段的 Layout 计算工作是在 CPU 完成的</strong>，包括 <code>layoutSubviews</code> 方法的重载，<code>addSubview:</code> 方法填充子视图等</p>
<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><p>其实这里的 Display 仅仅是我们设置 iOS 设备要最终成像的图元数据而已，重载视图 <code>drawRect:</code> 方法可以自定义 UIView 的显示，其原理是在 <code>drawRect:</code> 方法内部绘制 bitmap。</p>
<blockquote>
<p>Note: 重载 <code>drawRect:</code> 方法绘制 bitmap 过程<strong>使用 CPU 和 内存</strong>。</p>
</blockquote>
<p>所以重载 <code>drawRect:</code> 使用不当会造成 CPU 负载过重，App 内存飙升等问题。</p>
<h3 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h3><p>这个步骤属于附加步骤，一般处理图像的解码 &amp; 转换等操作。</p>
<h3 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h3><p>Commit 步骤指打包图层并将它们发送到 Render Server。</p>
<blockquote>
<p>Note: Commit 操作会<strong>递归执行</strong>，由于图层和视图一样是以树形结构存在的，当图层树过于复杂时 Commit 操作的开销也会非常大。</p>
</blockquote>
<h4 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h4><p>CATransaction 是 Core Animation 中用于将多个图层树操作分配到渲染树的<strong>原子更新</strong>中的机制，对图层树的每个修改都必须是事务的一部分。</p>
<p>CATransaction 类没有属性或者实例方法，并且也不能用 <code>+alloc</code> 和 <code>-init</code> 方法创建它，我们只能用类方法 <code>+begin</code> 和 <code>+commit</code> 分别来入栈或者出栈。</p>
<p>事实上任何可动画化的图层属性都会被添加到栈顶的事务，你可以通过 <code>+setAnimationDuration:</code> 方法设置当前事务的动画时间，或者通过 <code>+animationDuration</code> 方法来获取时长值（默认 0.25 秒）。</p>
<p>Core Animation 在每个 RunLoop 周期中自动开始一次新的事务，即使你不显式地使用 <code>[CATransaction begin]</code> 开始一次事务，在一个特定 RunLoop 循环中的任何属性的变化都会被收集起来，然后做一次 0.25 秒的动画（CALayer 隐式动画）。</p>
<blockquote>
<p>Note: CATransaction 支持<strong>嵌套</strong>。</p>
</blockquote>
<h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>对于 App 用户交互体验提升最明显的工作莫过于使用动画了，那么 iOS 是如何处理动画的渲染过程的呢？</p>
<p>日常开发中如果不是特别复杂的动画我们一般会使用 UIView Animation 实现，iOS 将 UIView Animation 的处理过程分为以下三个阶段：</p>
<ul>
<li>调用 <code>animateWithDuration:animations:</code> 方法</li>
<li>在 Animation Block 中进行 Layout，Display，Prepare，Commit</li>
<li>Render Server 根据 Animation 逐帧渲染</li>
</ul>
<img src="/ios-rendering-process/animation.png" class="">
<blockquote>
<p>Note: 原理是 <code>animateWithDuration:animations:</code> 内部使用了 CATransaction 来将整个 Animation Block 中的代码作为原子操作 commit 给了 RunLoop。</p>
</blockquote>
<h3 id="基于-CATransaction-实现链式动画"><a href="#基于-CATransaction-实现链式动画" class="headerlink" title="基于 CATransaction 实现链式动画"></a>基于 CATransaction 实现链式动画</h3><p>事实上大多数的动画交互都是有动画执行顺序的，尽管 UIView Animation 很强大，但是在写一些顺序动画时使用 UIView Animation 只能在 <code>+ (void)animateWithDuration:delay:options:animations:completion:</code> 方法的 completion block 中层级嵌套，写成一坨一坨 block 堆砌而成的代码，实在是难以阅读更别提后期维护了。</p>
<p>在得知 UIView Animation 使用了 CATransaction 时，我们不禁会想到这个 completion block 是不是也是基于 CATransaction 实现的呢？</p>
<p>Bingo！CATransaction 中有 <code>+completionBlock</code> 以及 <code>+setCompletionBlock:</code> 方法可以对应于 UIView Animation 的 completion block 的书写。</p>
<blockquote>
<p>Note: 我的一个开源库 <a target="_blank" rel="noopener" href="https://github.com/Lision/LSAnimator"><strong>LSAnimator - 可多链式动画库</strong></a> 在<strong>动画顺序链接时也用到了 CATransaction</strong>。</p>
</blockquote>
<h2 id="全文总结"><a href="#全文总结" class="headerlink" title="全文总结"></a>全文总结</h2><p>结合上下文不难梳理出一个 iOS <strong>最基本的完整渲染经过（Rendering pass）</strong>。</p>
<img src="/ios-rendering-process/rendering_pass.png" class="">
<h3 id="性能检测思路"><a href="#性能检测思路" class="headerlink" title="性能检测思路"></a>性能检测思路</h3><p>基于整篇文章的内容归纳一下我们在日常的开发工作中遇到性能问题时检测问题代码的思路：</p>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">建议</th>
<th style="text-align:center">检测工具</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">目标帧率</td>
<td style="text-align:center">60 FPS</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">CPU or GPU</td>
<td style="text-align:center">降低使用率节约能耗</td>
<td style="text-align:center">Time Profiler instrument</td>
</tr>
<tr>
<td style="text-align:center">不必要的 CPU 渲染</td>
<td style="text-align:center">GPU 渲染更理想，但要清楚 CPU 渲染在何时有意义</td>
<td style="text-align:center">Time Profiler instrument</td>
</tr>
<tr>
<td style="text-align:center">过多的 offscreen passes</td>
<td style="text-align:center">越少越好</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">过多的 blending</td>
<td style="text-align:center">越少越好</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">奇怪的图片格式或大小</td>
<td style="text-align:center">避免实时转换或调整大小</td>
<td style="text-align:center">Core Animation instrument</td>
</tr>
<tr>
<td style="text-align:center">开销昂贵的视图或特效</td>
<td style="text-align:center">理解当前方案的开销成本</td>
<td style="text-align:center">Xcode View Debugger</td>
</tr>
<tr>
<td style="text-align:center">想象不到的层次结构</td>
<td style="text-align:center">了解实际的视图层次结构</td>
<td style="text-align:center">Xcode View Debugger</td>
</tr>
</tbody>
</table>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的个人博客中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="http://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2014/419/">WWDC2014-Advanced Graphics and Animations for iOS Apps</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li>
</ul>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/opengl/" rel="tag">opengl</a><a class="tag-none-link" href="/tags/wwdc/" rel="tag">wwdc</a>
	  </div>
    

  </section>
</article>
  
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
