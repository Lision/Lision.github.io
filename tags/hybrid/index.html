<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: hybrid | 聊宅</title>
  <meta name="description" content="美麗的太陽照常升起 苦痛的人們依舊歇斯底裏" />
  <meta name="keywords" content="ios,objective-c,swift,python,javascript,otaku,lision" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="敲代码的，比较宅的内种">
<meta property="og:type" content="website">
<meta property="og:title" content="聊宅">
<meta property="og:url" content="https://lision.me/tags/hybrid/index.html">
<meta property="og:site_name" content="聊宅">
<meta property="og:description" content="敲代码的，比较宅的内种">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Lision">
<meta property="article:tag" content="ios,objective-c,swift,python,javascript,otaku,lision">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  
<!-- Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=" + "UA-118743071-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-118743071-1');
</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  otaku's self-cultivation
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          首页
        </a>
      
        <a href="/archives" class="nav-archives nav">
          归档
        </a>
      
        <a target="_blank" rel="noopener" href="https://github.com/Lision" class="nav-about nav">
          关于
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      
	<section class="page-header tag">
    <h1>- <span>hybrid</span> -</h1>
  </section>






<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/webview_javascript_bridge/">
      深入剖析 WebViewJavascriptBridge
    </a>
  </h2>
  
  <time>
    12月 23, 2017
  </time>
  <section class="content">
	  <img src="/webview_javascript_bridge/merry_ch.jpg" class="">
<p>Emmmmm…这篇文章发布出来可能正逢圣诞节🎄，Merry Christmas!</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而 JS 和 iOS Native 就好比两块没有交集的大陆，如果想要使它们相互通信就必须要建立一座“桥梁”。</p>
<p><strong>思考一下，如果项目组让你去造这座“桥”，如何才能做到既优雅又实用？</strong></p>
<p>本文将结合 WebViewJavascriptBridge 源码逐步带大家找到答案。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 是盛名已久的 JSBridge 库，早在 2011 年就被作者 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin">Marcus Westin</a> 发布到 GitHub，直到现在作者还在积极维护中，目前该项目已收获近 1w star 咯，其源码非常值得我们学习。</p>
<p>WebViewJavascriptBridge 的代码逻辑清晰，风格良好，加上自身代码量比较小使得其源码阅读非常轻松（可能需要一些 JS 基础）。更加难能可贵的是它仅使用了少量代码就实现了对于 Mac OS X 的 WebView 以及 iOS 平台的 UIWebView 和 WKWebView 三种组件的完美支持。</p>
<p>我对 WebViewJavascriptBridge 的评价是<strong>小而美</strong>，这类小而美的源码非常利于我们对其实现思想的学习（本文分析 WebViewJavascriptBridge 源码版本为 v6.0.3）。</p>
<p>关于 iOS 与 JS 的原生交互知识，之前我有写过一篇文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>，文章除了介绍 JavaScriptCore 库以及 UIWebView 和 WKWebView 与 JS 原生交互的方法之外还捎带提到了 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hybrid">Hybrid</a> 的发展简史，文末还提供了一个 <a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">JS 通过 Native 调用 iOS 设备摄像头的 Demo</a>。</p>
<p>所以这篇文章不会再把重点放在 iOS 与 JS 的原生交互了，本文旨在介绍 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge</a> 的设计思路和实现原理，对 iOS 与 JS 原生交互知识感兴趣的同学推荐去阅读上面提到的文章，应该会有点儿帮助（笑）。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>WebViewJavascriptBridge 简介</li>
<li>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</li>
<li>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</li>
<li>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</li>
<li>WebViewJavascriptBridge 的“桥梁美学”</li>
<li>文章总结</li>
</ul>
<h2 id="WebViewJavascriptBridge-简介"><a href="#WebViewJavascriptBridge-简介" class="headerlink" title="WebViewJavascriptBridge 简介"></a>WebViewJavascriptBridge 简介</h2><img src="/webview_javascript_bridge/bridge.png" class="">
<p>WebViewJavascriptBridge 是用于在 WKWebView，UIWebView 和 WebView 中的 Obj-C 和 JavaScript 之间发送消息的 iOS / OSX 桥接器。</p>
<p>有许多不错的项目都有使用 WebViewJavascriptBridge，这里简单列一部分（笑）：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.messenger.com/">Facebook Messenger</a></li>
<li><a target="_blank" rel="noopener" href="https://www.facebook.com/paper">Facebook Paper</a></li>
<li><a target="_blank" rel="noopener" href="http://www.stayelsewhere.com/">ELSEWHERE</a></li>
<li>… &amp; many more!</li>
</ul>
<p>关于 WebViewJavascriptBridge 的具体使用方法详见其 <a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">GitHub 页面</a>。</p>
<p>在读完 WebViewJavascriptBridge 的源码之后我将其划分为三个层级：</p>
<table>
<thead>
<tr>
<th style="text-align:center">层级</th>
<th style="text-align:center">源文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">接口层</td>
<td style="text-align:center">WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge</td>
</tr>
<tr>
<td style="text-align:center">实现层</td>
<td style="text-align:center">WebViewJavascriptBridgeBase</td>
</tr>
<tr>
<td style="text-align:center">JS 层</td>
<td style="text-align:center">WebViewJavascriptBridge_JS</td>
</tr>
</tbody>
</table>
<p>其中 WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 作为接口层主要负责提供方便的接口，隐藏实现细节，其实现细节都是通过实现层 WebViewJavascriptBridgeBase 去做的，而 WebViewJavascriptBridge_JS 作为 JS 层其实存储了一段 JS 代码，在需要的时候注入到当前 WebView 组件中，最终实现 Native 与 JS 的交互。</p>
<h2 id="WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究"><a href="#WebViewJavascriptBridge-amp-amp-WKWebViewJavascriptBridge-探究" class="headerlink" title="WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究"></a>WebViewJavascriptBridge &amp;&amp; WKWebViewJavascriptBridge 探究</h2><img src="/webview_javascript_bridge/golden_bridge.jpeg" class="">
<p>WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 作为接口层分别对应于 UIWebView 和 WKWebView 组件，我们来简单看一下这两个文件暴露出的信息：</p>
<p>WebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridge</span> : <span class="title">WVJB_WEBVIEW_DELEGATE_INTERFACE</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView; <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler; <span class="comment">// 注册 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 删除 handler (Native)</span></span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback; <span class="comment">// 调用 handler (JS)</span></span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate; <span class="comment">// 设置 webViewDelegate</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 的安全时长来加速消息传递，不推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>WKWebViewJavascriptBridge 暴露信息：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Emmmmm...这里应该不需要我注释了吧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WKWebViewJavascriptBridge</span> : <span class="title">NSObject</span>&lt;<span class="title">WKNavigationDelegate</span>, <span class="title">WebViewJavascriptBridgeBaseDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)bridgeForWebView:(<span class="built_in">WKWebView</span>*)webView;</span><br><span class="line">+ (<span class="type">void</span>)enableLogging;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)registerHandler:(<span class="built_in">NSString</span>*)handlerName handler:(WVJBHandler)handler;</span><br><span class="line">- (<span class="type">void</span>)removeHandler:(<span class="built_in">NSString</span>*)handlerName;</span><br><span class="line">- (<span class="type">void</span>)callHandler:(<span class="built_in">NSString</span>*)handlerName data:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback;</span><br><span class="line">- (<span class="type">void</span>)reset;</span><br><span class="line">- (<span class="type">void</span>)setWebViewDelegate:(<span class="type">id</span>)webViewDelegate;</span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>disableJavscriptAlertBoxSafetyTimeout</code> 方法是通过禁用 JS 端 AlertBox 的安全时长来加速网桥消息传递的。如果想使用那么需要和前端约定好，如果禁用之后前端 JS 代码仍有调用 AlertBox 相关代码（alert, confirm, 或 prompt）则程序将被挂起，所以这个方法是不安全的，如无特殊需求笔者不推荐使用。</p>
</blockquote>
<p>可以看得出来这两个文件暴露出的接口几乎一致，其中 WebViewJavascriptBridge 中使用了宏定义 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 来分别适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件需要实现的代理方法。</p>
<h3 id="WebViewJavascriptBridge-中的宏定义"><a href="#WebViewJavascriptBridge-中的宏定义" class="headerlink" title="WebViewJavascriptBridge 中的宏定义"></a>WebViewJavascriptBridge 中的宏定义</h3><p>其实 WebViewJavascriptBridge 中为了适配 iOS 和 Mac OS X 平台的 UIWebView 和 WebView 组件使用了一系列的宏定义，其源码比较简单：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __MAC_OS_X_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_OSX</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE WebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;WebViewJavascriptBridgeBaseDelegate, WebPolicyDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined __IPHONE_OS_VERSION_MAX_ALLOWED</span></span><br><span class="line">    <span class="meta">#import <span class="string">&lt;UIKit/UIWebView.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_PLATFORM_IOS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_TYPE UIWebView</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_TYPE NSObject<span class="string">&lt;UIWebViewDelegate&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEBVIEW_DELEGATE_INTERFACE NSObject<span class="string">&lt;UIWebViewDelegate, WebViewJavascriptBridgeBaseDelegate&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>分别根据所在平台不同定义了 <code>WVJB_WEBVIEW_TYPE</code>，<code>WVJB_WEBVIEW_DELEGATE_TYPE</code> 以及刚才提到的 <code>WVJB_WEBVIEW_DELEGATE_INTERFACE</code> 宏定义，并且分别定义了 <code>WVJB_PLATFORM_OSX</code> 和 <code>WVJB_PLATFORM_IOS</code> 便于之后的实现源码区分当前平台时使用，下面的 <code>supportsWKWebView</code> 宏定义也是同样的道理：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (__MAC_OS_X_VERSION_MAX_ALLOWED &gt; __MAC_10_9 || __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_7_1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> supportsWKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在引入头文件的时候可以通过这个 <code>supportsWKWebView</code> 宏灵活引入所需的头文件：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;WebKit/WebKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WebViewJavascriptBridge.m</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(supportsWKWebView)</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;WKWebViewJavascriptBridge.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="WebViewJavascriptBridge-的实现分析"><a href="#WebViewJavascriptBridge-的实现分析" class="headerlink" title="WebViewJavascriptBridge 的实现分析"></a>WebViewJavascriptBridge 的实现分析</h3><p>我们接着看一下 WebViewJavascriptBridge 的实现部分，首先从内部变量信息看起：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> __has_feature(objc_arc_weak)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __weak</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> WVJB_WEAK __unsafe_unretained</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    WVJB_WEAK WVJB_WEBVIEW_TYPE* _webView; <span class="comment">// bridge 对应的 WebView 组件</span></span><br><span class="line">    WVJB_WEAK <span class="type">id</span> _webViewDelegate; <span class="comment">// 给 WebView 组件设置的代理（需要的话）</span></span><br><span class="line">    <span class="type">long</span> _uniqueId; <span class="comment">// 唯一标识，Emmmmm...但是我发现没卵用，只有 _base 中的 _uniqueId 才有用</span></span><br><span class="line">    WebViewJavascriptBridgeBase *_base; <span class="comment">// 上文说过，底层实现其实都是 WebViewJavascriptBridgeBase 在做</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文提到 WebViewJavascriptBridge 和 WKWebViewJavascriptBridge 的 .h 文件暴露接口信息非常相似，那么我们要不要看看 WKWebViewJavascriptBridge 的内部变量信息呢？</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释参见 WebViewJavascriptBridge 就好</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WKWebViewJavascriptBridge</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="built_in">WKWebView</span>* _webView;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="type">id</span>&lt;<span class="built_in">WKNavigationDelegate</span>&gt; _webViewDelegate;</span><br><span class="line">    <span class="type">long</span> _uniqueId;</span><br><span class="line">    WebViewJavascriptBridgeBase *_base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ 这俩货简直是一个妈生的。其实这是作者故意为之，因为作者想对外提供一套接口，即 WebViewJavascriptBridge，我们只需要使用 WebViewJavascriptBridge 就可以自动根据绑定的 WebView 组件的不同生成与之对应的 JSBridge 实例。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)bridge:(<span class="type">id</span>)webView &#123;</span><br><span class="line"><span class="comment">// 如果支持 WKWebView</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined supportsWKWebView</span></span><br><span class="line">    <span class="comment">// 需要先判断当前入参 webView 是否从属于 WKWebView</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[<span class="built_in">WKWebView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WKWebViewJavascriptBridge 实例</span></span><br><span class="line">        <span class="keyword">return</span> (WebViewJavascriptBridge*) [<span class="built_in">WKWebViewJavascriptBridge</span> bridgeForWebView:webView];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 判断当前入参 webView 是否从属于 WebView（Mac OS X）或者 UIWebView（iOS）</span></span><br><span class="line">    <span class="keyword">if</span> ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// 返回 WebViewJavascriptBridge 实例</span></span><br><span class="line">        WebViewJavascriptBridge* bridge = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">        [bridge _platformSpecificSetup:webView];</span><br><span class="line">        <span class="keyword">return</span> bridge;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 抛出 BadWebViewType 异常并返回 nil</span></span><br><span class="line">    [<span class="built_in">NSException</span> raise:<span class="string">@&quot;BadWebViewType&quot;</span> format:<span class="string">@&quot;Unknown web view type.&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的代码，实现并不复杂。如果支持 WKWebView 的话（<code>#if defined supportsWKWebView</code>）则去判断当前绑定的 WebView 组件是否从属于 WKWebView，这样可以返回 WKWebViewJavascriptBridge 实例，否则返回 WebViewJavascriptBridge 实例，最后如果入参 <code>webView</code> 的类型不满足判断条件则抛出 <code>BadWebViewType</code> 异常。</p>
<p>还有一个关于 <code>_webViewDelegate</code> 的小细节，本来不打算讲的，但是还是提一下吧（囧）。其实在 WebViewJavascriptBridge 以及 WKWebViewJavascriptBridge 的初始化实现过程中，会把当前 WebView 组件的代理绑定为自己：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _platformSpecificSetup:(WVJB_WEBVIEW_TYPE*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WKWebViewJavascriptBridge</span></span><br><span class="line">- (<span class="type">void</span>) _setupInstance:(<span class="built_in">WKWebView</span>*)webView &#123;</span><br><span class="line">    _webView = webView;</span><br><span class="line">    _webView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    _base = [[WebViewJavascriptBridgeBase alloc] init];</span><br><span class="line">    _base.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 替换组件的代理将其代理绑定为 bridge 自己是因为 WebViewJavascriptBridge 的实现原理上是利用我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，所以需要监听 WebView 组件的代理方法获取加载之前的 Request.URL 并做处理。这也是为什么 WebViewJavascriptBridge 提供了一个接口 <code>setWebViewDelegate:</code> 存储了一个逻辑上的 <code>_webViewDelegate</code>，这个 <code>_webViewDelegate</code> 也需要遵循 WebView 组件的代理协议，这样在 WebViewJavascriptBridge 内部不同的代理方法中做完 bridge 要做的事情只有就会再去调用 <code>_webViewDelegate</code> 对应的代理方法，其实可以理解为 WebViewJavascriptBridge 对当前 WebView 组件的代理做了 hook。</p>
</blockquote>
<p>对于 WebViewJavascriptBridge 中暴露的初始化以外的所有接口，其内部实现都是通过 WebViewJavascriptBridgeBase 来实现的。这样做的好处就是<strong>即使 WebViewJavascriptBridge 因为绑定了 WKWebView 返回了 WKWebViewJavascriptBridge 实例，只要接口一致，对 JSBridge 发送相同的消息，就会有相同的实现（都是由 WebViewJavascriptBridgeBase 类实现的）</strong>。</p>
<h2 id="WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析"><a href="#WebViewJavascriptBridgeBase-JS-调用-Native-实现原理剖析" class="headerlink" title="WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析"></a>WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析</h2><img src="/webview_javascript_bridge/pier.jpg" class="">
<p>作为 WebViewJavascriptBridge 的实现层，WebViewJavascriptBridgeBase 的命名也可以体现出其是作为整座“桥梁”桥墩一般的存在，我们还是按照老规矩先看一下 WebViewJavascriptBridgeBase.h 暴露的信息，好对其有一个整体的印象：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBResponseCallback)(<span class="type">id</span> responseData); <span class="comment">// 回调 block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^WVJBHandler)(<span class="type">id</span> data, WVJBResponseCallback responseCallback); <span class="comment">// 注册的 Handler block</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span> WVJBMessage; <span class="comment">// 消息类型 - 字典</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">WebViewJavascriptBridgeBaseDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line">- (<span class="built_in">NSString</span>*) _evaluateJavascript:(<span class="built_in">NSString</span>*)javascriptCommand;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebViewJavascriptBridgeBase</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="type">id</span> &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate; <span class="comment">// 代理，指向接口层类，用以给对应接口绑定的 WebView 组件发送执行 JS 消息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableArray</span>* startupMessageQueue; <span class="comment">// 启动消息队列，可以理解为存放 WVJBMessage</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* responseCallbacks; <span class="comment">// 回调 blocks 字典，存放 WVJBResponseCallback 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSMutableDictionary</span>* messageHandlers; <span class="comment">// 已注册的 handlers 字典，存放 WVJBHandler 类型的 block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) WVJBHandler messageHandler; <span class="comment">// 没卵用</span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)enableLogging; <span class="comment">// 开启日志</span></span><br><span class="line">+ (<span class="type">void</span>)setLogMaxLength:(<span class="type">int</span>)length; <span class="comment">// 设置日志最大长度</span></span><br><span class="line">- (<span class="type">void</span>)reset; <span class="comment">// 对应 WKJSBridge 的 reset 接口</span></span><br><span class="line">- (<span class="type">void</span>)sendData:(<span class="type">id</span>)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(<span class="built_in">NSString</span>*)handlerName; <span class="comment">// 发送消息，入参依次是参数，回调 block，对应 JS 端注册的 HandlerName</span></span><br><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString; <span class="comment">// 刷新消息队列，核心代码</span></span><br><span class="line">- (<span class="type">void</span>)injectJavascriptFile; <span class="comment">// 注入 JS</span></span><br><span class="line">- (<span class="type">BOOL</span>)isWebViewJavascriptBridgeURL:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 判定是否为 WebViewJavascriptBridgeURL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isQueueMessageURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为队列消息 URL</span></span><br><span class="line">- (<span class="type">BOOL</span>)isBridgeLoadedURL:(<span class="built_in">NSURL</span>*)urll; <span class="comment">// 判定是否为 bridge 载入 URL</span></span><br><span class="line">- (<span class="type">void</span>)logUnkownMessage:(<span class="built_in">NSURL</span>*)url; <span class="comment">// 打印收到未知消息信息</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptCheckCommand; <span class="comment">// JS bridge 检测命令</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand; <span class="comment">// JS bridge 获取查询命令</span></span><br><span class="line">- (<span class="type">void</span>)disableJavscriptAlertBoxSafetyTimeout; <span class="comment">// 禁用 JS AlertBox 安全时长以获取发送消息速度提升，不建议使用，理由见上文</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>嘛~ 从 .h 文件中我们可以看到整个 WebViewJavascriptBridgeBase 所暴露出来的信息，属性层面上需要对以下 4 个属性加深印象，之后分析实现的过程中会带入这些属性：</p>
<ul>
<li><code>id &lt;WebViewJavascriptBridgeBaseDelegate&gt; delegate</code> 代理，可以通过代理让当前 bridge 绑定的 WebView 组件执行 JS 代码</li>
<li><code>NSMutableArray* startupMessageQueue;</code> 启动消息队列，存放 Obj-C 发送给 JS 的消息（可以理解为存放 <code>WVJBMessage</code> 类型）</li>
<li><code>NSMutableDictionary* responseCallbacks;</code> 回调 blocks 字典，存放 <code>WVJBResponseCallback</code> 类型的 block</li>
<li><code>NSMutableDictionary* messageHandlers;</code> Obj-C 端已注册的 handlers 字典，存放 <code>WVJBHandler</code> 类型的 block</li>
</ul>
<p>Emmmmm…接口层面看一下注释就好了，后面分析实现的时候会捎带讲解一些接口，剩下一些跟实现无关的接口内容感兴趣的同学推荐自己扒源码哈。</p>
<p>我们在对 WebViewJavascriptBridgeBase 整体有了一个初始印象之后就可以自己写一个页面，简单的嵌入一些 JS 跑一遍流程，在中间下断点扒源码，这样我们对于 Native 与 JS 的交互流程就可以一清二楚了。</p>
<p><strong>下面模拟一遍 JS 通过 WebViewJavascriptBridge 调用 Native 功能的流程分析 WebViewJavascriptBridgeBase 的相关实现</strong>（考虑现在的时间点决定以 WKWebView 为例讲解，即针对 WKWebViewJavascriptBridge 源码讲解）：</p>
<h3 id="1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码"><a href="#1-监听假-Request-并注入-WebViewJavascriptBridge-JS-内的-JS-代码" class="headerlink" title="1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码"></a>1.监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码</h3><p>上文说到 WebViewJavascriptBridge 的实现其实本质上是利用了我之前的文章<a href="https://lision.me/ios-native-js/">《iOS 与 JS 交互开发知识总结》</a>中讲过的假 Request 方法实现的，那么我们就从监听假 Request 开始讲起吧。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKNavigationDelegate 协议方法，用于监听 Request 并决定是否允许导航</span></span><br><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="comment">// webView 校验</span></span><br><span class="line">    <span class="keyword">if</span> (webView != _webView) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_webViewDelegate) strongDelegate = _webViewDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">if</span> ([_base isWebViewJavascriptBridgeURL:url]) &#123; <span class="comment">// 判定 WebViewJavascriptBridgeURL</span></span><br><span class="line">        <span class="keyword">if</span> ([_base isBridgeLoadedURL:url]) &#123; <span class="comment">// 判定 BridgeLoadedURL</span></span><br><span class="line">            <span class="comment">// 注入 JS 代码</span></span><br><span class="line">            [_base injectJavascriptFile];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([_base isQueueMessageURL:url]) &#123; <span class="comment">// 判定 QueueMessageURL</span></span><br><span class="line">            <span class="comment">// 刷新消息队列</span></span><br><span class="line">            [<span class="keyword">self</span> <span class="built_in">WKFlushMessageQueue</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 记录未知 bridge msg 日志</span></span><br><span class="line">            [_base logUnkownMessage:url];</span><br><span class="line">        &#125;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 _webViewDelegate 对应的代理方法</span></span><br><span class="line">    <span class="keyword">if</span> (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:<span class="keyword">@selector</span>(webView:decidePolicyForNavigationAction:decisionHandler:)]) &#123;</span><br><span class="line">        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 之前说过 WebViewJavascriptBridge 会 hook 绑定的 WebView 的代理方法，这一点 WKWebViewJavascriptBridge 也一样，在加入自己的代码之后会判断是否有 <code>_webViewDelegate</code> 响应这个代理方法，如果有则调用。</p>
</blockquote>
<p>我们还是把注意力放到注释中核心代码的位置，里面会先判断当前 url 是否为 bridge url：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kOldProtocolScheme @<span class="string">&quot;wvjbscheme&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kNewProtocolScheme @<span class="string">&quot;https&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kQueueHasMessage   @<span class="string">&quot;__wvjb_queue_message__&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> kBridgeLoaded      @<span class="string">&quot;__bridge_loaded__&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 的使用方法中第 4 步明确指出要复制粘贴 <code>setupWebViewJavascriptBridge</code> 方法到前段 JS 中，我们先来看一下这段 JS 方法源码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setupWebViewJavascriptBridge</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123; <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="title class_">WebViewJavascriptBridge</span>); &#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>) &#123; <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>.<span class="title function_">push</span>(callback); &#125;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span> = [callback];</span><br><span class="line">	<span class="comment">// 创建一个 iframe</span></span><br><span class="line">	<span class="keyword">var</span> <span class="title class_">WVJBIframe</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	<span class="comment">// 设置 iframe 为不显示</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 的 src 置为 &#x27;https://__bridge_loaded__&#x27;</span></span><br><span class="line">	<span class="title class_">WVJBIframe</span>.<span class="property">src</span> = <span class="string">&#x27;https://__bridge_loaded__&#x27;</span>;</span><br><span class="line">	<span class="comment">// 将 iframe 加入到 document.documentElement</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(<span class="title class_">WVJBIframe</span>);</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">removeChild</span>(<span class="title class_">WVJBIframe</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了一个不显示的 iframe 并将其 src 置为 <code>https://__bridge_loaded__</code>，与上文中 <code>kBridgeLoaded</code> 宏定义一致，即用于 <code>isBridgeLoadedURL:</code> 方法中判定当前 url 是否为 BridgeLoadedURL。</p>
<blockquote>
<p>Note: 假 Request 的发起有两种方式，-1:<code>location.href</code> -2:<code>iframe</code>。通过 <code>location.href</code> 有个问题，就是如果 JS 多次调用原生的方法也就是 <code>location.href</code> 的值多次变化，Native 端只能接受到最后一次请求，前面的请求会被忽略掉，所以这里 WebViewJavascriptBridge 选择使用 iframe，后面不再解释。</p>
</blockquote>
<p>因为加入了 src 为 <code>https://__bridge_loaded__</code> 的 iframe 元素，我们上面截获 url 的代理方法就会拿到一个 <code>https://__bridge_loaded__</code> 的 url，由于 https 满足判定 WebViewJavascriptBridgeURL，将会进入核心代码区域接着会被判定为 BridgeLoadedURL 执行注入 JS 代码的方法，即 <code>[_base injectJavascriptFile];</code>。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)injectJavascriptFile &#123;</span><br><span class="line">    <span class="comment">// 获取到 WebViewJavascriptBridge_JS 的代码</span></span><br><span class="line">    <span class="built_in">NSString</span> *js = WebViewJavascriptBridge_js();</span><br><span class="line">    <span class="comment">// 将获取到的 js 通过代理方法注入到当前绑定的 WebView 组件</span></span><br><span class="line">    [<span class="keyword">self</span> _evaluateJavascript:js];</span><br><span class="line">    <span class="comment">// 如果当前已有消息队列则遍历并分发消息，之后清空消息队列</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.startupMessageQueue) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>* queue = <span class="keyword">self</span>.startupMessageQueue;</span><br><span class="line">        <span class="keyword">self</span>.startupMessageQueue = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">id</span> queuedMessage <span class="keyword">in</span> queue) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _dispatchMessage:queuedMessage];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，第一步交互已完成。关于 WebViewJavascriptBridge_JS 内部的 JS 代码我们放到后面的章节解读，现在可以简单理解为 WebViewJavascriptBridge 在 JS 端的具体实现代码。</p>
<h3 id="2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？"><a href="#2-JS-端调用-callHandler-方法之后-Native-端究竟是如何响应的？" class="headerlink" title="2.JS 端调用 callHandler 方法之后 Native 端究竟是如何响应的？"></a>2.JS 端调用 <code>callHandler</code> 方法之后 Native 端究竟是如何响应的？</h3><p><a target="_blank" rel="noopener" href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavascriptBridge GitHub 页面</a> 中指出 JS 端的操作方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setupWebViewJavascriptBridge</span>(<span class="keyword">function</span>(<span class="params">bridge</span>) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Initialize your app here */</span></span><br><span class="line"></span><br><span class="line">	bridge.<span class="title function_">registerHandler</span>(<span class="string">&#x27;JS Echo&#x27;</span>, <span class="keyword">function</span>(<span class="params">data, responseCallback</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS Echo called with:&quot;</span>, data)</span><br><span class="line">		<span class="title function_">responseCallback</span>(data)</span><br><span class="line">	&#125;)</span><br><span class="line">	bridge.<span class="title function_">callHandler</span>(<span class="string">&#x27;ObjC Echo&#x27;</span>, &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;, <span class="keyword">function</span> <span class="title function_">responseCallback</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;JS received response:&quot;</span>, responseData)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们知道 JS 端调用 <code>setupWebViewJavascriptBridge</code> 方法会走我们刚才分析过的第一步，即监听假 Request 并注入 WebViewJavascriptBridge_JS 内的 JS 代码。那么当 JS 端调用 <code>bridge.callHandler</code> 时，Native 端究竟是如何做出响应的呢？这里我们需要先稍微解读一下之前注入的 WebViewJavascriptBridge_JS 中的 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		responseCallback = data;</span><br><span class="line">		data = <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line"><span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">		responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">		message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">	&#125;</span><br><span class="line">	sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到 JS 端的代码中有 <code>callHandler</code> 函数的实现，其内部将入参 <code>handlerName</code> 以及 <code>data</code> 以字典形式作为参数调用 <code>_doSend</code> 方法，我们看一下 <code>_doSend</code> 方法的实现：</p>
<ul>
<li><code>_doSend</code> 方法内部会先判断入参中是否有回调</li>
<li>如果有回调则根据规则生成 <code>callbackId</code> 并且将回调 block 保存到 <code>responseCallbacks</code> 字典（囧~ JS 不叫字典的，我是为了 iOS 读者看着方便），之后给消息也加入一个键值对保存刚才生成的 <code>callbackId</code></li>
<li>之后给 <code>sendMessageQueue</code> 队列加入 <code>message</code></li>
<li>将 <code>messagingIframe.src</code> 设置为 <code>https://__wvjb_queue_message__</code></li>
</ul>
<p>好，点到为止，对于 WebViewJavascriptBridge_JS 内的 JS 端其他源码我们放着后面看。注意这里加入了一个 src 为 <code>https://__wvjb_queue_message__</code> 的 <code>messagingIframe</code>，它也是一个不可见的 iframe。这样 Native 端会收到一个 url 为 <code>https://__wvjb_queue_message__</code> 的 request，回到第 1 步中获取到假的 request 之后会进行各项判定，这次会满足 <code>[_base isQueueMessageURL:url]</code> 的判定调用 Native 的 <code>WKFlushMessageQueue</code> 方法。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)<span class="built_in">WKFlushMessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 WebViewJavascriptBridge._fetchQueue(); 方法</span></span><br><span class="line">    [_webView evaluateJavaScript:[_base webViewJavascriptFetchQueyCommand] completionHandler:^(<span class="built_in">NSString</span>* result, <span class="built_in">NSError</span>* error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 刷新消息列表</span></span><br><span class="line">        [_base flushMessageQueue:result];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)webViewJavascriptFetchQueyCommand &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;WebViewJavascriptBridge._fetchQueue();&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 Native 端会在刷新队列中调用 JS 端的 <code>WebViewJavascriptBridge._fetchQueue();</code> 方法，我们来看一下 JS 端此方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// 将 sendMessageQueue 转为 JSON 格式</span></span><br><span class="line">	<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">	<span class="comment">// 重置 sendMessageQueue</span></span><br><span class="line">	sendMessageQueue = [];</span><br><span class="line">	<span class="comment">// 返回 JSON 格式的 </span></span><br><span class="line">	<span class="keyword">return</span> messageQueueString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会把当前 JS 端 <code>sendMessageQueue</code> 消息队列以 JSON 的形式返回，而 Native 端会调用 <code>[_base flushMessageQueue:result];</code> 将拿到的 JSON 形式消息队列作为参数调用 <code>flushMessageQueue:</code> 方法，这个方法是整个框架 Native 端的精华所在，就是稍微有点长（笑）。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)flushMessageQueue:(<span class="built_in">NSString</span> *)messageQueueString &#123;</span><br><span class="line">    <span class="comment">// 校验 messageQueueString</span></span><br><span class="line">    <span class="keyword">if</span> (messageQueueString == <span class="literal">nil</span> || messageQueueString.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 messageQueueString 通过 NSJSONSerialization 解为 messages 并遍历</span></span><br><span class="line">    <span class="type">id</span> messages = [<span class="keyword">self</span> _deserializeMessageJSON:messageQueueString];</span><br><span class="line">    <span class="keyword">for</span> (WVJBMessage* message <span class="keyword">in</span> messages) &#123;</span><br><span class="line">        <span class="comment">// 类型校验</span></span><br><span class="line">        <span class="keyword">if</span> (![message isKindOfClass:[WVJBMessage <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;</span>, [message <span class="keyword">class</span>], message);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> _log:<span class="string">@&quot;RCVD&quot;</span> json:message];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试取 responseId，如取到则表明是回调，从 _responseCallbacks 取匹配的回调 block 执行</span></span><br><span class="line">        <span class="built_in">NSString</span>* responseId = message[<span class="string">@&quot;responseId&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (responseId) &#123; <span class="comment">// 取到 responseId</span></span><br><span class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</span><br><span class="line">            responseCallback(message[<span class="string">@&quot;responseData&quot;</span>]);</span><br><span class="line">            [<span class="keyword">self</span>.responseCallbacks removeObjectForKey:responseId];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 responseId，则表明是正常的 JS callHandler 调用 iOS</span></span><br><span class="line">            WVJBResponseCallback responseCallback = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 尝试取 callbackId，示例 cb_1_1512035076293</span></span><br><span class="line">            <span class="comment">// 对应 JS 代码 var callbackId = &#x27;cb_&#x27;+(uniqueId++)+&#x27;_&#x27;+new Date().getTime();</span></span><br><span class="line">            <span class="built_in">NSString</span>* callbackId = message[<span class="string">@&quot;callbackId&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span> (callbackId) &#123; <span class="comment">// 取到 callbackId，表示 js 端希望在调用 iOS native 代码后有回调</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> responseData) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (responseData == <span class="literal">nil</span>) &#123;</span><br><span class="line">                        responseData = [<span class="built_in">NSNull</span> null];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 将 callbackId 作为 msg 的 responseId 并设置 responseData，执行 _queueMessage</span></span><br><span class="line">                    WVJBMessage* msg = @&#123; <span class="string">@&quot;responseId&quot;</span>:callbackId, <span class="string">@&quot;responseData&quot;</span>:responseData &#125;;</span><br><span class="line">                    <span class="comment">// _queueMessage 函数主要是把 msg 转为 JSON 格式，内含 responseId = callbackId</span></span><br><span class="line">                    <span class="comment">// JS 端调用 WebViewJavascriptBridge._handleMessageFromObjC(&#x27;msg_JSON&#x27;); 其中 &#x27;msg_JSON&#x27; 就是 JSON 格式的 msg</span></span><br><span class="line">                    [<span class="keyword">self</span> _queueMessage:msg];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未取到 callbackId</span></span><br><span class="line">                responseCallback = ^(<span class="type">id</span> ignoreResponseData) &#123;</span><br><span class="line">                    <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 尝试以 handlerName 获取 iOS 端之前注册过的 handler</span></span><br><span class="line">            WVJBHandler handler = <span class="keyword">self</span>.messageHandlers[message[<span class="string">@&quot;handlerName&quot;</span>]];</span><br><span class="line">            <span class="keyword">if</span> (!handler) &#123; <span class="comment">// 没注册过，则跳过此 msg</span></span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;</span>, message);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用对应的 handler，以 message[@&quot;data&quot;] 为入参，以 responseCallback 为回调</span></span><br><span class="line">            handler(message[<span class="string">@&quot;data&quot;</span>], responseCallback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嘛~ <code>flushMessageQueue:</code> 方法作为整个 Native 端的核心，有点长是可以理解的。我们简单理一下它的实现思路：</p>
<ul>
<li>入参校验</li>
<li>将 JSON 形式的入参转换为 Native 对象，即消息队列，这里面消息类型是之前定义过的 WVJBMessage，即字典</li>
<li>如果消息中含有 “responseId” 则表明是之前 Native 调用的 JS 方法回调过来的消息（因为 JS 端和 Native 端实现逻辑是对等的，所以这个地方不明白的可以参考下面的分析）</li>
<li>如果消息中不含 “responseId” 则表明是 JS 端通过 <code>callHandler</code> 函数正常调用 Native 端过来的消息</li>
<li>尝试获取消息中的 “callbackId”，如果 JS 本次消息需要 Native 响应之后回调才会有这个键值，具体参见上文中 JS 端 <code>_doSend</code> 部分源码分析。如取到 “callbackId” 则需生成一个回调 block，回调 block 内部将 “callbackId” 作为 msg 的 “responseId” 执行 <code>_queueMessage</code> 将消息发送给 JS 端（JS 端处理消息逻辑与 Native 端一致，所以上面使用 “responseId” 判断当前消息是否为回调方法传递过来的消息是很容易理解的）</li>
<li>尝试以消息中的 “handlerName” 从 <code>messageHandlers</code>（上文提到过，是保存 Native 端注册过的 handler 的字典）取到对应的 handler block，如果取到则执行代码块，否则打印错误日志</li>
</ul>
<blockquote>
<p>Note: 这个消息处理的方法虽然长，但是逻辑清晰，而且有效的解决了 JS 与 Native 相互调用的过程中参数传递的问题（包括回调），此外 JS 端的消息处理逻辑与 Native 端保持一致，实现了逻辑对称，非常值得我们学习。</p>
</blockquote>
<h2 id="WebViewJavascriptBridge-JS-Native-调用-JS-实现解读"><a href="#WebViewJavascriptBridge-JS-Native-调用-JS-实现解读" class="headerlink" title="WebViewJavascriptBridge_JS - Native 调用 JS 实现解读"></a>WebViewJavascriptBridge_JS - Native 调用 JS 实现解读</h2><img src="/webview_javascript_bridge/javascript.jpg" class="">
<p>Emmmmm…这一章节主要讲 JS 端注入的代码，即 WebViewJavascriptBridge_JS 中的 JS 源码。由于我没做过前段，能力不足，水平有限，可能有谬误希望各位读者发现的话及时指正，感激不尽。预警，由于 JS 端和上文分析过的 Native 端逻辑对称且上文已经分析过部分 JS 端的函数，所以下面的 JS 源码没有另做拆分，为避免被大段 JS 代码糊脸不感兴趣的同学可以直接看代码后面的总结。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// window.WebViewJavascriptBridge 校验，避免重复</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒加载 window.onerror，用于打印 error 日志</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">onerror</span>) &#123;</span><br><span class="line">		<span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">msg, url, line</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: ERROR:&quot;</span> + msg + <span class="string">&quot;@&quot;</span> + url + <span class="string">&quot;:&quot;</span> + line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// window.WebViewJavascriptBridge 声明</span></span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">WebViewJavascriptBridge</span> = &#123;</span><br><span class="line">		<span class="attr">registerHandler</span>: registerHandler,</span><br><span class="line">		<span class="attr">callHandler</span>: callHandler,</span><br><span class="line">		<span class="attr">disableJavscriptAlertBoxSafetyTimeout</span>: disableJavscriptAlertBoxSafetyTimeout,</span><br><span class="line">		<span class="attr">_fetchQueue</span>: _fetchQueue,</span><br><span class="line">		<span class="attr">_handleMessageFromObjC</span>: _handleMessageFromObjC</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量声明</span></span><br><span class="line">	<span class="keyword">var</span> messagingIframe; <span class="comment">// 消息 iframe</span></span><br><span class="line">	<span class="keyword">var</span> sendMessageQueue = []; <span class="comment">// 发送消息队列</span></span><br><span class="line">	<span class="keyword">var</span> messageHandlers = &#123;&#125;; <span class="comment">// JS 端注册的消息处理 handlers 字典（囧，JS 其实叫对象）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// scheme 使用 https 之后通过 host 做匹配</span></span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> = <span class="string">&#x27;https&#x27;</span>;</span><br><span class="line">	<span class="keyword">var</span> <span class="variable constant_">QUEUE_HAS_MESSAGE</span> = <span class="string">&#x27;__wvjb_queue_message__&#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> responseCallbacks = &#123;&#125;; <span class="comment">// JS 端存放回调的字典</span></span><br><span class="line">	<span class="keyword">var</span> uniqueId = <span class="number">1</span>; <span class="comment">// 唯一标示，用于回调时生成 callbackId</span></span><br><span class="line">	<span class="keyword">var</span> dispatchMessagesWithTimeoutSafety = <span class="literal">true</span>; <span class="comment">// 默认启用安全时长</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过禁用 AlertBoxSafetyTimeout 来提速网桥消息传递</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">disableJavscriptAlertBoxSafetyTimeout</span>(<span class="params"></span>) &#123;</span><br><span class="line">		dispatchMessagesWithTimeoutSafety = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同 iOS 逻辑，注册 handler 其实是往 messageHandlers 字典中插入对应 name 的 block</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">registerHandler</span>(<span class="params">handlerName, handler</span>) &#123;</span><br><span class="line">		messageHandlers[handlerName] = handler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 调用 iOS handler，参数校验之后调用 _doSend 函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">callHandler</span>(<span class="params">handlerName, data, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如果参数只有两个且第二个参数类型为 function，则表示没有参数传递，即 data 为空</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> data == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">			responseCallback = data;</span><br><span class="line">			data = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 handlerName 和 data 作为 msg 对象参数调用 _doSend 函数</span></span><br><span class="line">		<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:handlerName, <span class="attr">data</span>:data &#125;, responseCallback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// _doSend 向 Native 端发送消息</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_doSend</span>(<span class="params">message, responseCallback</span>) &#123;</span><br><span class="line">	    <span class="comment">// 如有回调，则设置 message[&#x27;callbackId&#x27;] 与 responseCallbacks[callbackId]</span></span><br><span class="line">		<span class="keyword">if</span> (responseCallback) &#123;</span><br><span class="line">			<span class="keyword">var</span> callbackId = <span class="string">&#x27;cb_&#x27;</span>+(uniqueId++)+<span class="string">&#x27;_&#x27;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">			responseCallbacks[callbackId] = responseCallback;</span><br><span class="line">			message[<span class="string">&#x27;callbackId&#x27;</span>] = callbackId;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将 msg 加入 sendMessageQueue 数组，设置 messagingIframe.src</span></span><br><span class="line">		sendMessageQueue.<span class="title function_">push</span>(message);</span><br><span class="line">		messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列，在 iOS 端刷新消息队列时会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_fetchQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">	    <span class="comment">// 内部将发送消息队列 sendMessageQueue 转为 JSON 格式并返回</span></span><br><span class="line">		<span class="keyword">var</span> messageQueueString = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(sendMessageQueue);</span><br><span class="line">		sendMessageQueue = [];</span><br><span class="line">		<span class="keyword">return</span> messageQueueString;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// iOS 端 _dispatchMessage 函数会调用此函数</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_handleMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">	    <span class="comment">// 调度从 Native 端获取到的消息</span></span><br><span class="line">        <span class="title function_">_dispatchMessageFromObjC</span>(messageJSON);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心代码，调度从 Native 端获取到的消息，逻辑与 Native 端一致</span></span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_dispatchMessageFromObjC</span>(<span class="params">messageJSON</span>) &#123;</span><br><span class="line">		<span class="comment">// 判断有没有禁用 AlertBoxSafetyTimeout，最终会调用 _doDispatchMessageFromObjC 函数</span></span><br><span class="line">		<span class="keyword">if</span> (dispatchMessagesWithTimeoutSafety) &#123;</span><br><span class="line">			<span class="built_in">setTimeout</span>(_doDispatchMessageFromObjC);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			 <span class="title function_">_doDispatchMessageFromObjC</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 解析 msgJSON 得到 msg</span></span><br><span class="line">		<span class="keyword">function</span> <span class="title function_">_doDispatchMessageFromObjC</span>(<span class="params"></span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> message = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(messageJSON);</span><br><span class="line">			<span class="keyword">var</span> messageHandler;</span><br><span class="line">			<span class="keyword">var</span> responseCallback;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果有 responseId，则说明是回调，取对应的 responseCallback 执行，之后释放</span></span><br><span class="line">			<span class="keyword">if</span> (message.<span class="property">responseId</span>) &#123;</span><br><span class="line">				responseCallback = responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">				<span class="keyword">if</span> (!responseCallback) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="title function_">responseCallback</span>(message.<span class="property">responseData</span>);</span><br><span class="line">				<span class="keyword">delete</span> responseCallbacks[message.<span class="property">responseId</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 responseId，则表示正常的 iOS call handler 调用 js</span></span><br><span class="line">				<span class="comment">// 如 msg 包含 callbackId，说明 iOS 端需要回调，初始化对应的 responseCallback</span></span><br><span class="line">				<span class="keyword">if</span> (message.<span class="property">callbackId</span>) &#123;</span><br><span class="line">					<span class="keyword">var</span> callbackResponseId = message.<span class="property">callbackId</span>;</span><br><span class="line">					responseCallback = <span class="keyword">function</span>(<span class="params">responseData</span>) &#123;</span><br><span class="line">						<span class="title function_">_doSend</span>(&#123; <span class="attr">handlerName</span>:message.<span class="property">handlerName</span>, <span class="attr">responseId</span>:callbackResponseId, <span class="attr">responseData</span>:responseData &#125;);</span><br><span class="line">					&#125;;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">// 从 messageHandlers 拿到对应的 handler 执行</span></span><br><span class="line">				<span class="keyword">var</span> handler = messageHandlers[message.<span class="property">handlerName</span>];</span><br><span class="line">				<span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">				    <span class="comment">// 如未取到对应的 handler 则打印错误日志</span></span><br><span class="line">					<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;</span>, message);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="title function_">handler</span>(message.<span class="property">data</span>, responseCallback);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// messagingIframe 的声明，类型 iframe，样式不可见，src 设置</span></span><br><span class="line">	messagingIframe = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">	messagingIframe.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">	messagingIframe.<span class="property">src</span> = <span class="variable constant_">CUSTOM_PROTOCOL_SCHEME</span> + <span class="string">&#x27;://&#x27;</span> + <span class="variable constant_">QUEUE_HAS_MESSAGE</span>;</span><br><span class="line">	<span class="comment">// messagingIframe 加入 document.documentElement 中</span></span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="title function_">appendChild</span>(messagingIframe);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 disableJavscriptAlertBoxSafetyTimeout handler，Native 可以通过禁用 AlertBox 的安全时长来加速桥接消息</span></span><br><span class="line">	<span class="title function_">registerHandler</span>(<span class="string">&quot;_disableJavascriptAlertBoxSafetyTimeout&quot;</span>, disableJavscriptAlertBoxSafetyTimeout);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">setTimeout</span>(_callWVJBCallbacks, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">function</span> <span class="title function_">_callWVJBCallbacks</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">var</span> callbacks = <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">WVJBCallbacks</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;callbacks.<span class="property">length</span>; i++) &#123;</span><br><span class="line">			callbacks[i](<span class="title class_">WebViewJavascriptBridge</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS 端和 Native 端逻辑一致，上面的代码已经加入了详细的中文注释，上文在对于“WebViewJavascriptBridgeBase - JS 调用 Native 实现原理剖析”章节的分析过程中为了走通整个调用的逻辑已经对部分 JS 端代码进行了分析，这里我们简单的梳理一下 JS 端核心代码 <code>_doDispatchMessageFromObjC</code> 函数的逻辑：</p>
<ul>
<li>将 messageJSON 使用 JSON 解析出来</li>
<li>尝试取解析到的消息中的 responseId，如果有取到则说明是 Native 端响应 JS 端之后通过回调向 JS 端发出的消息，用 responseId 取 responseCallbacks 中对应的回调响应 block，找到后执行该 block 之后删除</li>
<li>如果没取到 responseId 则表示这条消息是 Native 端通过 <code>callHandler:data:responseCallback:</code> 正常调用 JS 注册的 handler 发送过来的消息（这里的正常是针对回调而言）</li>
<li>如果当前的消息有 callbackId 则表明 Native 端需要 JS 端响应本次消息之后回调反馈，生成一个 responseCallback 作为回调 block (JS 端是 function) ，其内部使用 <code>_doSend</code> 方法传递一个带有 responseId 的消息给 Native 端，表明此条消息是之前的回调消息</li>
<li>最后按照解析到的消息中 handlerName 从 messageHandlers，即 JS 端注册过的 handlers 中找到与名称对应的处理函数执行，如果没找到则打印附带相关信息的错误日志</li>
</ul>
<p>嘛~ 对比一下 Native 端的核心代码 <code>flushMessageQueue:</code> 看一下，很容易发现两端的处理实现是逻辑对称的。</p>
<h2 id="WebViewJavascriptBridge-的“桥梁美学”"><a href="#WebViewJavascriptBridge-的“桥梁美学”" class="headerlink" title="WebViewJavascriptBridge 的“桥梁美学”"></a>WebViewJavascriptBridge 的“桥梁美学”</h2><img src="/webview_javascript_bridge/bridge_beautiful.jpg" class="">
<p>在总结 WebViewJavascriptBridge 的“桥梁美学”之前请再回顾一下 WebViewJavascriptBridge 的工作流：</p>
<ul>
<li>JS 端加入 src 为 <code>https://__bridge_loaded__</code> 的 iframe</li>
<li>Native 端检测到 Request，检测如果是 <code>__bridge_loaded__</code> 则通过当前的 WebView 组件注入 WebViewJavascriptBridge_JS 代码</li>
<li>注入代码成功之后会加入一个 messagingIframe，其 src 为 <code>https://__wvjb_queue_message__</code></li>
<li>之后不论是 Native 端还是 JS 端都可以通过 <code>registerHandler</code> 方法注册一个两端约定好的 HandlerName 的处理，也都可以通过 <code>callHandler</code> 方法通过约定好的 HandlerName 调用另一端的处理（两端处理消息的实现逻辑对称）</li>
</ul>
<p>嘛~ 所以我们很容易列举出 WebViewJavascriptBridge 所具有的“美学”：</p>
<ul>
<li>隐性适配</li>
<li>接口对等</li>
<li>逻辑对称</li>
</ul>
<p>我们结合本文展开来说一下上面的“美学”的具体实现。</p>
<h3 id="隐性适配"><a href="#隐性适配" class="headerlink" title="隐性适配"></a>隐性适配</h3><p>WebViewJavascriptBridge 主要是作为 Mac OS X 和 iOS 端（Native 端）与 JS 端相互通信，互相调用的桥梁。对于 Mac OS X 和 iOS 两种平台包含的三种 WebView 功能组件而言，WebViewJavascriptBridge 做了隐性适配，即仅用一套代码即可绑定不同平台的 WebView 组件实现同样功能的 JS 通信功能，这一点非常方便。</p>
<h3 id="接口对等"><a href="#接口对等" class="headerlink" title="接口对等"></a>接口对等</h3><p>WebViewJavascriptBridge 对于 JS 端和 Native 端设计了对等的接口，不论是 JS 端还是 Native 端，注册本端的响应处理都是用 <code>registerHandler</code> 接口，调用另一端（给另一端发消息）都是用 <code>callHandler</code> 接口。</p>
<p>这样做是非常合理的，因为不论是 JS 端还是 Native 端，作为通信的双方就通信本身而言是处于对等的地位的。这就好比一座大桥连接两块陆地，两地用大桥相互运输货物并接收资源，两块陆地在大桥的运输使用过程中逻辑上也是地位对等的。</p>
<h3 id="逻辑对称"><a href="#逻辑对称" class="headerlink" title="逻辑对称"></a>逻辑对称</h3><p>WebViewJavascriptBridge 在 JS 端和 Native 端对发送过来的消息有着相同逻辑的处理实现，如果考虑到收发双方的身份则可以把逻辑相同看做逻辑对称。</p>
<p>这种实现方式依旧非常合理，被桥连接的两块大陆在装货上桥和下桥卸货这两处逻辑上就应该是对称的。</p>
<p>嘛~ 说到这里就不得不祭出一个词来形容 WebViewJavascriptBridge 了，这个词就是<strong>优雅</strong>（笑）。当大家结合 WebViewJavascriptBridge 源码阅读本文之后不难发现其整个架构和设计思想跟现实桥梁设计中很多设计思想不谋而合，比如桥一般会分为左右桥幅，而左右幅桥一般只有一条线路中心线，即一个前进方向，用于桥上单一方向的资源传输，左右桥幅在功能上对等。</p>
<h2 id="文章总结"><a href="#文章总结" class="headerlink" title="文章总结"></a>文章总结</h2><ul>
<li>文章系统分析了 WebViewJavascriptBridge 源码，希望各位读者能够在阅读本文之后对 WebViewJavascriptBridge 的架构有一个整体认识。</li>
<li>文章对 WebViewJavascriptBridge 在 JS 端和 Native 端的消息处理实现做了深入剖析，希望可以对各位读者这部分源码的理解提供一些微薄的帮助。</li>
<li>总结了 WebViewJavascriptBridge 作为一个 JSBridge 框架所具有的优势，即文中所指的“桥梁美学”，期望可以对大家以后自己封装一个 JSBridge 提供思路，抛砖引玉。</li>
</ul>
<p>Emmmmm…不过需要注意的是 WebViewJavascriptBridge 仅仅是作为 JSBridge 层用于提供 JS 和 Native 之间相互传递消息的基础支持的。如果想要封装自己项目中的 WebView 组件还需要另外实现 HTTP cookie 注入，自定义 User-Agent，白名单或者权限校验等功能，更进一步还需要对 WebView 组件进行初始化速度，页面渲染速度以及页面缓存策略的优化。我之后<strong>也许可能大概应该</strong>会写一篇文章分享一下自己封装 WebView 组件时踩到的一些坑以及经验，因为自己水平有限…所以也可能不会写（笑）。</p>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/ios_native_js/">
      iOS 与 JS 交互开发知识总结
    </a>
  </h2>
  
  <time>
    10月 23, 2017
  </time>
  <section class="content">
	  <img src="/ios_native_js/hybrid.jpg" class="">
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 页面中的 JS 与 iOS Native 如何交互是每个 iOS 猿必须掌握的技能。而说到 Native 与 JS 交互，就不得不提一嘴 Hybrid。</p>
<p>Hybrid 的翻译结果并不是很文明（擦汗，不知道为啥很多翻译软件会译为“杂种”，但我更喜欢将它翻译为“混合、混血”），Hybrid Mobile App 我对它的理解为通过 Web 网络技术（如 HTML，CSS 和 JavaScript）与 Native 相结合的混合移动应用程序。</p>
<p>那么我们来看一下 Hybrid 对比 Native 有哪些优劣：</p>
<img src="/ios_native_js/hybrid_vs_native.jpg" class="">
<p>因为 Hybrid 的灵活性（更改 Web 页面不必重新发版）以及通用性（一份 H5 玩遍所有平台）再加上门槛低（前端猿可以无痛上手开撸）的优势，所以在非核心功能模块使用 Web 通过 Hybrid 的方式来实现可能从各方面都会优于 Native。而 Native 则可以在核心功能和设备硬件的调用上为 JS 提供强有力的支持。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>Hybrid 的发展简史</li>
<li>JavaScriptCore 简介</li>
<li>iOS Native 与 JS 交互的方法</li>
<li>WKWebView 与 JS 交互的特有方法</li>
<li>JS 通过 Native 调用 iOS 设备摄像头的 Demo</li>
<li>总结</li>
</ul>
<h2 id="Hybrid-的发展简史"><a href="#Hybrid-的发展简史" class="headerlink" title="Hybrid 的发展简史"></a>Hybrid 的发展简史</h2><p>下面简述一下 Hybrid 的发展史：</p>
<h3 id="1-H5-发布"><a href="#1-H5-发布" class="headerlink" title="1.H5 发布"></a>1.H5 发布</h3><img src="/ios_native_js/html5.png" class="">
<p>Html5 是在 2014 年 9 月份正式发布的，这一次的发布做了一个最大的改变就是“从以前的 XML 子集升级成为一个独立集合”。</p>
<h3 id="2-H5-渗入-Mobile-App-开发"><a href="#2-H5-渗入-Mobile-App-开发" class="headerlink" title="2.H5 渗入 Mobile App 开发"></a>2.H5 渗入 Mobile App 开发</h3><p>Native APP 开发中有一个 webview 的组件（Android 中是 webview，iOS 有 UIWebview和 WKWebview），这个组件可以加载 Html 文件。</p>
<p>在 H5 大行其道之前，webview 加载的 web 页面很单调（因为只能加载一些静态资源），自从 H5 火了之后，前端猿们开发的 H5 页面在 webview 中的表现不俗使得 H5 开发慢慢渗透到了 Mobile App 开发中来。</p>
<h3 id="3-Hybrid-现状"><a href="#3-Hybrid-现状" class="headerlink" title="3.Hybrid 现状"></a>3.Hybrid 现状</h3><p>虽然目前已经出现了 RN 和 Weex 这些使用 JS 写 Native App 的技术，但是 Hybrid 仍然没有被淘汰，市面上大多数应用都不同程度的引入了 Web 页面。</p>
<h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>JavaScriptCore 这个库是 Apple 在 iOS 7 之后加入到标准库的，它对 iOS Native 与 JS 做交互调用产生了划时代的影响。</p>
<p>JavaScriptCore 大体是由 4 个类以及 1 个协议组成的：</p>
<img src="/ios_native_js/javascriptcore_framework.jpg" class="">
<ul>
<li>JSContext 是 JS 执行上下文，你可以把它理解为 JS 运行的环境。</li>
<li>JSValue 是对 JavaScript 值的引用，任何 JS 中的值都可以被包装为一个 JSValue。</li>
<li>JSManagedValue 是对 JSValue 的包装，加入了“conditional retain”。</li>
<li>JSVirtualMachine 表示 JavaScript 执行的独立环境。</li>
</ul>
<p>还有 JSExport 协议：</p>
<blockquote>
<p>实现将 Objective-C 类及其实例方法，类方法和属性导出为 JavaScript 代码的协议。</p>
</blockquote>
<p>这里的 JSContext，JSValue，JSManagedValue 相对比较好理解，下面我们把 JSVirtualMachine 单拎出来说明一下：</p>
<h3 id="JSVirtualMachine-的用法和其与-JSContext-的关系"><a href="#JSVirtualMachine-的用法和其与-JSContext-的关系" class="headerlink" title="JSVirtualMachine 的用法和其与 JSContext 的关系"></a>JSVirtualMachine 的用法和其与 JSContext 的关系</h3><img src="/ios_native_js/jsvirtualmachine.jpg" class="">
<p>官方文档的介绍：</p>
<blockquote>
<p>JSVirtualMachine 实例表示用于 JavaScript 执行的独立环境。 您使用此类有两个主要目的：支持并发 JavaScript 执行，并管理 JavaScript 和 Objective-C 或 Swift 之间桥接的对象的内存。</p>
</blockquote>
<p>关于 JSVirtualMachine 的使用，一般情况下我们不用手动去创建 JSVirtualMachine。因为当我们获取 JSContext 时，获取到的 JSContext 从属于一个 JSVirtualMachine。</p>
<p>每个 JavaScript 上下文（JSContext 对象）都属于一个 JSVirtualMachine。 每个 JSVirtualMachine 可以包含多个上下文，允许在上下文之间传递值（JSValue 对象）。 但是，每个 JSVirtualMachine 是不同的，即我们不能将一个 JSVirtualMachine 中创建的值传递到另一个 JSVirtualMachine 中的上下文。</p>
<p>JavaScriptCore API 是线程安全的 —— 例如，我们可以从任何线程创建 JSValue 对象或运行 JS 脚本 - 但是，尝试使用相同 JSVirtualMachine 的所有其他线程将被阻塞。 要在多个线程上同时（并发）运行 JavaScript 脚本，请为每个线程使用单独的 JSVirtualMachine 实例。</p>
<h3 id="JSValue-与-JavaScript-的转换表"><a href="#JSValue-与-JavaScript-的转换表" class="headerlink" title="JSValue 与 JavaScript 的转换表"></a>JSValue 与 JavaScript 的转换表</h3><table>
<thead>
<tr>
<th>OBJECTIVE-C</th>
<th>JAVASCRIPT</th>
<th>JSVALUE CONVERT</th>
<th>JSVALUE CONSTRUCTOR</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil</td>
<td>undefined</td>
<td></td>
<td>valueWithUndefinedInContext</td>
</tr>
<tr>
<td>NSNull</td>
<td>null</td>
<td></td>
<td>valueWithNullInContext:</td>
</tr>
<tr>
<td>NSString</td>
<td>string</td>
<td>toString</td>
<td></td>
</tr>
<tr>
<td>NSNumber</td>
<td>number, boolean</td>
<td>toNumber<br />toBool<br />toDouble<br />toInt32<br />toUInt32</td>
<td>valueWithBool:inContext:<br />valueWithDouble:inContext:<br />valueWithInt32:inContext:<br />valueWithUInt32:inContext:</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Object object</td>
<td>toDictionary</td>
<td>valueWithNewObjectInContext:</td>
</tr>
<tr>
<td>NSArray</td>
<td>Array object</td>
<td>toArray</td>
<td>valueWithNewArrayInContext:</td>
</tr>
<tr>
<td>NSDate</td>
<td>Date object</td>
<td>toDate</td>
<td></td>
</tr>
<tr>
<td>NSBlock</td>
<td>Function object</td>
<td></td>
<td></td>
</tr>
<tr>
<td>id</td>
<td>Wrapper object</td>
<td>toObject<br />toObjectOfClass:</td>
<td>valueWithObject:inContext:</td>
</tr>
<tr>
<td>Class</td>
<td>Constructor object</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="iOS-Native-与-JS-交互"><a href="#iOS-Native-与-JS-交互" class="headerlink" title="iOS Native 与 JS 交互"></a>iOS Native 与 JS 交互</h2><p>对于 iOS Native 与 JS 交互我们先从调用方向上分为两种情况来看：</p>
<ul>
<li>JS 调用 Native</li>
<li>Native 调用 JS</li>
</ul>
<img src="/ios_native_js/call_eachother.jpg" class="">
<h3 id="JS-调用-Native"><a href="#JS-调用-Native" class="headerlink" title="JS 调用 Native"></a>JS 调用 Native</h3><p>其实 JS 调用 iOS Native 也分为两种实现方式：</p>
<ul>
<li>假 Request 方法</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="假-Request-方法"><a href="#假-Request-方法" class="headerlink" title="假 Request 方法"></a>假 Request 方法</h4><p>原理：其实这种方式就是利用了 webview 的代理方法，在 webview 开始请求的时候截获请求，判断请求是否为约定好的假请求。如果是假请求则表示是 JS 想要按照约定调用我们的 Native 方法，按照约定去执行我们的 Native 代码就好。</p>
<h5 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 代理有用于截获请求的函数，在里面做判断就好：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">BOOL</span>)webView:(<span class="built_in">UIWebView</span> *)webView shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span> *)request navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>WKWebView 有两个代理，一个是 WKNavigationDelegate，另一个是 WKUIDelegate。WKUIDelegate 我们在下面的章节会讲到，这里我们需要设置并实现它的 WKNavigationDelegate 方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="type">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler &#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = navigationAction.request.URL;</span><br><span class="line">    <span class="comment">// 与约定好的函数名作比较</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@&quot;your_func_name&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// just do it</span></span><br><span class="line">        decisionHandler(<span class="built_in">WKNavigationActionPolicyCancel</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(<span class="built_in">WKNavigationActionPolicyAllow</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: <code>decisionHandler</code> 是当你的应用程序决定是允许还是取消导航时，要调用的代码块。 该代码块使用单个参数，它必须是枚举类型 <code>WKNavigationActionPolicy</code> 的常量之一。如果不调用 <code>decisionHandler</code> 会引起 crash。</p>
</blockquote>
<p>这里补充一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callNative</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">loadURL</span>(<span class="string">&quot;your_func_name://xxx&quot;</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>然后拿个 button 标签用一下就好了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot; onclick=&quot;callNative()&quot;&gt;Call Native!&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="JavaScriptCore-方法"><a href="#JavaScriptCore-方法" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>iOS 7 有了 JavaScriptCore 专门用来做 Native 与 JS 的交互。我们可以在 webview 完成加载之后获取 JSContext，然后利用 JSContext 将 JS 中的对象引用过来用 Native 代码对其作出解释或响应：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再 UIWebView 的完成加载的代理方法中</span></span><br><span class="line">- (<span class="type">void</span>)webViewDidFinishLoad:(<span class="built_in">UIWebView</span> *)webView &#123;</span><br><span class="line">    <span class="comment">// 获取 JS 上下文</span></span><br><span class="line">    jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line">    <span class="comment">// 做引用，将 JS 内的元素引用过来解释，比如方法可以解释成 Block，对象也可以指向 OC 的 Native 对象哦</span></span><br><span class="line">    jsContext[<span class="string">@&quot;iosDelegate&quot;</span>] = <span class="keyword">self</span>;</span><br><span class="line">    jsContext[<span class="string">@&quot;yourFuncName&quot;</span>] = ^(<span class="type">id</span> parameter)&#123;</span><br><span class="line">        <span class="comment">// 注意这里的线程默认是 web 处理的线程，如果涉及主线程操作需要手动转到主线程</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">// your code</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 JS 这边代码更简单了，干脆声明一个不解释的函数（约定好名字的），用于给 Native 做引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parameter = xxx;</span><br><span class="line"><span class="title function_">yourFuncName</span>(parameter);</span><br></pre></td></tr></table></figure>
<h3 id="iOS-Native-调用-JS"><a href="#iOS-Native-调用-JS" class="headerlink" title="iOS Native 调用 JS"></a>iOS Native 调用 JS</h3><p>iOS Native 调用 JS 的实现方法也被 JavaScriptCore 划分开来：</p>
<ul>
<li>webview 直接注入 JS 并执行</li>
<li>JavaScriptCore 方法</li>
</ul>
<h4 id="webview-直接注入-JS-并执行"><a href="#webview-直接注入-JS-并执行" class="headerlink" title="webview 直接注入 JS 并执行"></a>webview 直接注入 JS 并执行</h4><p>在 iOS 平台，webview 有注入并执行 JS 的 API。</p>
<h5 id="UIWebView-1"><a href="#UIWebView-1" class="headerlink" title="UIWebView"></a>UIWebView</h5><p>UIWebView 有直接注入 JS 的方法：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;showAlert(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;alert msg&quot;</span>];</span><br><span class="line">[_webView stringByEvaluatingJavaScriptFromString:jsStr];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 这个方法会返回运行 JS 的结果（<code>nullable NSString *</code>），它是一个同步方法，会阻塞当前线程！尽管此方法不被弃用，但最佳做法是使用 <code>WKWebView</code> 类的 <code>evaluateJavaScript：completionHandler：method</code>。</p>
<p>官方文档：<br>The stringByEvaluatingJavaScriptFromString: method waits synchronously for JavaScript evaluation to complete. If you load web content whose JavaScript code you have not vetted, invoking this method could hang your app. Best practice is to adopt the WKWebView class and use its evaluateJavaScript:completionHandler: method instead.</p>
</blockquote>
<h5 id="WKWebView-1"><a href="#WKWebView-1" class="headerlink" title="WKWebView"></a>WKWebView</h5><p>不同于 UIWebView，WKWebView 注入并执行 JS 的方法不会阻塞当前线程。因为考虑到 webview 加载的 web content 内 JS 代码不一定经过验证，如果阻塞线程可能会挂起 App。</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *jsStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;setLocation(&#x27;%@&#x27;)&quot;</span>, <span class="string">@&quot;北京市东城区南锣鼓巷纳福胡同xx号&quot;</span>];</span><br><span class="line">[_webview evaluateJavaScript:jsStr completionHandler:^(<span class="type">id</span> _Nullable result, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@----%@&quot;</span>, result, error);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: 方法不会阻塞线程，而且它的回调代码块总是在主线程中运行。</p>
<p>官方文档：<br>Evaluates a JavaScript string.<br>The method sends the result of the script evaluation (or an error) to the completion handler. The completion handler always runs on the main thread.</p>
</blockquote>
<h4 id="JavaScriptCore-方法-1"><a href="#JavaScriptCore-方法-1" class="headerlink" title="JavaScriptCore 方法"></a>JavaScriptCore 方法</h4><p>上面简单提到过 JavaScriptCore 库提供的 JSValue 类，这里再提供一下官方文档对 JSValue 的介绍翻译：</p>
<blockquote>
<p>JSValue 实例是对 JavaScript 值的引用。 您可以使用 JSValue 类来转换 JavaScript 和 Objective-C 或 Swift 之间的基本值（如数字和字符串），以便在本机代码和 JavaScript 代码之间传递数据。</p>
</blockquote>
<p>不过你也看到了我贴在上面的 OC 和 JS 数据类型转换表，那里面根本没有限定为官方文档所说的基本值。如果你不熟悉 JS 的话，我这里解释一下为什么 JSValue 也可以指向 JS 中的对象和函数，因为 JS 语言不区分基本值和对象以及函数，在 JS 中“万物皆为对象”。</p>
<p>好了下面直接 show code：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 JavaScriptCore 库</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先获取 JS 上下文</span></span><br><span class="line"><span class="keyword">self</span>.jsContext = [webView valueForKeyPath:<span class="string">@&quot;documentView.webView.mainFrame.javaScriptContext&quot;</span>];</span><br><span class="line"><span class="comment">// 如果涉及 UI 操作，切回主线程调用 JS 代码中的 YourFuncName，通过数组@[parameter] 入参</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    JSValue *jsValue = <span class="keyword">self</span>.jsContext[<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">    [jsValue callWithArguments:@[parameter]];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码调用了 JS 代码中 YourFuncName 函数，并且给函数加了 @[parameter] 作为入参。为了方便阅读理解，这里再贴一下 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">YourFuncName</span>(<span class="params"><span class="variable language_">arguments</span></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="variable language_">arguments</span>;</span><br><span class="line">    <span class="comment">// do what u want to do</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WKWebView-与-JS-交互的特有方法"><a href="#WKWebView-与-JS-交互的特有方法" class="headerlink" title="WKWebView 与 JS 交互的特有方法"></a>WKWebView 与 JS 交互的特有方法</h2><img src="/ios_native_js/wkwebview.jpg" class="">
<p>关于 WKWebView 与 UIWebView 的区别就不在本文加以详细说明了，更多信息还请自行查阅。这里要讲的是 WKWebView 在与 JS 的交互时特有的方法：</p>
<ul>
<li>WKUIDelegate 方法</li>
<li>MessageHandler 方法</li>
</ul>
<h3 id="WKUIDelegate-方法"><a href="#WKUIDelegate-方法" class="headerlink" title="WKUIDelegate 方法"></a>WKUIDelegate 方法</h3><p>对于 WKWebView 上文提到过，除了 WKNavigationDelegate，它还有一个 WKUIDelegate，这个 WKUIDelegate 是做什么用的呢？ </p>
<p>WKUIDelegate 协议包含一些函数用来监听 web JS 想要显示 alert 或 confirm 时触发。我们如果在 WKWebView 中加载一个 web 并且想要 web JS 的 alert 或 confirm 正常弹出，就需要实现对应的代理方法。</p>
<blockquote>
<p>Note: 如果没有实现对应的代理方法，则 webview 将会按照默认操作去做出行为。</p>
<ul>
<li>Alert: If you do not implement this method, the web view will behave as if the user selected the OK button.</li>
<li>Confirm: If you do not implement this method, the web view will behave as if the user selected the Cancel button.</li>
</ul>
</blockquote>
<p>我们这里就拿 alert 举例，相信各位读者可以自己举一反三。下面是在 WKUIDelegate 监听 web 要显示 alert 的代理方法中用 Native UIAlertController 替代 JS 中的 alert 显示的栗子 ：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="type">void</span> (^)(<span class="type">void</span>))completionHandler &#123;</span><br><span class="line">    <span class="comment">// 用 Native 的 UIAlertController 弹窗显示 JS 将要提示的信息</span></span><br><span class="line">    <span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@&quot;提醒&quot;</span> message:message preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    [alert addAction:[<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@&quot;知道了&quot;</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="comment">// 函数内必须调用 completionHandler</span></span><br><span class="line">        completionHandler();</span><br><span class="line">    &#125;]];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MessageHandler-方法"><a href="#MessageHandler-方法" class="headerlink" title="MessageHandler 方法"></a>MessageHandler 方法</h3><p>MessageHandler 是继 Native 截获 JS 假请求后另一种 JS 调用 Native 的方法，该方法利用了 WKWebView 的新特性实现。对比截获假 Request 的方法来说，MessageHandler 传参数更加简单方便。</p>
<h4 id="MessageHandler-指什么？"><a href="#MessageHandler-指什么？" class="headerlink" title="MessageHandler 指什么？"></a>MessageHandler 指什么？</h4><p>WKUserContentController 类有一个方法:<br><figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)addScriptMessageHandler:(<span class="type">id</span> &lt;<span class="built_in">WKScriptMessageHandler</span>&gt;)scriptMessageHandler name:(<span class="built_in">NSString</span> *)name;</span><br></pre></td></tr></table></figure><br>该方法用来添加一个脚本处理器，可以在处理器内对 JS 脚本调用的方法做出处理，从而达到 JS 调用 Native 的目的。</p>
<p>那么 WKUserContentController 类和 WKWebView 有毛关系呢？</p>
<p>在 WKWebView 的初始化函数中有一个入参 configuration，它的类型是 WKWebViewConfiguration。WKWebViewConfiguration 中包含一个属性 userContentController，这个 userContentController 就是 WKUserContentController 类型的实例，我们可以用这个 userContentController 来添加不同名称的脚本处理器。</p>
<img src="/ios_native_js/wkusercontentcontroller.jpg" class="">
<h5 id="MessageHandler-的坑"><a href="#MessageHandler-的坑" class="headerlink" title="MessageHandler 的坑"></a>MessageHandler 的坑</h5><p>那么回到 <code>- (void)addScriptMessageHandler:name:</code> 方法上面，该方法添加一个脚本消息处理器（第一个入参 scriptMessageHandler），并且给这个处理器起一个名字（第二个入参 name）。不过这个函数在使用的时候有个坑：scriptMessageHandler 入参会被强引用，那么如果你把当前 WKWebView 所在的 UIViewController 作为第一个入参，这个 viewController 被他自己所持有的 <code>webview.configuration. userContentController</code> 所持有，就会造成循环引用。</p>
<img src="/ios_native_js/retaincycle.jpg" class="">
<p>我们可以通过 <code>- (void)removeScriptMessageHandlerForName:</code> 方法删掉 userContentController 对 viewController 的强引用。所以一般情况下我们的代码会在 <code>viewWillAppear</code> 和 <code>viewWillDisappear</code> 成对儿的添加和删除 MessageHandler：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)viewWillAppear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillAppear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController addScriptMessageHandler:<span class="keyword">self</span> name:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)viewWillDisappear:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="variable language_">super</span> viewWillDisappear:animated];</span><br><span class="line">    [<span class="keyword">self</span>.webview.configuration.userContentController removeScriptMessageHandlerForName:<span class="string">@&quot;YourFuncName&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="WKScriptMessageHandler-协议"><a href="#WKScriptMessageHandler-协议" class="headerlink" title="WKScriptMessageHandler 协议"></a>WKScriptMessageHandler 协议</h5><p>WKScriptMessageHandler 是脚本信息处理器协议，如果想让一个对象具有脚本信息处理能力（比如上文中 webview 的所属 viewController 也就是上面代码的 self）就必须使其遵循该协议。</p>
<p>WKScriptMessageHandler 协议内部非常简单，只有一个方法，我们必须要实现该方法（@required）：</p>
<figure class="highlight obj-c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WKScriptMessageHandler 协议方法，在接收到脚本信息时触发</span></span><br><span class="line">- (<span class="type">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message &#123;</span><br><span class="line">    <span class="comment">// message 有两个属性：name 和 body</span></span><br><span class="line">    <span class="comment">// message.name 可以用于区别要做的处理</span></span><br><span class="line">    <span class="keyword">if</span> ([message.name isEqualToString:<span class="string">@&quot;YourFuncName&quot;</span>]) &#123;</span><br><span class="line">        <span class="comment">// message.body 相当于 JS 传递过来的参数</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;JS call native success %@&quot;</span>, message.body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补充 JS 的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;name&gt; 换 YourFuncName，&lt;messageBody&gt; 换你要的入参即可</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">webkit</span>.<span class="property">messageHandlers</span>.&lt;name&gt;.<span class="title function_">postMessage</span>(&lt;messageBody&gt;)</span><br></pre></td></tr></table></figure>
<p>搞定收工！</p>
<h2 id="JS-通过-Native-调用-iOS-设备摄像头的-Demo"><a href="#JS-通过-Native-调用-iOS-设备摄像头的-Demo" class="headerlink" title="JS 通过 Native 调用 iOS 设备摄像头的 Demo"></a>JS 通过 Native 调用 iOS 设备摄像头的 Demo</h2><p>徒手撸了一个 Demo，实现了 JS 与 Native 代码的交互，达到用 JS 在 webview 内调用 iOS 设备摄像头的功能。Demo 内含权限申请，用户拒绝授权等细节（技术上就是 JS 和 Native 相互传值调用），还请各位大佬指教。</p>
<p>向各位基佬低头，献上我的膝盖~<a target="_blank" rel="noopener" href="https://github.com/Lision/HybridCameraDemo">（Demo 地址）</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这篇文章简单的介绍了一下 Hybrid Mobile App（其中还包括 Hybrid 的发展简史）。</li>
<li>介绍了 JavaScriptCore 的组成，并且把 JSVirtualMachine 与 JSContext 和 JSValue 之间的关系用图片的形式表述出来（JSVirtualMachine 包含 JSContext 包含 JSValue，都是 1 对 n 的关系，且由于同一个 JSVirtualMachine 下的代码会相互阻塞，所以如果想异步执行交互需要在不同的线程声明 JSVirtualMachine 并发执行）。</li>
<li>从调用方向的角度把 JS 与 iOS Native 相互调用的方式方法分别用代码示例讲解了一遍。</li>
<li>介绍了 WKWebView 与 JS 交互特有的方法：WKUIDelegate 和 MessageHandler。</li>
<li>提供了一个 JS 通过 Native 调用 iOS 设备摄像头的 Demo。</li>
</ul>
<p>文章写得比较用心（是我个人的原创文章，转载请注明 <a href="https://lision.me/">https://lision.me/</a>），如果发现错误会优先在我的 <a href="https://lision.me/">个人博客</a> 中更新。如果有任何问题欢迎在我的微博 <a target="_blank" rel="noopener" href="https://weibo.com/lisioncode">@Lision</a> 联系我~</p>
<p>希望我的文章可以为你带来价值~</p>


    
    
    
	  <div class="tags">
      <a class="tag-none-link" href="/tags/hybrid/" rel="tag">hybrid</a><a class="tag-none-link" href="/tags/jsbridge/" rel="tag">jsbridge</a>
	  </div>
    

  </section>
</article>
  
</section>


      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <script>
      (function() {
        var cx = '001858749347000340533:drswradlp64';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:searchbox-only></gcse:searchbox-only>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:lisionmail@gmail.com" class="social email"
          target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/Lision" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="https://twitter.com/LisionChat" class="social twitter"
          target="_blank" rel="external">
          <span class="icon icon-twitter"></span>
        </a>
      
        <a href="https://weibo.com/lisioncode" class="social sina-weibo"
          target="_blank" rel="external">
          <span class="icon icon-sina-weibo"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">聊宅</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  
<script>
  var disqus_shortname = 'lision-me';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>




<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "AIzaSyAMIoydL742ROhE6lLk9n3hT0pZwbrXD_I";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "001858749347000340533:drswradlp64";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
